(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[1],{

/***/ "./node_modules/ng-diff-match-patch/dist/diff.directive.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ng-diff-match-patch/dist/diff.directive.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar core_1 = __webpack_require__(/*! @angular/core */ \"./node_modules/@angular/core/fesm5/core.js\");\nvar diffMatchPatch_service_1 = __webpack_require__(/*! ./diffMatchPatch.service */ \"./node_modules/ng-diff-match-patch/dist/diffMatchPatch.service.js\");\nvar DiffDirective = (function () {\n    function DiffDirective(el, dmp) {\n        this.el = el;\n        this.dmp = dmp;\n    }\n    DiffDirective.prototype.ngOnInit = function () {\n        this.updateHtml();\n    };\n    DiffDirective.prototype.ngOnChanges = function () {\n        this.updateHtml();\n    };\n    DiffDirective.prototype.updateHtml = function () {\n        this.el.nativeElement.innerHTML = this.createHtml(this.dmp.getDiff(this.left, this.right));\n    };\n    DiffDirective.prototype.createHtml = function (diffs) {\n        var html;\n        html = '<div>';\n        for (var _i = 0, diffs_1 = diffs; _i < diffs_1.length; _i++) {\n            var diff = diffs_1[_i];\n            diff[1] = diff[1].replace(/\\n/g, '<br/>');\n            if (diff[0] === 0 /* Equal */) {\n                html += diff[1];\n            }\n            if (diff[0] === -1 /* Delete */) {\n                html += '<del>' + diff[1] + '</del>';\n            }\n            if (diff[0] === 1 /* Insert */) {\n                html += '<ins>' + diff[1] + '</ins>';\n            }\n        }\n        html += '</div>';\n        return html;\n    };\n    __decorate([\n        core_1.Input(),\n        __metadata(\"design:type\", String)\n    ], DiffDirective.prototype, \"left\", void 0);\n    __decorate([\n        core_1.Input(),\n        __metadata(\"design:type\", String)\n    ], DiffDirective.prototype, \"right\", void 0);\n    DiffDirective = __decorate([\n        core_1.Directive({\n            selector: '[diff]'\n        }),\n        __metadata(\"design:paramtypes\", [core_1.ElementRef,\n            diffMatchPatch_service_1.DiffMatchPatchService])\n    ], DiffDirective);\n    return DiffDirective;\n}());\nexports.DiffDirective = DiffDirective;\n//# sourceMappingURL=diff.directive.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmctZGlmZi1tYXRjaC1wYXRjaC9kaXN0L2RpZmYuZGlyZWN0aXZlLmpzP2QzZDIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQsYUFBYSxtQkFBTyxDQUFDLGlFQUFlO0FBQ3BDLCtCQUErQixtQkFBTyxDQUFDLG1HQUEwQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHFCQUFxQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmctZGlmZi1tYXRjaC1wYXRjaC9kaXN0L2RpZmYuZGlyZWN0aXZlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb3JlXCIpO1xudmFyIGRpZmZNYXRjaFBhdGNoX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL2RpZmZNYXRjaFBhdGNoLnNlcnZpY2VcIik7XG52YXIgRGlmZkRpcmVjdGl2ZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGlmZkRpcmVjdGl2ZShlbCwgZG1wKSB7XG4gICAgICAgIHRoaXMuZWwgPSBlbDtcbiAgICAgICAgdGhpcy5kbXAgPSBkbXA7XG4gICAgfVxuICAgIERpZmZEaXJlY3RpdmUucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZUh0bWwoKTtcbiAgICB9O1xuICAgIERpZmZEaXJlY3RpdmUucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZUh0bWwoKTtcbiAgICB9O1xuICAgIERpZmZEaXJlY3RpdmUucHJvdG90eXBlLnVwZGF0ZUh0bWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZWwubmF0aXZlRWxlbWVudC5pbm5lckhUTUwgPSB0aGlzLmNyZWF0ZUh0bWwodGhpcy5kbXAuZ2V0RGlmZih0aGlzLmxlZnQsIHRoaXMucmlnaHQpKTtcbiAgICB9O1xuICAgIERpZmZEaXJlY3RpdmUucHJvdG90eXBlLmNyZWF0ZUh0bWwgPSBmdW5jdGlvbiAoZGlmZnMpIHtcbiAgICAgICAgdmFyIGh0bWw7XG4gICAgICAgIGh0bWwgPSAnPGRpdj4nO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGRpZmZzXzEgPSBkaWZmczsgX2kgPCBkaWZmc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGRpZmYgPSBkaWZmc18xW19pXTtcbiAgICAgICAgICAgIGRpZmZbMV0gPSBkaWZmWzFdLnJlcGxhY2UoL1xcbi9nLCAnPGJyLz4nKTtcbiAgICAgICAgICAgIGlmIChkaWZmWzBdID09PSAwIC8qIEVxdWFsICovKSB7XG4gICAgICAgICAgICAgICAgaHRtbCArPSBkaWZmWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRpZmZbMF0gPT09IC0xIC8qIERlbGV0ZSAqLykge1xuICAgICAgICAgICAgICAgIGh0bWwgKz0gJzxkZWw+JyArIGRpZmZbMV0gKyAnPC9kZWw+JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkaWZmWzBdID09PSAxIC8qIEluc2VydCAqLykge1xuICAgICAgICAgICAgICAgIGh0bWwgKz0gJzxpbnM+JyArIGRpZmZbMV0gKyAnPC9pbnM+JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBodG1sICs9ICc8L2Rpdj4nO1xuICAgICAgICByZXR1cm4gaHRtbDtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbiAgICBdLCBEaWZmRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJsZWZ0XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuICAgIF0sIERpZmZEaXJlY3RpdmUucHJvdG90eXBlLCBcInJpZ2h0XCIsIHZvaWQgMCk7XG4gICAgRGlmZkRpcmVjdGl2ZSA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBjb3JlXzEuRGlyZWN0aXZlKHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnW2RpZmZdJ1xuICAgICAgICB9KSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtjb3JlXzEuRWxlbWVudFJlZixcbiAgICAgICAgICAgIGRpZmZNYXRjaFBhdGNoX3NlcnZpY2VfMS5EaWZmTWF0Y2hQYXRjaFNlcnZpY2VdKVxuICAgIF0sIERpZmZEaXJlY3RpdmUpO1xuICAgIHJldHVybiBEaWZmRGlyZWN0aXZlO1xufSgpKTtcbmV4cG9ydHMuRGlmZkRpcmVjdGl2ZSA9IERpZmZEaXJlY3RpdmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kaWZmLmRpcmVjdGl2ZS5qcy5tYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/ng-diff-match-patch/dist/diff.directive.js\n");

/***/ }),

/***/ "./node_modules/ng-diff-match-patch/dist/diffMatchPatch.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ng-diff-match-patch/dist/diffMatchPatch.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Class containing the diff, match and patch methods.\n * @constructor\n */\nvar DiffMatchPatch = (function () {\n    function DiffMatchPatch() {\n        // Defaults.\n        // Redefine these in your program to override the defaults.\n        // Number of seconds to map a diff before giving up (0 for infinity).\n        this.Diff_Timeout = 1.0;\n        // Cost of an empty edit operation in terms of edit characters.\n        this.Diff_EditCost = 4;\n        // At what point is no match declared (0.0 = perfection, 1.0 = very loose).\n        this.Match_Threshold = 0.5;\n        // How far to search for a match (0 = exact location, 1000+ = broad match).\n        // A match this many characters away from the expected location will add\n        // 1.0 to the score (0.0 is a perfect match).\n        this.Match_Distance = 1000;\n        // When deleting a large block of text (over ~64 characters), how close do\n        // the contents have to be to match the expected contents. (0.0 = perfection,\n        // 1.0 = very loose).  Note that Match_Threshold controls how closely the\n        // end points of a delete need to match.\n        this.Patch_DeleteThreshold = 0.5;\n        // Chunk size for context length.\n        this.Patch_Margin = 4;\n        // The number of bits in an int.\n        this.Match_MaxBits = 32;\n        /**\n         * The data structure representing a diff is an array of tuples:\n         * [[DiffOp.Delete, 'Hello'], [DiffOp.Insert, 'Goodbye'], [DiffOp.Equal, ' world.']]\n         * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\n         */\n        // Define some regex patterns for matching boundaries.\n        this.whitespaceRegex_ = new RegExp('/\\s/');\n        this.linebreakRegex_ = new RegExp('/[\\r\\n]/');\n        this.blanklineEndRegex_ = new RegExp('/\\n\\r?\\n$/');\n        this.blanklineStartRegex_ = new RegExp('/^\\r?\\n\\r?\\n/');\n        /**\n         * Convert a diff array into a pretty HTML report.\n         * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n         * @return {string} HTML representation.\n         */\n        this.diff_prettyHtml = function (diffs) {\n            var html = [];\n            var pattern_amp = /&/g;\n            var pattern_lt = /</g;\n            var pattern_gt = />/g;\n            var pattern_para = /\\n/g;\n            for (var x = 0; x < diffs.length; x++) {\n                var op = diffs[x][0]; // Operation (insert, delete, equal)\n                var data = diffs[x][1]; // Text of change.\n                var text = data.replace(pattern_amp, '&amp;').replace(pattern_lt, '&lt;')\n                    .replace(pattern_gt, '&gt;').replace(pattern_para, '&para;<br>');\n                switch (op) {\n                    case 1 /* Insert */:\n                        html[x] = '<ins style=\"background:#e6ffe6;\">' + text + '</ins>';\n                        break;\n                    case -1 /* Delete */:\n                        html[x] = '<del style=\"background:#ffe6e6;\">' + text + '</del>';\n                        break;\n                    case 0 /* Equal */:\n                        html[x] = '<span>' + text + '</span>';\n                        break;\n                }\n            }\n            return html.join('');\n        };\n        /**\n         * Look through the patches and break up any which are longer than the maximum\n         * limit of the match algorithm.\n         * Intended to be called only from within patch_apply.\n         * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n         */\n        this.patch_splitMax = function (patches) {\n            var patch_size = this.Match_MaxBits;\n            for (var x = 0; x < patches.length; x++) {\n                if (patches[x].length1 <= patch_size) {\n                    continue;\n                }\n                var bigpatch = patches[x];\n                // Remove the big old patch.\n                patches.splice(x--, 1);\n                var start1 = bigpatch.start1;\n                var start2 = bigpatch.start2;\n                var precontext = '';\n                while (bigpatch.diffs.length !== 0) {\n                    // Create one of several smaller patches.\n                    var patch = new patch_obj();\n                    var empty = true;\n                    patch.start1 = start1 - precontext.length;\n                    patch.start2 = start2 - precontext.length;\n                    if (precontext !== '') {\n                        patch.length1 = patch.length2 = precontext.length;\n                        patch.diffs.push([0 /* Equal */, precontext]);\n                    }\n                    while (bigpatch.diffs.length !== 0 &&\n                        patch.length1 < patch_size - this.Patch_Margin) {\n                        var diff_type = bigpatch.diffs[0][0];\n                        var diff_text = bigpatch.diffs[0][1];\n                        if (diff_type === 1 /* Insert */) {\n                            // Insertions are harmless.\n                            patch.length2 += diff_text.length;\n                            start2 += diff_text.length;\n                            patch.diffs.push(bigpatch.diffs.shift());\n                            empty = false;\n                        }\n                        else if (diff_type === -1 /* Delete */ && patch.diffs.length == 1 &&\n                            patch.diffs[0][0] == 0 /* Equal */ &&\n                            diff_text.length > 2 * patch_size) {\n                            // This is a large deletion.  Let it pass in one chunk.\n                            patch.length1 += diff_text.length;\n                            start1 += diff_text.length;\n                            empty = false;\n                            patch.diffs.push([diff_type, diff_text]);\n                            bigpatch.diffs.shift();\n                        }\n                        else {\n                            // Deletion or equality.  Only take as much as we can stomach.\n                            diff_text = diff_text.substring(0, patch_size - patch.length1 - this.Patch_Margin);\n                            patch.length1 += diff_text.length;\n                            start1 += diff_text.length;\n                            if (diff_type === 0 /* Equal */) {\n                                patch.length2 += diff_text.length;\n                                start2 += diff_text.length;\n                            }\n                            else {\n                                empty = false;\n                            }\n                            patch.diffs.push([diff_type, diff_text]);\n                            if (diff_text == bigpatch.diffs[0][1]) {\n                                bigpatch.diffs.shift();\n                            }\n                            else {\n                                bigpatch.diffs[0][1] =\n                                    bigpatch.diffs[0][1].substring(diff_text.length);\n                            }\n                        }\n                    }\n                    // Compute the head context for the next patch.\n                    precontext = this.diff_text2(patch.diffs);\n                    precontext =\n                        precontext.substring(precontext.length - this.Patch_Margin);\n                    // Append the end context for this patch.\n                    var postcontext = this.diff_text1(bigpatch.diffs)\n                        .substring(0, this.Patch_Margin);\n                    if (postcontext !== '') {\n                        patch.length1 += postcontext.length;\n                        patch.length2 += postcontext.length;\n                        if (patch.diffs.length !== 0 &&\n                            patch.diffs[patch.diffs.length - 1][0] === 0 /* Equal */) {\n                            patch.diffs[patch.diffs.length - 1][1] += postcontext;\n                        }\n                        else {\n                            patch.diffs.push([0 /* Equal */, postcontext]);\n                        }\n                    }\n                    if (!empty) {\n                        patches.splice(++x, 0, patch);\n                    }\n                }\n            }\n        };\n    }\n    /**\n     * Find the differences between two texts.  Simplifies the problem by stripping\n     * any common prefix or suffix off the texts before diffing.\n     * @param {string} text1 Old string to be diffed.\n     * @param {string} text2 New string to be diffed.\n     * @param {boolean=} opt_checklines Optional speedup flag. If present and false,\n     *     then don't run a line-level diff first to identify the changed areas.\n     *     Defaults to true, which does a faster, slightly less optimal diff.\n     * @param {number} opt_deadline Optional time when the diff should be complete\n     *     by.  Used internally for recursive calls.  Users should set DiffTimeout\n     *     instead.\n     * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n     */\n    DiffMatchPatch.prototype.diff_main = function (text1, text2, opt_checklines, opt_deadline) {\n        // Set a deadline by which time the diff must be complete.\n        if (typeof opt_deadline == 'undefined') {\n            if (this.Diff_Timeout <= 0) {\n                opt_deadline = Number.MAX_VALUE;\n            }\n            else {\n                opt_deadline = (new Date).getTime() + this.Diff_Timeout * 1000;\n            }\n        }\n        var deadline = opt_deadline;\n        // Check for null inputs.\n        if (text1 == null || text2 == null) {\n            throw new Error('Null input. (diff_main)');\n        }\n        // Check for equality (speedup).\n        if (text1 == text2) {\n            if (text1) {\n                return [[0 /* Equal */, text1]];\n            }\n            return [];\n        }\n        if (typeof opt_checklines == 'undefined') {\n            opt_checklines = true;\n        }\n        var checklines = opt_checklines;\n        // Trim off common prefix (speedup).\n        var commonlength = this.diff_commonPrefix(text1, text2);\n        var commonprefix = text1.substring(0, commonlength);\n        text1 = text1.substring(commonlength);\n        text2 = text2.substring(commonlength);\n        // Trim off common suffix (speedup).\n        commonlength = this.diff_commonSuffix(text1, text2);\n        var commonsuffix = text1.substring(text1.length - commonlength);\n        text1 = text1.substring(0, text1.length - commonlength);\n        text2 = text2.substring(0, text2.length - commonlength);\n        // Compute the diff on the middle block.\n        var diffs = this.diff_compute_(text1, text2, checklines, deadline);\n        // Restore the prefix and suffix.\n        if (commonprefix) {\n            diffs.unshift([0 /* Equal */, commonprefix]);\n        }\n        if (commonsuffix) {\n            diffs.push([0 /* Equal */, commonsuffix]);\n        }\n        this.diff_cleanupMerge(diffs);\n        return diffs;\n    };\n    ;\n    /**\n     * Find the differences between two texts.  Assumes that the texts do not\n     * have any common prefix or suffix.\n     * @param {string} text1 Old string to be diffed.\n     * @param {string} text2 New string to be diffed.\n     * @param {boolean} checklines Speedup flag.  If false, then don't run a\n     *     line-level diff first to identify the changed areas.\n     *     If true, then run a faster, slightly less optimal diff.\n     * @param {number} deadline Time when the diff should be complete by.\n     * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n     * @private\n     */\n    DiffMatchPatch.prototype.diff_compute_ = function (text1, text2, checklines, deadline) {\n        var diffs;\n        if (!text1) {\n            // Just add some text (speedup).\n            return [[1 /* Insert */, text2]];\n        }\n        if (!text2) {\n            // Just delete some text (speedup).\n            return [[-1 /* Delete */, text1]];\n        }\n        var longtext = text1.length > text2.length ? text1 : text2;\n        var shorttext = text1.length > text2.length ? text2 : text1;\n        var i = longtext.indexOf(shorttext);\n        if (i != -1) {\n            // Shorter text is inside the longer text (speedup).\n            diffs = [[1 /* Insert */, longtext.substring(0, i)],\n                [0 /* Equal */, shorttext],\n                [1 /* Insert */, longtext.substring(i + shorttext.length)]];\n            // Swap insertions for deletions if diff is reversed.\n            if (text1.length > text2.length) {\n                diffs[0][0] = diffs[2][0] = -1 /* Delete */;\n            }\n            return diffs;\n        }\n        if (shorttext.length == 1) {\n            // Single character string.\n            // After the previous speedup, the character can't be an equality.\n            return [[-1 /* Delete */, text1], [1 /* Insert */, text2]];\n        }\n        // Check to see if the problem can be split in two.\n        var hm = this.diff_halfMatch_(text1, text2);\n        if (hm) {\n            // A half-match was found, sort out the return data.\n            var text1_a = hm[0];\n            var text1_b = hm[1];\n            var text2_a = hm[2];\n            var text2_b = hm[3];\n            var mid_common = hm[4];\n            // Send both pairs off for separate processing.\n            var diffs_a = this.diff_main(text1_a, text2_a, checklines, deadline);\n            var diffs_b = this.diff_main(text1_b, text2_b, checklines, deadline);\n            // Merge the results.\n            return diffs_a.concat([[0 /* Equal */, mid_common]], diffs_b);\n        }\n        if (checklines && text1.length > 100 && text2.length > 100) {\n            return this.diff_lineMode_(text1, text2, deadline);\n        }\n        return this.diff_bisect_(text1, text2, deadline);\n    };\n    ;\n    /**\n     * Do a quick line-level diff on both strings, then rediff the parts for\n     * greater accuracy.\n     * This speedup can produce non-minimal diffs.\n     * @param {string} text1 Old string to be diffed.\n     * @param {string} text2 New string to be diffed.\n     * @param {number} deadline Time when the diff should be complete by.\n     * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n     * @private\n     */\n    DiffMatchPatch.prototype.diff_lineMode_ = function (text1, text2, deadline) {\n        // Scan the text on a line-by-line basis first.\n        var a = this.diff_linesToChars_(text1, text2);\n        text1 = a.chars1;\n        text2 = a.chars2;\n        var linearray = a.lineArray;\n        var diffs = this.diff_main(text1, text2, false, deadline);\n        // Convert the diff back to original text.\n        this.diff_charsToLines_(diffs, linearray);\n        // Eliminate freak matches (e.g. blank lines)\n        this.diff_cleanupSemantic(diffs);\n        // Rediff any replacement blocks, this time character-by-character.\n        // Add a dummy entry at the end.\n        diffs.push([0 /* Equal */, '']);\n        var pointer = 0;\n        var count_delete = 0;\n        var count_insert = 0;\n        var text_delete = '';\n        var text_insert = '';\n        while (pointer < diffs.length) {\n            switch (diffs[pointer][0]) {\n                case 1 /* Insert */:\n                    count_insert++;\n                    text_insert += diffs[pointer][1];\n                    break;\n                case -1 /* Delete */:\n                    count_delete++;\n                    text_delete += diffs[pointer][1];\n                    break;\n                case 0 /* Equal */:\n                    // Upon reaching an equality, check for prior redundancies.\n                    if (count_delete >= 1 && count_insert >= 1) {\n                        // Delete the offending records and add the merged ones.\n                        diffs.splice(pointer - count_delete - count_insert, count_delete + count_insert);\n                        pointer = pointer - count_delete - count_insert;\n                        var b = this.diff_main(text_delete, text_insert, false, deadline);\n                        for (var j = b.length - 1; j >= 0; j--) {\n                            diffs.splice(pointer, 0, b[j]);\n                        }\n                        pointer = pointer + b.length;\n                    }\n                    count_insert = 0;\n                    count_delete = 0;\n                    text_delete = '';\n                    text_insert = '';\n                    break;\n            }\n            pointer++;\n        }\n        diffs.pop(); // Remove the dummy entry at the end.\n        return diffs;\n    };\n    ;\n    /**\n     * Find the 'middle snake' of a diff, split the problem in two\n     * and return the recursively constructed diff.\n     * See Myers 1986 paper: An O(ND) Difference Algorithm and Its constiations.\n     * @param {string} text1 Old string to be diffed.\n     * @param {string} text2 New string to be diffed.\n     * @param {number} deadline Time at which to bail if not yet complete.\n     * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n     * @private\n     */\n    DiffMatchPatch.prototype.diff_bisect_ = function (text1, text2, deadline) {\n        // Cache the text lengths to prevent multiple calls.\n        var text1_length = text1.length;\n        var text2_length = text2.length;\n        var max_d = Math.ceil((text1_length + text2_length) / 2);\n        var v_offset = max_d;\n        var v_length = 2 * max_d;\n        var v1 = new Array(v_length);\n        var v2 = new Array(v_length);\n        // Setting all elements to -1 is faster in Chrome & Firefox than mixing\n        // integers and undefined.\n        for (var x = 0; x < v_length; x++) {\n            v1[x] = -1;\n            v2[x] = -1;\n        }\n        v1[v_offset + 1] = 0;\n        v2[v_offset + 1] = 0;\n        var delta = text1_length - text2_length;\n        // If the total number of characters is odd, then the front path will collide\n        // with the reverse path.\n        var front = (delta % 2 != 0);\n        // Offsets for start and end of k loop.\n        // Prevents mapping of space beyond the grid.\n        var k1start = 0;\n        var k1end = 0;\n        var k2start = 0;\n        var k2end = 0;\n        for (var d = 0; d < max_d; d++) {\n            // Bail out if deadline is reached.\n            if ((new Date()).getTime() > deadline) {\n                break;\n            }\n            // Walk the front path one step.\n            for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {\n                var k1_offset = v_offset + k1;\n                var x1 = void 0;\n                if (k1 == -d || (k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])) {\n                    x1 = v1[k1_offset + 1];\n                }\n                else {\n                    x1 = v1[k1_offset - 1] + 1;\n                }\n                var y1 = x1 - k1;\n                while (x1 < text1_length && y1 < text2_length &&\n                    text1.charAt(x1) == text2.charAt(y1)) {\n                    x1++;\n                    y1++;\n                }\n                v1[k1_offset] = x1;\n                if (x1 > text1_length) {\n                    // Ran off the right of the graph.\n                    k1end += 2;\n                }\n                else if (y1 > text2_length) {\n                    // Ran off the bottom of the graph.\n                    k1start += 2;\n                }\n                else if (front) {\n                    var k2_offset = v_offset + delta - k1;\n                    if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {\n                        // Mirror x2 onto top-left coordinate system.\n                        var x2 = text1_length - v2[k2_offset];\n                        if (x1 >= x2) {\n                            // Overlap detected.\n                            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);\n                        }\n                    }\n                }\n            }\n            // Walk the reverse path one step.\n            for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {\n                var k2_offset = v_offset + k2;\n                var x2 = void 0;\n                if (k2 == -d || (k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])) {\n                    x2 = v2[k2_offset + 1];\n                }\n                else {\n                    x2 = v2[k2_offset - 1] + 1;\n                }\n                var y2 = x2 - k2;\n                while (x2 < text1_length && y2 < text2_length &&\n                    text1.charAt(text1_length - x2 - 1) ==\n                        text2.charAt(text2_length - y2 - 1)) {\n                    x2++;\n                    y2++;\n                }\n                v2[k2_offset] = x2;\n                if (x2 > text1_length) {\n                    // Ran off the left of the graph.\n                    k2end += 2;\n                }\n                else if (y2 > text2_length) {\n                    // Ran off the top of the graph.\n                    k2start += 2;\n                }\n                else if (!front) {\n                    var k1_offset = v_offset + delta - k2;\n                    if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {\n                        var x1 = v1[k1_offset];\n                        var y1 = v_offset + x1 - k1_offset;\n                        // Mirror x2 onto top-left coordinate system.\n                        x2 = text1_length - x2;\n                        if (x1 >= x2) {\n                            // Overlap detected.\n                            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);\n                        }\n                    }\n                }\n            }\n        }\n        // Diff took too long and hit the deadline or\n        // number of diffs equals number of characters, no commonality at all.\n        return [[-1 /* Delete */, text1], [1 /* Insert */, text2]];\n    };\n    ;\n    /**\n     * Given the location of the 'middle snake', split the diff in two parts\n     * and recurse.\n     * @param {string} text1 Old string to be diffed.\n     * @param {string} text2 New string to be diffed.\n     * @param {number} x Index of split point in text1.\n     * @param {number} y Index of split point in text2.\n     * @param {number} deadline Time at which to bail if not yet complete.\n     * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n     * @private\n     */\n    DiffMatchPatch.prototype.diff_bisectSplit_ = function (text1, text2, x, y, deadline) {\n        var text1a = text1.substring(0, x);\n        var text2a = text2.substring(0, y);\n        var text1b = text1.substring(x);\n        var text2b = text2.substring(y);\n        // Compute both diffs serially.\n        var diffs = this.diff_main(text1a, text2a, false, deadline);\n        var diffsb = this.diff_main(text1b, text2b, false, deadline);\n        return diffs.concat(diffsb);\n    };\n    ;\n    /**\n     * Split two texts into an array of strings.  Reduce the texts to a string of\n     * hashes where each Unicode character represents one line.\n     * @param {string} text1 First string.\n     * @param {string} text2 Second string.\n     * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}\n     *     An object containing the encoded text1, the encoded text2 and\n     *     the array of unique strings.\n     *     The zeroth element of the array of unique strings is intentionally blank.\n     * @private\n     */\n    DiffMatchPatch.prototype.diff_linesToChars_ = function (text1, text2) {\n        var lineArray = []; // e.g. lineArray[4] == 'Hello\\n'\n        var lineHash = {}; // e.g. lineHash['Hello\\n'] == 4\n        // '\\x00' is a valid character, but constious debuggers don't like it.\n        // So we'll insert a junk entry to avoid generating a null character.\n        lineArray[0] = '';\n        var chars1 = this.diff_linesToCharsMunge_(text1, lineArray, lineHash);\n        var chars2 = this.diff_linesToCharsMunge_(text2, lineArray, lineHash);\n        return { chars1: chars1, chars2: chars2, lineArray: lineArray };\n    };\n    ;\n    /**\n     * Split a text into an array of strings.  Reduce the texts to a string of\n     * hashes where each Unicode character represents one line.\n     * Modifies linearray and linehash through being a closure.\n     * @param {string} text String to encode.\n     * @return {string} Encoded string.\n     * @private\n     */\n    DiffMatchPatch.prototype.diff_linesToCharsMunge_ = function (text, lineArray, lineHash) {\n        var chars = '';\n        // Walk the text, pulling out a substring for each line.\n        // text.split('\\n') would would temporarily double our memory footprint.\n        // Modifying text would create many large strings to garbage collect.\n        var lineStart = 0;\n        var lineEnd = -1;\n        // Keeping our own length constiable is faster than looking it up.\n        var lineArrayLength = lineArray.length;\n        while (lineEnd < text.length - 1) {\n            lineEnd = text.indexOf('\\n', lineStart);\n            if (lineEnd == -1) {\n                lineEnd = text.length - 1;\n            }\n            var line = text.substring(lineStart, lineEnd + 1);\n            lineStart = lineEnd + 1;\n            if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) :\n                (lineHash[line] !== undefined)) {\n                chars += String.fromCharCode(lineHash[line]);\n            }\n            else {\n                chars += String.fromCharCode(lineArrayLength);\n                lineHash[line] = lineArrayLength;\n                lineArray[lineArrayLength++] = line;\n            }\n        }\n        return chars;\n    };\n    /**\n     * Rehydrate the text in a diff from a string of line hashes to real lines of\n     * text.\n     * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n     * @param {!Array.<string>} lineArray Array of unique strings.\n     * @private\n     */\n    DiffMatchPatch.prototype.diff_charsToLines_ = function (diffs, lineArray) {\n        for (var x = 0; x < diffs.length; x++) {\n            var chars = diffs[x][1];\n            var text = [];\n            for (var y = 0; y < chars.length; y++) {\n                text[y] = lineArray[chars.charCodeAt(y)];\n            }\n            diffs[x][1] = text.join('');\n        }\n    };\n    ;\n    /**\n     * Determine the common prefix of two strings.\n     * @param {string} text1 First string.\n     * @param {string} text2 Second string.\n     * @return {number} The number of characters common to the start of each\n     *     string.\n     */\n    DiffMatchPatch.prototype.diff_commonPrefix = function (text1, text2) {\n        // Quick check for common null cases.\n        if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {\n            return 0;\n        }\n        // Binary search.\n        // Performance analysis: http://neil.fraser.name/news/2007/10/09/\n        var pointermin = 0;\n        var pointermax = Math.min(text1.length, text2.length);\n        var pointermid = pointermax;\n        var pointerstart = 0;\n        while (pointermin < pointermid) {\n            if (text1.substring(pointerstart, pointermid) ==\n                text2.substring(pointerstart, pointermid)) {\n                pointermin = pointermid;\n                pointerstart = pointermin;\n            }\n            else {\n                pointermax = pointermid;\n            }\n            pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n        }\n        return pointermid;\n    };\n    ;\n    /**\n     * Determine the common suffix of two strings.\n     * @param {string} text1 First string.\n     * @param {string} text2 Second string.\n     * @return {number} The number of characters common to the end of each string.\n     */\n    DiffMatchPatch.prototype.diff_commonSuffix = function (text1, text2) {\n        // Quick check for common null cases.\n        if (!text1 || !text2 ||\n            text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {\n            return 0;\n        }\n        // Binary search.\n        // Performance analysis: http://neil.fraser.name/news/2007/10/09/\n        var pointermin = 0;\n        var pointermax = Math.min(text1.length, text2.length);\n        var pointermid = pointermax;\n        var pointerend = 0;\n        while (pointermin < pointermid) {\n            if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==\n                text2.substring(text2.length - pointermid, text2.length - pointerend)) {\n                pointermin = pointermid;\n                pointerend = pointermin;\n            }\n            else {\n                pointermax = pointermid;\n            }\n            pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n        }\n        return pointermid;\n    };\n    ;\n    /**\n     * Determine if the suffix of one string is the prefix of another.\n     * @param {string} text1 First string.\n     * @param {string} text2 Second string.\n     * @return {number} The number of characters common to the end of the first\n     *     string and the start of the second string.\n     * @private\n     */\n    DiffMatchPatch.prototype.diff_commonOverlap_ = function (text1, text2) {\n        // Cache the text lengths to prevent multiple calls.\n        var text1_length = text1.length;\n        var text2_length = text2.length;\n        // Eliminate the null case.\n        if (text1_length == 0 || text2_length == 0) {\n            return 0;\n        }\n        // Truncate the longer string.\n        if (text1_length > text2_length) {\n            text1 = text1.substring(text1_length - text2_length);\n        }\n        else if (text1_length < text2_length) {\n            text2 = text2.substring(0, text1_length);\n        }\n        var text_length = Math.min(text1_length, text2_length);\n        // Quick check for the worst case.\n        if (text1 == text2) {\n            return text_length;\n        }\n        // Start by looking for a single character match\n        // and increase length until no match is found.\n        // Performance analysis: http://neil.fraser.name/news/2010/11/04/\n        var best = 0;\n        var length = 1;\n        while (true) {\n            var pattern = text1.substring(text_length - length);\n            var found = text2.indexOf(pattern);\n            if (found == -1) {\n                return best;\n            }\n            length += found;\n            if (found == 0 || text1.substring(text_length - length) ==\n                text2.substring(0, length)) {\n                best = length;\n                length++;\n            }\n        }\n    };\n    ;\n    /**\n     * Do the two texts share a substring which is at least half the length of the\n     * longer text?\n     * This speedup can produce non-minimal diffs.\n     * @param {string} text1 First string.\n     * @param {string} text2 Second string.\n     * @return {Array.<string>} Five element Array, containing the prefix of\n     *     text1, the suffix of text1, the prefix of text2, the suffix of\n     *     text2 and the common middle.  Or null if there was no match.\n     * @private\n     */\n    DiffMatchPatch.prototype.diff_halfMatch_ = function (text1, text2) {\n        if (this.Diff_Timeout <= 0) {\n            // Don't risk returning a non-optimal diff if we have unlimited time.\n            return null;\n        }\n        var longtext = text1.length > text2.length ? text1 : text2;\n        var shorttext = text1.length > text2.length ? text2 : text1;\n        if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {\n            return null; // Pointless.\n        }\n        var dmp = this; // 'this' becomes 'window' in a closure.\n        // First check if the second quarter is the seed for a half-match.\n        var hm1 = this.diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 4), dmp);\n        // Check again based on the third quarter.\n        var hm2 = this.diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 2), dmp);\n        var hm;\n        if (!hm1 && !hm2) {\n            return null;\n        }\n        else if (!hm2) {\n            hm = hm1;\n        }\n        else if (!hm1) {\n            hm = hm2;\n        }\n        else {\n            // Both matched.  Select the longest.\n            hm = hm1[4].length > hm2[4].length ? hm1 : hm2;\n        }\n        // A half-match was found, sort out the return data.\n        var text1_a, text1_b, text2_a, text2_b;\n        if (text1.length > text2.length) {\n            text1_a = hm[0];\n            text1_b = hm[1];\n            text2_a = hm[2];\n            text2_b = hm[3];\n        }\n        else {\n            text2_a = hm[0];\n            text2_b = hm[1];\n            text1_a = hm[2];\n            text1_b = hm[3];\n        }\n        var mid_common = hm[4];\n        return [text1_a, text1_b, text2_a, text2_b, mid_common];\n    };\n    ;\n    /**\n     * Does a substring of shorttext exist within longtext such that the substring\n     * is at least half the length of longtext?\n     * Closure, but does not reference any external constiables.\n     * @param {string} longtext Longer string.\n     * @param {string} shorttext Shorter string.\n     * @param {number} i Start index of quarter length substring within longtext.\n     * @return {Array.<string>} Five element Array, containing the prefix of\n     *     longtext, the suffix of longtext, the prefix of shorttext, the suffix\n     *     of shorttext and the common middle.  Or null if there was no match.\n     * @private\n     */\n    DiffMatchPatch.prototype.diff_halfMatchI_ = function (longtext, shorttext, i, dmp) {\n        // Start with a 1/4 length substring at position i as a seed.\n        var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));\n        var j = -1;\n        var best_common = '';\n        var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;\n        while ((j = shorttext.indexOf(seed, j + 1)) != -1) {\n            var prefixLength = dmp.diff_commonPrefix(longtext.substring(i), shorttext.substring(j));\n            var suffixLength = dmp.diff_commonSuffix(longtext.substring(0, i), shorttext.substring(0, j));\n            if (best_common.length < suffixLength + prefixLength) {\n                best_common = shorttext.substring(j - suffixLength, j) +\n                    shorttext.substring(j, j + prefixLength);\n                best_longtext_a = longtext.substring(0, i - suffixLength);\n                best_longtext_b = longtext.substring(i + prefixLength);\n                best_shorttext_a = shorttext.substring(0, j - suffixLength);\n                best_shorttext_b = shorttext.substring(j + prefixLength);\n            }\n        }\n        if (best_common.length * 2 >= longtext.length) {\n            return [best_longtext_a, best_longtext_b,\n                best_shorttext_a, best_shorttext_b, best_common];\n        }\n        else {\n            return null;\n        }\n    };\n    /**\n     * Reduce the number of edits by eliminating semantically trivial equalities.\n     * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n     */\n    DiffMatchPatch.prototype.diff_cleanupSemantic = function (diffs) {\n        var changes = false;\n        var equalities = []; // Stack of indices where equalities are found.\n        var equalitiesLength = 0; // Keeping our own length const is faster in JS.\n        /** @type {?string} */\n        var lastequality = null;\n        // Always equal to diffs[equalities[equalitiesLength - 1]][1]\n        var pointer = 0; // Index of current position.\n        // Number of characters that changed prior to the equality.\n        var length_insertions1 = 0;\n        var length_deletions1 = 0;\n        // Number of characters that changed after the equality.\n        var length_insertions2 = 0;\n        var length_deletions2 = 0;\n        while (pointer < diffs.length) {\n            if (diffs[pointer][0] == 0 /* Equal */) {\n                equalities[equalitiesLength++] = pointer;\n                length_insertions1 = length_insertions2;\n                length_deletions1 = length_deletions2;\n                length_insertions2 = 0;\n                length_deletions2 = 0;\n                lastequality = diffs[pointer][1];\n            }\n            else {\n                if (diffs[pointer][0] == 1 /* Insert */) {\n                    length_insertions2 += diffs[pointer][1].length;\n                }\n                else {\n                    length_deletions2 += diffs[pointer][1].length;\n                }\n                // Eliminate an equality that is smaller or equal to the edits on both\n                // sides of it.\n                if (lastequality && (lastequality.length <=\n                    Math.max(length_insertions1, length_deletions1)) &&\n                    (lastequality.length <= Math.max(length_insertions2, length_deletions2))) {\n                    // Duplicate record.\n                    diffs.splice(equalities[equalitiesLength - 1], 0, [-1 /* Delete */, lastequality]);\n                    // Change second copy to insert.\n                    diffs[equalities[equalitiesLength - 1] + 1][0] = 1 /* Insert */;\n                    // Throw away the equality we just deleted.\n                    equalitiesLength--;\n                    // Throw away the previous equality (it needs to be reevaluated).\n                    equalitiesLength--;\n                    pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;\n                    length_insertions1 = 0; // Reset the counters.\n                    length_deletions1 = 0;\n                    length_insertions2 = 0;\n                    length_deletions2 = 0;\n                    lastequality = null;\n                    changes = true;\n                }\n            }\n            pointer++;\n        }\n        // Normalize the diff.\n        if (changes) {\n            this.diff_cleanupMerge(diffs);\n        }\n        this.diff_cleanupSemanticLossless(diffs);\n        // Find any overlaps between deletions and insertions.\n        // e.g: <del>abcxxx</del><ins>xxxdef</ins>\n        //   -> <del>abc</del>xxx<ins>def</ins>\n        // e.g: <del>xxxabc</del><ins>defxxx</ins>\n        //   -> <ins>def</ins>xxx<del>abc</del>\n        // Only extract an overlap if it is as big as the edit ahead or behind it.\n        pointer = 1;\n        while (pointer < diffs.length) {\n            if (diffs[pointer - 1][0] == -1 /* Delete */ &&\n                diffs[pointer][0] == 1 /* Insert */) {\n                var deletion = diffs[pointer - 1][1];\n                var insertion = diffs[pointer][1];\n                var overlap_length1 = this.diff_commonOverlap_(deletion, insertion);\n                var overlap_length2 = this.diff_commonOverlap_(insertion, deletion);\n                if (overlap_length1 >= overlap_length2) {\n                    if (overlap_length1 >= deletion.length / 2 ||\n                        overlap_length1 >= insertion.length / 2) {\n                        // Overlap found.  Insert an equality and trim the surrounding edits.\n                        diffs.splice(pointer, 0, [0 /* Equal */, insertion.substring(0, overlap_length1)]);\n                        diffs[pointer - 1][1] =\n                            deletion.substring(0, deletion.length - overlap_length1);\n                        diffs[pointer + 1][1] = insertion.substring(overlap_length1);\n                        pointer++;\n                    }\n                }\n                else {\n                    if (overlap_length2 >= deletion.length / 2 ||\n                        overlap_length2 >= insertion.length / 2) {\n                        // Reverse overlap found.\n                        // Insert an equality and swap and trim the surrounding edits.\n                        diffs.splice(pointer, 0, [0 /* Equal */, deletion.substring(0, overlap_length2)]);\n                        diffs[pointer - 1][0] = 1 /* Insert */;\n                        diffs[pointer - 1][1] =\n                            insertion.substring(0, insertion.length - overlap_length2);\n                        diffs[pointer + 1][0] = -1 /* Delete */;\n                        diffs[pointer + 1][1] =\n                            deletion.substring(overlap_length2);\n                        pointer++;\n                    }\n                }\n                pointer++;\n            }\n            pointer++;\n        }\n    };\n    ;\n    /**\n     * Look for single edits surrounded on both sides by equalities\n     * which can be shifted sideways to align the edit to a word boundary.\n     * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.\n     * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n     */\n    DiffMatchPatch.prototype.diff_cleanupSemanticLossless = function (diffs) {\n        /**\n         * Given two strings, compute a score representing whether the internal\n         * boundary falls on logical boundaries.\n         * Scores range from 6 (best) to 0 (worst).\n         * Closure, but does not reference any external constiables.\n         * @param {string} one First string.\n         * @param {string} two Second string.\n         * @return {number} The score.\n         * @private\n         */\n        function diff_cleanupSemanticScore_(one, two) {\n            if (!one || !two) {\n                // Edges are the best.\n                return 6;\n            }\n            var nonAlphaNumericRegex_ = new RegExp('/[^a-zA-Z0-9]/');\n            // Each port of this function behaves slightly differently due to\n            // subtle differences in each language's definition of things like\n            // 'whitespace'.  Since this function's purpose is largely cosmetic,\n            // the choice has been made to use each language's native features\n            // rather than force total conformity.\n            var char1 = one.charAt(one.length - 1);\n            var char2 = two.charAt(0);\n            var nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex_);\n            var nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex_);\n            var whitespace1 = nonAlphaNumeric1 &&\n                char1.match(this.whitespaceRegex_);\n            var whitespace2 = nonAlphaNumeric2 &&\n                char2.match(this.whitespaceRegex_);\n            var lineBreak1 = whitespace1 &&\n                char1.match(this.linebreakRegex_);\n            var lineBreak2 = whitespace2 &&\n                char2.match(this.linebreakRegex_);\n            var blankLine1 = lineBreak1 &&\n                one.match(this.blanklineEndRegex_);\n            var blankLine2 = lineBreak2 &&\n                two.match(this.blanklineStartRegex_);\n            if (blankLine1 || blankLine2) {\n                // Five points for blank lines.\n                return 5;\n            }\n            else if (lineBreak1 || lineBreak2) {\n                // Four points for line breaks.\n                return 4;\n            }\n            else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {\n                // Three points for end of sentences.\n                return 3;\n            }\n            else if (whitespace1 || whitespace2) {\n                // Two points for whitespace.\n                return 2;\n            }\n            else if (nonAlphaNumeric1 || nonAlphaNumeric2) {\n                // One point for non-alphanumeric.\n                return 1;\n            }\n            return 0;\n        }\n        var pointer = 1;\n        // Intentionally ignore the first and last element (don't need checking).\n        while (pointer < diffs.length - 1) {\n            if (diffs[pointer - 1][0] == 0 /* Equal */ &&\n                diffs[pointer + 1][0] == 0 /* Equal */) {\n                // This is a single edit surrounded by equalities.\n                var equality1 = diffs[pointer - 1][1];\n                var edit = diffs[pointer][1];\n                var equality2 = diffs[pointer + 1][1];\n                // First, shift the edit as far left as possible.\n                var commonOffset = this.diff_commonSuffix(equality1, edit);\n                if (commonOffset) {\n                    var commonString = edit.substring(edit.length - commonOffset);\n                    equality1 = equality1.substring(0, equality1.length - commonOffset);\n                    edit = commonString + edit.substring(0, edit.length - commonOffset);\n                    equality2 = commonString + equality2;\n                }\n                // Second, step character by character right, looking for the best fit.\n                var bestEquality1 = equality1;\n                var bestEdit = edit;\n                var bestEquality2 = equality2;\n                var bestScore = diff_cleanupSemanticScore_(equality1, edit) +\n                    diff_cleanupSemanticScore_(edit, equality2);\n                while (edit.charAt(0) === equality2.charAt(0)) {\n                    equality1 += edit.charAt(0);\n                    edit = edit.substring(1) + equality2.charAt(0);\n                    equality2 = equality2.substring(1);\n                    var score = diff_cleanupSemanticScore_(equality1, edit) +\n                        diff_cleanupSemanticScore_(edit, equality2);\n                    // The >= encourages trailing rather than leading whitespace on edits.\n                    if (score >= bestScore) {\n                        bestScore = score;\n                        bestEquality1 = equality1;\n                        bestEdit = edit;\n                        bestEquality2 = equality2;\n                    }\n                }\n                if (diffs[pointer - 1][1] != bestEquality1) {\n                    // We have an improvement, save it back to the diff.\n                    if (bestEquality1) {\n                        diffs[pointer - 1][1] = bestEquality1;\n                    }\n                    else {\n                        diffs.splice(pointer - 1, 1);\n                        pointer--;\n                    }\n                    diffs[pointer][1] = bestEdit;\n                    if (bestEquality2) {\n                        diffs[pointer + 1][1] = bestEquality2;\n                    }\n                    else {\n                        diffs.splice(pointer + 1, 1);\n                        pointer--;\n                    }\n                }\n            }\n            pointer++;\n        }\n    };\n    ;\n    /**\n     * Reduce the number of edits by eliminating operationally trivial equalities.\n     * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n     */\n    DiffMatchPatch.prototype.diff_cleanupEfficiency = function (diffs) {\n        var changes = false;\n        var equalities = []; // Stack of indices where equalities are found.\n        var equalitiesLength = 0; // Keeping our own length const is faster in JS.\n        /** @type {?string} */\n        var lastequality = null;\n        // Always equal to diffs[equalities[equalitiesLength - 1]][1]\n        var pointer = 0; // Index of current position.\n        // Is there an insertion operation before the last equality.\n        var pre_ins = false;\n        // Is there a deletion operation before the last equality.\n        var pre_del = false;\n        // Is there an insertion operation after the last equality.\n        var post_ins = false;\n        // Is there a deletion operation after the last equality.\n        var post_del = false;\n        while (pointer < diffs.length) {\n            if (diffs[pointer][0] == 0 /* Equal */) {\n                if (diffs[pointer][1].length < this.Diff_EditCost &&\n                    (post_ins || post_del)) {\n                    // Candidate found.\n                    equalities[equalitiesLength++] = pointer;\n                    pre_ins = post_ins;\n                    pre_del = post_del;\n                    lastequality = diffs[pointer][1];\n                }\n                else {\n                    // Not a candidate, and can never become one.\n                    equalitiesLength = 0;\n                    lastequality = null;\n                }\n                post_ins = post_del = false;\n            }\n            else {\n                if (diffs[pointer][0] == -1 /* Delete */) {\n                    post_del = true;\n                }\n                else {\n                    post_ins = true;\n                }\n                /*\n                * Five types to be split:\n                * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\n                * <ins>A</ins>X<ins>C</ins><del>D</del>\n                * <ins>A</ins><del>B</del>X<ins>C</ins>\n                * <ins>A</del>X<ins>C</ins><del>D</del>\n                * <ins>A</ins><del>B</del>X<del>C</del>\n                */\n                if (lastequality && ((pre_ins && pre_del && post_ins && post_del) ||\n                    ((lastequality.length < this.Diff_EditCost / 2) &&\n                        ((pre_ins ? 1 : 0) + (pre_del ? 1 : 0) + (post_ins ? 1 : 0) + (post_del ? 1 : 0) == 3)))) {\n                    // Duplicate record.\n                    diffs.splice(equalities[equalitiesLength - 1], 0, [-1 /* Delete */, lastequality]);\n                    // Change second copy to insert.\n                    diffs[equalities[equalitiesLength - 1] + 1][0] = 1 /* Insert */;\n                    equalitiesLength--; // Throw away the equality we just deleted;\n                    lastequality = null;\n                    if (pre_ins && pre_del) {\n                        // No changes made which could affect previous entry, keep going.\n                        post_ins = post_del = true;\n                        equalitiesLength = 0;\n                    }\n                    else {\n                        equalitiesLength--; // Throw away the previous equality.\n                        pointer = equalitiesLength > 0 ?\n                            equalities[equalitiesLength - 1] : -1;\n                        post_ins = post_del = false;\n                    }\n                    changes = true;\n                }\n            }\n            pointer++;\n        }\n        if (changes) {\n            this.diff_cleanupMerge(diffs);\n        }\n    };\n    ;\n    /**\n     * Reorder and merge like edit sections.  Merge equalities.\n     * Any edit section can move as long as it doesn't cross an equality.\n     * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n     */\n    DiffMatchPatch.prototype.diff_cleanupMerge = function (diffs) {\n        diffs.push([0 /* Equal */, '']); // Add a dummy entry at the end.\n        var pointer = 0;\n        var count_delete = 0;\n        var count_insert = 0;\n        var text_delete = '';\n        var text_insert = '';\n        var commonlength;\n        while (pointer < diffs.length) {\n            switch (diffs[pointer][0]) {\n                case 1 /* Insert */:\n                    count_insert++;\n                    text_insert += diffs[pointer][1];\n                    pointer++;\n                    break;\n                case -1 /* Delete */:\n                    count_delete++;\n                    text_delete += diffs[pointer][1];\n                    pointer++;\n                    break;\n                case 0 /* Equal */:\n                    // Upon reaching an equality, check for prior redundancies.\n                    if (count_delete + count_insert > 1) {\n                        if (count_delete !== 0 && count_insert !== 0) {\n                            // Factor out any common prefixies.\n                            commonlength = this.diff_commonPrefix(text_insert, text_delete);\n                            if (commonlength !== 0) {\n                                if ((pointer - count_delete - count_insert) > 0 &&\n                                    diffs[pointer - count_delete - count_insert - 1][0] ==\n                                        0 /* Equal */) {\n                                    diffs[pointer - count_delete - count_insert - 1][1] +=\n                                        text_insert.substring(0, commonlength);\n                                }\n                                else {\n                                    diffs.splice(0, 0, [0 /* Equal */,\n                                        text_insert.substring(0, commonlength)]);\n                                    pointer++;\n                                }\n                                text_insert = text_insert.substring(commonlength);\n                                text_delete = text_delete.substring(commonlength);\n                            }\n                            // Factor out any common suffixies.\n                            commonlength = this.diff_commonSuffix(text_insert, text_delete);\n                            if (commonlength !== 0) {\n                                diffs[pointer][1] = text_insert.substring(text_insert.length -\n                                    commonlength) + diffs[pointer][1];\n                                text_insert = text_insert.substring(0, text_insert.length -\n                                    commonlength);\n                                text_delete = text_delete.substring(0, text_delete.length -\n                                    commonlength);\n                            }\n                        }\n                        // Delete the offending records and add the merged ones.\n                        if (count_delete === 0) {\n                            diffs.splice(pointer - count_insert, count_delete + count_insert, [1 /* Insert */, text_insert]);\n                        }\n                        else if (count_insert === 0) {\n                            diffs.splice(pointer - count_delete, count_delete + count_insert, [-1 /* Delete */, text_delete]);\n                        }\n                        else {\n                            diffs.splice(pointer - count_delete - count_insert, count_delete + count_insert, [-1 /* Delete */, text_delete], [1 /* Insert */, text_insert]);\n                        }\n                        pointer = pointer - count_delete - count_insert +\n                            (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;\n                    }\n                    else if (pointer !== 0 && diffs[pointer - 1][0] == 0 /* Equal */) {\n                        // Merge this equality with the previous one.\n                        diffs[pointer - 1][1] += diffs[pointer][1];\n                        diffs.splice(pointer, 1);\n                    }\n                    else {\n                        pointer++;\n                    }\n                    count_insert = 0;\n                    count_delete = 0;\n                    text_delete = '';\n                    text_insert = '';\n                    break;\n            }\n        }\n        if (diffs[diffs.length - 1][1] === '') {\n            diffs.pop(); // Remove the dummy entry at the end.\n        }\n        // Second pass: look for single edits surrounded on both sides by equalities\n        // which can be shifted sideways to eliminate an equality.\n        // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\n        var changes = false;\n        pointer = 1;\n        // Intentionally ignore the first and last element (don't need checking).\n        while (pointer < diffs.length - 1) {\n            if (diffs[pointer - 1][0] == 0 /* Equal */ &&\n                diffs[pointer + 1][0] == 0 /* Equal */) {\n                // This is a single edit surrounded by equalities.\n                if (diffs[pointer][1].substring(diffs[pointer][1].length -\n                    diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {\n                    // Shift the edit over the previous equality.\n                    diffs[pointer][1] = diffs[pointer - 1][1] +\n                        diffs[pointer][1].substring(0, diffs[pointer][1].length -\n                            diffs[pointer - 1][1].length);\n                    diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];\n                    diffs.splice(pointer - 1, 1);\n                    changes = true;\n                }\n                else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==\n                    diffs[pointer + 1][1]) {\n                    // Shift the edit over the next equality.\n                    diffs[pointer - 1][1] += diffs[pointer + 1][1];\n                    diffs[pointer][1] =\n                        diffs[pointer][1].substring(diffs[pointer + 1][1].length) +\n                            diffs[pointer + 1][1];\n                    diffs.splice(pointer + 1, 1);\n                    changes = true;\n                }\n            }\n            pointer++;\n        }\n        // If shifts were made, the diff needs reordering and another shift sweep.\n        if (changes) {\n            this.diff_cleanupMerge(diffs);\n        }\n    };\n    ;\n    /**\n     * loc is a location in text1, compute and return the equivalent location in\n     * text2.\n     * e.g. 'The cat' vs 'The big cat', 1->1, 5->8\n     * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n     * @param {number} loc Location within text1.\n     * @return {number} Location within text2.\n     */\n    DiffMatchPatch.prototype.diff_xIndex = function (diffs, loc) {\n        var chars1 = 0;\n        var chars2 = 0;\n        var last_chars1 = 0;\n        var last_chars2 = 0;\n        var x;\n        for (x = 0; x < diffs.length; x++) {\n            if (diffs[x][0] !== 1 /* Insert */) {\n                chars1 += diffs[x][1].length;\n            }\n            if (diffs[x][0] !== -1 /* Delete */) {\n                chars2 += diffs[x][1].length;\n            }\n            if (chars1 > loc) {\n                break;\n            }\n            last_chars1 = chars1;\n            last_chars2 = chars2;\n        }\n        // Was the location was deleted?\n        if (diffs.length != x && diffs[x][0] === -1 /* Delete */) {\n            return last_chars2;\n        }\n        // Add the remaining character length.\n        return last_chars2 + (loc - last_chars1);\n    };\n    ;\n    /**\n     * Compute and return the source text (all equalities and deletions).\n     * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n     * @return {string} Source text.\n     */\n    DiffMatchPatch.prototype.diff_text1 = function (diffs) {\n        var text = [];\n        for (var x = 0; x < diffs.length; x++) {\n            if (diffs[x][0] !== 1 /* Insert */) {\n                text[x] = diffs[x][1];\n            }\n        }\n        return text.join('');\n    };\n    ;\n    /**\n     * Compute and return the destination text (all equalities and insertions).\n     * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n     * @return {string} Destination text.\n     */\n    DiffMatchPatch.prototype.diff_text2 = function (diffs) {\n        var text = [];\n        for (var x = 0; x < diffs.length; x++) {\n            if (diffs[x][0] !== -1 /* Delete */) {\n                text[x] = diffs[x][1];\n            }\n        }\n        return text.join('');\n    };\n    ;\n    /**\n     * Compute the Levenshtein distance; the number of inserted, deleted or\n     * substituted characters.\n     * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n     * @return {number} Number of changes.\n     */\n    DiffMatchPatch.prototype.diff_levenshtein = function (diffs) {\n        var levenshtein = 0;\n        var insertions = 0;\n        var deletions = 0;\n        for (var x = 0; x < diffs.length; x++) {\n            var op = diffs[x][0];\n            var data = diffs[x][1];\n            switch (op) {\n                case 1 /* Insert */:\n                    insertions += data.length;\n                    break;\n                case -1 /* Delete */:\n                    deletions += data.length;\n                    break;\n                case 0 /* Equal */:\n                    // A deletion and an insertion is one substitution.\n                    levenshtein += Math.max(insertions, deletions);\n                    insertions = 0;\n                    deletions = 0;\n                    break;\n            }\n        }\n        levenshtein += Math.max(insertions, deletions);\n        return levenshtein;\n    };\n    ;\n    /**\n     * Crush the diff into an encoded string which describes the operations\n     * required to transform text1 into text2.\n     * E.g. =3\\t-2\\t+ing  -> Keep 3 chars, delete 2 chars, insert 'ing'.\n     * Operations are tab-separated.  Inserted text is escaped using %xx notation.\n     * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n     * @return {string} Delta text.\n     */\n    DiffMatchPatch.prototype.diff_toDelta = function (diffs) {\n        var text = [];\n        for (var x = 0; x < diffs.length; x++) {\n            switch (diffs[x][0]) {\n                case 1 /* Insert */:\n                    text[x] = '+' + encodeURI(diffs[x][1]);\n                    break;\n                case -1 /* Delete */:\n                    text[x] = '-' + diffs[x][1].length;\n                    break;\n                case 0 /* Equal */:\n                    text[x] = '=' + diffs[x][1].length;\n                    break;\n            }\n        }\n        return text.join('\\t').replace(/%20/g, ' ');\n    };\n    ;\n    /**\n     * Given the original text1, and an encoded string which describes the\n     * operations required to transform text1 into text2, compute the full diff.\n     * @param {string} text1 Source string for the diff.\n     * @param {string} delta Delta text.\n     * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n     * @throws {!Error} If invalid input.\n     */\n    DiffMatchPatch.prototype.diff_fromDelta = function (text1, delta) {\n        var diffs = [];\n        var diffsLength = 0; // Keeping our own length const is faster in JS.\n        var pointer = 0; // Cursor in text1\n        var tokens = delta.split(/\\t/g);\n        for (var x = 0; x < tokens.length; x++) {\n            // Each token begins with a one character parameter which specifies the\n            // operation of this token (delete, insert, equality).\n            var param = tokens[x].substring(1);\n            switch (tokens[x].charAt(0)) {\n                case '+':\n                    try {\n                        diffs[diffsLength++] = [1 /* Insert */, decodeURI(param)];\n                    }\n                    catch (ex) {\n                        // Malformed URI sequence.\n                        throw new Error('Illegal escape in diff_fromDelta: ' + param);\n                    }\n                    break;\n                case '-':\n                // Fall through.\n                case '=':\n                    var n = parseInt(param, 10);\n                    if (isNaN(n) || n < 0) {\n                        throw new Error('Invalid number in diff_fromDelta: ' + param);\n                    }\n                    var text = text1.substring(pointer, pointer += n);\n                    if (tokens[x].charAt(0) == '=') {\n                        diffs[diffsLength++] = [0 /* Equal */, text];\n                    }\n                    else {\n                        diffs[diffsLength++] = [-1 /* Delete */, text];\n                    }\n                    break;\n                default:\n                    // Blank tokens are ok (from a trailing \\t).\n                    // Anything else is an error.\n                    if (tokens[x]) {\n                        throw new Error('Invalid diff operation in diff_fromDelta: ' +\n                            tokens[x]);\n                    }\n            }\n        }\n        if (pointer != text1.length) {\n            throw new Error('Delta length (' + pointer +\n                ') does not equal source text length (' + text1.length + ').');\n        }\n        return diffs;\n    };\n    ;\n    /**\n     * Locate the best instance of 'pattern' in 'text' near 'loc'.\n     * @param {string} text The text to search.\n     * @param {string} pattern The pattern to search for.\n     * @param {number} loc The location to search around.\n     * @return {number} Best match index or -1.\n     */\n    DiffMatchPatch.prototype.match_main = function (text, pattern, loc) {\n        // Check for null inputs.\n        if (text == null || pattern == null || loc == null) {\n            throw new Error('Null input. (match_main)');\n        }\n        loc = Math.max(0, Math.min(loc, text.length));\n        if (text == pattern) {\n            // Shortcut (potentially not guaranteed by the algorithm)\n            return 0;\n        }\n        else if (!text.length) {\n            // Nothing to match.\n            return -1;\n        }\n        else if (text.substring(loc, loc + pattern.length) == pattern) {\n            // Perfect match at the perfect spot!  (Includes case of null pattern)\n            return loc;\n        }\n        else {\n            // Do a fuzzy compare.\n            return this.match_bitap_(text, pattern, loc);\n        }\n    };\n    ;\n    /**\n     * Locate the best instance of 'pattern' in 'text' near 'loc' using the\n     * Bitap algorithm.\n     * @param {string} text The text to search.\n     * @param {string} pattern The pattern to search for.\n     * @param {number} loc The location to search around.\n     * @return {number} Best match index or -1.\n     * @private\n     */\n    DiffMatchPatch.prototype.match_bitap_ = function (text, pattern, loc) {\n        if (pattern.length > this.Match_MaxBits) {\n            throw new Error('Pattern too long for this browser.');\n        }\n        // Initialise the alphabet.\n        var s = this.match_alphabet_(pattern);\n        var dmp = this; // 'this' becomes 'window' in a closure.\n        /**\n         * Compute and return the score for a match with e errors and x location.\n         * Accesses loc and pattern through being a closure.\n         * @param {number} e Number of errors in match.\n         * @param {number} x Location of match.\n         * @return {number} Overall score for match (0.0 = good, 1.0 = bad).\n         * @private\n         */\n        function match_bitapScore_(e, x) {\n            var accuracy = e / pattern.length;\n            var proximity = Math.abs(loc - x);\n            if (!dmp.Match_Distance) {\n                // Dodge divide by zero error.\n                return proximity ? 1.0 : accuracy;\n            }\n            return accuracy + (proximity / dmp.Match_Distance);\n        }\n        // Highest score beyond which we give up.\n        var score_threshold = this.Match_Threshold;\n        // Is there a nearby exact match? (speedup)\n        var best_loc = text.indexOf(pattern, loc);\n        if (best_loc != -1) {\n            score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);\n            // What about in the other direction? (speedup)\n            best_loc = text.lastIndexOf(pattern, loc + pattern.length);\n            if (best_loc != -1) {\n                score_threshold =\n                    Math.min(match_bitapScore_(0, best_loc), score_threshold);\n            }\n        }\n        // Initialise the bit arrays.\n        var matchmask = 1 << (pattern.length - 1);\n        best_loc = -1;\n        var bin_min, bin_mid;\n        var bin_max = pattern.length + text.length;\n        var last_rd;\n        for (var d = 0; d < pattern.length; d++) {\n            // Scan for the best match; each iteration allows for one more error.\n            // Run a binary search to determine how far from 'loc' we can stray at this\n            // error level.\n            bin_min = 0;\n            bin_mid = bin_max;\n            while (bin_min < bin_mid) {\n                if (match_bitapScore_(d, loc + bin_mid) <= score_threshold) {\n                    bin_min = bin_mid;\n                }\n                else {\n                    bin_max = bin_mid;\n                }\n                bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);\n            }\n            // Use the result from this iteration as the maximum for the next.\n            bin_max = bin_mid;\n            var start = Math.max(1, loc - bin_mid + 1);\n            var finish = Math.min(loc + bin_mid, text.length) + pattern.length;\n            var rd = Array(finish + 2);\n            rd[finish + 1] = (1 << d) - 1;\n            for (var j = finish; j >= start; j--) {\n                // The alphabet (s) is a sparse hash, so the following line generates\n                // warnings.\n                var charMatch = s[text.charAt(j - 1)];\n                if (d === 0) {\n                    rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;\n                }\n                else {\n                    rd[j] = (((rd[j + 1] << 1) | 1) & charMatch) |\n                        (((last_rd[j + 1] | last_rd[j]) << 1) | 1) |\n                        last_rd[j + 1];\n                }\n                if (rd[j] & matchmask) {\n                    var score = match_bitapScore_(d, j - 1);\n                    // This match will almost certainly be better than any existing match.\n                    // But check anyway.\n                    if (score <= score_threshold) {\n                        // Told you so.\n                        score_threshold = score;\n                        best_loc = j - 1;\n                        if (best_loc > loc) {\n                            // When passing loc, don't exceed our current distance from loc.\n                            start = Math.max(1, 2 * loc - best_loc);\n                        }\n                        else {\n                            // Already passed loc, downhill from here on in.\n                            break;\n                        }\n                    }\n                }\n            }\n            // No hope for a (better) match at greater error levels.\n            if (match_bitapScore_(d + 1, loc) > score_threshold) {\n                break;\n            }\n            last_rd = rd;\n        }\n        return best_loc;\n    };\n    ;\n    /**\n     * Initialise the alphabet for the Bitap algorithm.\n     * @param {string} pattern The text to encode.\n     * @return {!Object} Hash of character locations.\n     * @private\n     */\n    DiffMatchPatch.prototype.match_alphabet_ = function (pattern) {\n        var s = {};\n        for (var i = 0; i < pattern.length; i++) {\n            s[pattern.charAt(i)] = 0;\n        }\n        for (var i = 0; i < pattern.length; i++) {\n            s[pattern.charAt(i)] |= 1 << (pattern.length - i - 1);\n        }\n        return s;\n    };\n    ;\n    /**\n     * Increase the context until it is unique,\n     * but don't let the pattern expand beyond Match_MaxBits.\n     * @param {!diff_match_patch.patch_obj} patch The patch to grow.\n     * @param {string} text Source text.\n     * @private\n     */\n    DiffMatchPatch.prototype.patch_addContext_ = function (patch, text) {\n        if (text.length == 0) {\n            return;\n        }\n        var pattern = text.substring(patch.start2, patch.start2 + patch.length1);\n        var padding = 0;\n        // Look for the first and last matches of pattern in text.  If two different\n        // matches are found, increase the pattern length.\n        while (text.indexOf(pattern) != text.lastIndexOf(pattern) &&\n            pattern.length < this.Match_MaxBits - this.Patch_Margin -\n                this.Patch_Margin) {\n            padding += this.Patch_Margin;\n            pattern = text.substring(patch.start2 - padding, patch.start2 + patch.length1 + padding);\n        }\n        // Add one chunk for good luck.\n        padding += this.Patch_Margin;\n        // Add the prefix.\n        var prefix = text.substring(patch.start2 - padding, patch.start2);\n        if (prefix) {\n            patch.diffs.unshift([0 /* Equal */, prefix]);\n        }\n        // Add the suffix.\n        var suffix = text.substring(patch.start2 + patch.length1, patch.start2 + patch.length1 + padding);\n        if (suffix) {\n            patch.diffs.push([0 /* Equal */, suffix]);\n        }\n        // Roll back the start points.\n        patch.start1 -= prefix.length;\n        patch.start2 -= prefix.length;\n        // Extend the lengths.\n        patch.length1 += prefix.length + suffix.length;\n        patch.length2 += prefix.length + suffix.length;\n    };\n    ;\n    /**\n     * Compute a list of patches to turn text1 into text2.\n     * Use diffs if provided, otherwise compute it ourselves.\n     * There are four ways to call this function, depending on what data is\n     * available to the caller:\n     * Method 1:\n     * a = text1, b = text2\n     * Method 2:\n     * a = diffs\n     * Method 3 (optimal):\n     * a = text1, b = diffs\n     * Method 4 (deprecated, use method 3):\n     * a = text1, b = text2, c = diffs\n     *\n     * @param {string|!Array.<!diff_match_patch.Diff>} a text1 (methods 1,3,4) or\n     * Array of diff tuples for text1 to text2 (method 2).\n     * @param {string|!Array.<!diff_match_patch.Diff>} opt_b text2 (methods 1,4) or\n     * Array of diff tuples for text1 to text2 (method 3) or undefined (method 2).\n     * @param {string|!Array.<!diff_match_patch.Diff>} opt_c Array of diff tuples\n     * for text1 to text2 (method 4) or undefined (methods 1,2,3).\n     * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.\n     */\n    DiffMatchPatch.prototype.patch_make = function (a, opt_b, opt_c) {\n        var text1, diffs;\n        if (typeof a == 'string' && typeof opt_b == 'string' &&\n            typeof opt_c == 'undefined') {\n            // Method 1: text1, text2\n            // Compute diffs from text1 and text2.\n            text1 = (a);\n            diffs = this.diff_main(text1, /** @type {string} */ (opt_b), true);\n            if (diffs.length > 2) {\n                this.diff_cleanupSemantic(diffs);\n                this.diff_cleanupEfficiency(diffs);\n            }\n        }\n        else if (a && typeof a == 'object' && typeof opt_b == 'undefined' &&\n            typeof opt_c == 'undefined') {\n            // Method 2: diffs\n            // Compute text1 from diffs.\n            diffs = (a);\n            text1 = this.diff_text1(diffs);\n        }\n        else if (typeof a == 'string' && opt_b && typeof opt_b == 'object' &&\n            typeof opt_c == 'undefined') {\n            // Method 3: text1, diffs\n            text1 = (a);\n            diffs = (opt_b);\n        }\n        else if (typeof a == 'string' && typeof opt_b == 'string' &&\n            opt_c && typeof opt_c == 'object') {\n            // Method 4: text1, text2, diffs\n            // text2 is not used.\n            text1 = (a);\n            diffs = (opt_c);\n        }\n        else {\n            throw new Error('Unknown call format to patch_make.');\n        }\n        if (diffs.length === 0) {\n            return []; // Get rid of the null case.\n        }\n        var patches = [];\n        var patch = new patch_obj();\n        var patchDiffLength = 0; // Keeping our own length const is faster in JS.\n        var char_count1 = 0; // Number of characters into the text1 string.\n        var char_count2 = 0; // Number of characters into the text2 string.\n        // Start with text1 (prepatch_text) and apply the diffs until we arrive at\n        // text2 (postpatch_text).  We recreate the patches one by one to determine\n        // context info.\n        var prepatch_text = text1;\n        var postpatch_text = text1;\n        for (var x = 0; x < diffs.length; x++) {\n            var diff_type = diffs[x][0];\n            var diff_text = diffs[x][1];\n            if (!patchDiffLength && diff_type !== 0 /* Equal */) {\n                // A new patch starts here.\n                patch.start1 = char_count1;\n                patch.start2 = char_count2;\n            }\n            switch (diff_type) {\n                case 1 /* Insert */:\n                    patch.diffs[patchDiffLength++] = diffs[x];\n                    patch.length2 += diff_text.length;\n                    postpatch_text = postpatch_text.substring(0, char_count2) + diff_text +\n                        postpatch_text.substring(char_count2);\n                    break;\n                case -1 /* Delete */:\n                    patch.length1 += diff_text.length;\n                    patch.diffs[patchDiffLength++] = diffs[x];\n                    postpatch_text = postpatch_text.substring(0, char_count2) +\n                        postpatch_text.substring(char_count2 +\n                            diff_text.length);\n                    break;\n                case 0 /* Equal */:\n                    if (diff_text.length <= 2 * this.Patch_Margin &&\n                        patchDiffLength && diffs.length != x + 1) {\n                        // Small equality inside a patch.\n                        patch.diffs[patchDiffLength++] = diffs[x];\n                        patch.length1 += diff_text.length;\n                        patch.length2 += diff_text.length;\n                    }\n                    else if (diff_text.length >= 2 * this.Patch_Margin) {\n                        // Time for a new patch.\n                        if (patchDiffLength) {\n                            this.patch_addContext_(patch, prepatch_text);\n                            patches.push(patch);\n                            patch = new patch_obj();\n                            patchDiffLength = 0;\n                            // Unlike Unidiff, our patch lists have a rolling context.\n                            // http://code.google.com/p/google-diff-match-patch/wiki/Unidiff\n                            // Update prepatch text & pos to reflect the application of the\n                            // just completed patch.\n                            prepatch_text = postpatch_text;\n                            char_count1 = char_count2;\n                        }\n                    }\n                    break;\n            }\n            // Update the current character count.\n            if (diff_type !== 1 /* Insert */) {\n                char_count1 += diff_text.length;\n            }\n            if (diff_type !== -1 /* Delete */) {\n                char_count2 += diff_text.length;\n            }\n        }\n        // Pick up the leftover patch if not empty.\n        if (patchDiffLength) {\n            this.patch_addContext_(patch, prepatch_text);\n            patches.push(patch);\n        }\n        return patches;\n    };\n    ;\n    /**\n     * Given an array of patches, return another array that is identical.\n     * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n     * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.\n     */\n    DiffMatchPatch.prototype.patch_deepCopy = function (patches) {\n        // Making deep copies is hard in JavaScript.\n        var patchesCopy = [];\n        for (var x = 0; x < patches.length; x++) {\n            var patch = patches[x];\n            var patchCopy = new patch_obj();\n            patchCopy.diffs = [];\n            for (var y = 0; y < patch.diffs.length; y++) {\n                patchCopy.diffs[y] = [patch.diffs[y][0], patch.diffs[y][1]];\n            }\n            patchCopy.start1 = patch.start1;\n            patchCopy.start2 = patch.start2;\n            patchCopy.length1 = patch.length1;\n            patchCopy.length2 = patch.length2;\n            patchesCopy[x] = patchCopy;\n        }\n        return patchesCopy;\n    };\n    ;\n    /**\n     * Merge a set of patches onto the text.  Return a patched text, as well\n     * as a list of true/false values indicating which patches were applied.\n     * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n     * @param {string} text Old text.\n     * @return {!Array.<string|!Array.<boolean>>} Two element Array, containing the\n     *      new text and an array of boolean values.\n     */\n    DiffMatchPatch.prototype.patch_apply = function (patches, text) {\n        if (patches.length == 0) {\n            return [text, []];\n        }\n        // Deep copy the patches so that no changes are made to originals.\n        patches = this.patch_deepCopy(patches);\n        var nullPadding = this.patch_addPadding(patches);\n        text = nullPadding + text + nullPadding;\n        this.patch_splitMax(patches);\n        // delta keeps track of the offset between the expected and actual location\n        // of the previous patch.  If there are patches expected at positions 10 and\n        // 20, but the first patch was found at 12, delta is 2 and the second patch\n        // has an effective expected position of 22.\n        var delta = 0;\n        var results = [];\n        for (var x = 0; x < patches.length; x++) {\n            var expected_loc = patches[x].start2 + delta;\n            var text1 = this.diff_text1(patches[x].diffs);\n            var start_loc = void 0;\n            var end_loc = -1;\n            if (text1.length > this.Match_MaxBits) {\n                // patch_splitMax will only provide an oversized pattern in the case of\n                // a monster delete.\n                start_loc = this.match_main(text, text1.substring(0, this.Match_MaxBits), expected_loc);\n                if (start_loc != -1) {\n                    end_loc = this.match_main(text, text1.substring(text1.length - this.Match_MaxBits), expected_loc + text1.length - this.Match_MaxBits);\n                    if (end_loc == -1 || start_loc >= end_loc) {\n                        // Can't find valid trailing context.  Drop this patch.\n                        start_loc = -1;\n                    }\n                }\n            }\n            else {\n                start_loc = this.match_main(text, text1, expected_loc);\n            }\n            if (start_loc == -1) {\n                // No match found.  :(\n                results[x] = false;\n                // Subtract the delta for this failed patch from subsequent patches.\n                delta -= patches[x].length2 - patches[x].length1;\n            }\n            else {\n                // Found a match.  :)\n                results[x] = true;\n                delta = start_loc - expected_loc;\n                var text2 = void 0;\n                if (end_loc == -1) {\n                    text2 = text.substring(start_loc, start_loc + text1.length);\n                }\n                else {\n                    text2 = text.substring(start_loc, end_loc + this.Match_MaxBits);\n                }\n                if (text1 == text2) {\n                    // Perfect match, just shove the replacement text in.\n                    text = text.substring(0, start_loc) +\n                        this.diff_text2(patches[x].diffs) +\n                        text.substring(start_loc + text1.length);\n                }\n                else {\n                    // Imperfect match.  Run a diff to get a framework of equivalent\n                    // indices.\n                    var diffs = this.diff_main(text1, text2, false);\n                    if (text1.length > this.Match_MaxBits &&\n                        this.diff_levenshtein(diffs) / text1.length >\n                            this.Patch_DeleteThreshold) {\n                        // The end points match, but the content is unacceptably bad.\n                        results[x] = false;\n                    }\n                    else {\n                        this.diff_cleanupSemanticLossless(diffs);\n                        var index1 = 0;\n                        var index2 = void 0;\n                        for (var y = 0; y < patches[x].diffs.length; y++) {\n                            var mod = patches[x].diffs[y];\n                            if (mod[0] !== 0 /* Equal */) {\n                                index2 = this.diff_xIndex(diffs, index1);\n                            }\n                            if (mod[0] === 1 /* Insert */) {\n                                text = text.substring(0, start_loc + index2) + mod[1] +\n                                    text.substring(start_loc + index2);\n                            }\n                            else if (mod[0] === -1 /* Delete */) {\n                                text = text.substring(0, start_loc + index2) +\n                                    text.substring(start_loc + this.diff_xIndex(diffs, index1 + mod[1].length));\n                            }\n                            if (mod[0] !== -1 /* Delete */) {\n                                index1 += mod[1].length;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        // Strip the padding off.\n        text = text.substring(nullPadding.length, text.length - nullPadding.length);\n        return [text, results];\n    };\n    ;\n    /**\n     * Add some padding on text start and end so that edges can match something.\n     * Intended to be called only from within patch_apply.\n     * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n     * @return {string} The padding string added to each side.\n     */\n    DiffMatchPatch.prototype.patch_addPadding = function (patches) {\n        var paddingLength = this.Patch_Margin;\n        var nullPadding = '';\n        for (var x = 1; x <= paddingLength; x++) {\n            nullPadding += String.fromCharCode(x);\n        }\n        // Bump all the patches forward.\n        for (var x = 0; x < patches.length; x++) {\n            patches[x].start1 += paddingLength;\n            patches[x].start2 += paddingLength;\n        }\n        // Add some padding on start of first diff.\n        var patch = patches[0];\n        var diffs = patch.diffs;\n        if (diffs.length == 0 || diffs[0][0] != 0 /* Equal */) {\n            // Add nullPadding equality.\n            diffs.unshift([0 /* Equal */, nullPadding]);\n            patch.start1 -= paddingLength; // Should be 0.\n            patch.start2 -= paddingLength; // Should be 0.\n            patch.length1 += paddingLength;\n            patch.length2 += paddingLength;\n        }\n        else if (paddingLength > diffs[0][1].length) {\n            // Grow first equality.\n            var extraLength = paddingLength - diffs[0][1].length;\n            diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];\n            patch.start1 -= extraLength;\n            patch.start2 -= extraLength;\n            patch.length1 += extraLength;\n            patch.length2 += extraLength;\n        }\n        // Add some padding on end of last diff.\n        patch = patches[patches.length - 1];\n        diffs = patch.diffs;\n        if (diffs.length == 0 || diffs[diffs.length - 1][0] != 0 /* Equal */) {\n            // Add nullPadding equality.\n            diffs.push([0 /* Equal */, nullPadding]);\n            patch.length1 += paddingLength;\n            patch.length2 += paddingLength;\n        }\n        else if (paddingLength > diffs[diffs.length - 1][1].length) {\n            // Grow last equality.\n            var extraLength = paddingLength - diffs[diffs.length - 1][1].length;\n            diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);\n            patch.length1 += extraLength;\n            patch.length2 += extraLength;\n        }\n        return nullPadding;\n    };\n    ;\n    /**\n     * Take a list of patches and return a textual representation.\n     * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n     * @return {string} Text representation of patches.\n     */\n    DiffMatchPatch.prototype.patch_toText = function (patches) {\n        var text = [];\n        for (var x = 0; x < patches.length; x++) {\n            text[x] = patches[x];\n        }\n        return text.join('');\n    };\n    ;\n    /**\n     * Parse a textual representation of patches and return a list of Patch objects.\n     * @param {string} textline Text representation of patches.\n     * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.\n     * @throws {!Error} If invalid input.\n     */\n    DiffMatchPatch.prototype.patch_fromText = function (textline) {\n        var patches = [];\n        if (!textline) {\n            return patches;\n        }\n        var text = textline.split('\\n');\n        var textPointer = 0;\n        var patchHeader = /^@@ -(\\d+),?(\\d*) \\+(\\d+),?(\\d*) @@$/;\n        while (textPointer < text.length) {\n            var m = text[textPointer].match(patchHeader);\n            if (!m) {\n                throw new Error('Invalid patch string: ' + text[textPointer]);\n            }\n            var patch = new patch_obj();\n            patches.push(patch);\n            patch.start1 = parseInt(m[1], 10);\n            if (m[2] === '') {\n                patch.start1--;\n                patch.length1 = 1;\n            }\n            else if (m[2] == '0') {\n                patch.length1 = 0;\n            }\n            else {\n                patch.start1--;\n                patch.length1 = parseInt(m[2], 10);\n            }\n            patch.start2 = parseInt(m[3], 10);\n            if (m[4] === '') {\n                patch.start2--;\n                patch.length2 = 1;\n            }\n            else if (m[4] == '0') {\n                patch.length2 = 0;\n            }\n            else {\n                patch.start2--;\n                patch.length2 = parseInt(m[4], 10);\n            }\n            textPointer++;\n            while (textPointer < text.length) {\n                var sign = text[textPointer].charAt(0);\n                var line = void 0;\n                try {\n                    line = decodeURI(text[textPointer].substring(1));\n                }\n                catch (ex) {\n                    // Malformed URI sequence.\n                    throw new Error('Illegal escape in patch_fromText: ' + line);\n                }\n                if (sign == '-') {\n                    // Deletion.\n                    patch.diffs.push([-1 /* Delete */, line]);\n                }\n                else if (sign == '+') {\n                    // Insertion.\n                    patch.diffs.push([1 /* Insert */, line]);\n                }\n                else if (sign == ' ') {\n                    // Minor equality.\n                    patch.diffs.push([0 /* Equal */, line]);\n                }\n                else if (sign == '@') {\n                    // Start of next patch.\n                    break;\n                }\n                else if (sign === '') {\n                    // Blank line?  Whatever.\n                }\n                else {\n                    // WTF?\n                    throw new Error('Invalid patch mode \"' + sign + '\" in: ' + line);\n                }\n                textPointer++;\n            }\n        }\n        return patches;\n    };\n    ;\n    return DiffMatchPatch;\n}());\nexports.DiffMatchPatch = DiffMatchPatch;\n/**\n * Class representing one patch operation.\n * @constructor\n */\nvar patch_obj = (function () {\n    function patch_obj() {\n        this.diffs = [];\n        this.start1 = null;\n        this.start2 = null;\n        this.length1 = 0;\n        this.length2 = 0;\n        /**\n         * Emmulate GNU diff's format.\n         * Header: @@ -382,8 +481,9 @@\n         * Indicies are printed as 1-based, not 0-based.\n         */\n        this.toString = function () {\n            var coords1, coords2;\n            if (this.length1 === 0) {\n                coords1 = this.start1 + ',0';\n            }\n            else if (this.length1 == 1) {\n                coords1 = this.start1 + 1;\n            }\n            else {\n                coords1 = (this.start1 + 1) + ',' + this.length1;\n            }\n            if (this.length2 === 0) {\n                coords2 = this.start2 + ',0';\n            }\n            else if (this.length2 == 1) {\n                coords2 = this.start2 + 1;\n            }\n            else {\n                coords2 = (this.start2 + 1) + ',' + this.length2;\n            }\n            var text = ['@@ -' + coords1 + ' +' + coords2 + ' @@\\n'];\n            var op;\n            // Escape the body of the patch with %xx notation.\n            for (var x = 0; x < this.diffs.length; x++) {\n                switch (this.diffs[x][0]) {\n                    case 1 /* Insert */:\n                        op = '+';\n                        break;\n                    case -1 /* Delete */:\n                        op = '-';\n                        break;\n                    case 0 /* Equal */:\n                        op = ' ';\n                        break;\n                }\n                text[x + 1] = op + encodeURI(this.diffs[x][1]) + '\\n';\n            }\n            return text.join('').replace(/%20/g, ' ');\n        };\n    }\n    return patch_obj;\n}());\nexports.patch_obj = patch_obj;\n//# sourceMappingURL=diffMatchPatch.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmctZGlmZi1tYXRjaC1wYXRjaC9kaXN0L2RpZmZNYXRjaFBhdGNoLmpzPzJkOGEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0NBQWdDO0FBQ25ELG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGtCQUFrQjtBQUM3QyxxQ0FBcUM7QUFDckMsdUNBQXVDO0FBQ3ZDLDJEQUEyRCw0QkFBNEI7QUFDdkYsOENBQThDLGdDQUFnQztBQUM5RTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFDQUFxQztBQUN4RDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsb0JBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBLGdCQUFnQixnQ0FBZ0M7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLGdDQUFnQztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLGdDQUFnQztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFFBQVE7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLGdDQUFnQztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixjQUFjO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixXQUFXO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsaUJBQWlCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxpQkFBaUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLGdDQUFnQztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQ0FBZ0M7QUFDL0MsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtCQUFrQjtBQUN6QztBQUNBO0FBQ0EsMkJBQTJCLGtCQUFrQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQ0FBZ0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLGlDQUFpQztBQUNqQyxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0NBQWdDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUIsb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0NBQWdDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QixpQ0FBaUM7QUFDakMsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdDQUFnQztBQUMvQztBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdDQUFnQztBQUMvQyxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQ0FBZ0M7QUFDL0MsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtCQUFrQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdDQUFnQztBQUMvQyxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsa0JBQWtCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQSxlQUFlLGdDQUFnQztBQUMvQyxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtCQUFrQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQ0FBZ0M7QUFDL0MsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtCQUFrQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixnQ0FBZ0M7QUFDaEQsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLHdCQUF3QjtBQUN4QjtBQUNBLHVCQUF1QixtQkFBbUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUIsb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG9CQUFvQjtBQUMzQyx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsWUFBWTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG9CQUFvQjtBQUMzQztBQUNBO0FBQ0EsdUJBQXVCLG9CQUFvQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw0QkFBNEI7QUFDM0MsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVDQUF1QztBQUN0RDtBQUNBLGVBQWUsdUNBQXVDO0FBQ3REO0FBQ0EsZUFBZSx1Q0FBdUM7QUFDdEQ7QUFDQSxnQkFBZ0IscUNBQXFDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsT0FBTztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyw0QkFBNEI7QUFDNUIsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsa0JBQWtCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxQ0FBcUM7QUFDcEQsZ0JBQWdCLHFDQUFxQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixvQkFBb0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHdCQUF3QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxQ0FBcUM7QUFDcEQsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixpQ0FBaUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixvQkFBb0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyw2QkFBNkI7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFDQUFxQztBQUNwRCxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixvQkFBb0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG9CQUFvQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscUNBQXFDO0FBQ3BELGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixvQkFBb0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLHFDQUFxQztBQUNyRCxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsdUJBQXVCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9uZy1kaWZmLW1hdGNoLXBhdGNoL2Rpc3QvZGlmZk1hdGNoUGF0Y2guanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQ2xhc3MgY29udGFpbmluZyB0aGUgZGlmZiwgbWF0Y2ggYW5kIHBhdGNoIG1ldGhvZHMuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIERpZmZNYXRjaFBhdGNoID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEaWZmTWF0Y2hQYXRjaCgpIHtcbiAgICAgICAgLy8gRGVmYXVsdHMuXG4gICAgICAgIC8vIFJlZGVmaW5lIHRoZXNlIGluIHlvdXIgcHJvZ3JhbSB0byBvdmVycmlkZSB0aGUgZGVmYXVsdHMuXG4gICAgICAgIC8vIE51bWJlciBvZiBzZWNvbmRzIHRvIG1hcCBhIGRpZmYgYmVmb3JlIGdpdmluZyB1cCAoMCBmb3IgaW5maW5pdHkpLlxuICAgICAgICB0aGlzLkRpZmZfVGltZW91dCA9IDEuMDtcbiAgICAgICAgLy8gQ29zdCBvZiBhbiBlbXB0eSBlZGl0IG9wZXJhdGlvbiBpbiB0ZXJtcyBvZiBlZGl0IGNoYXJhY3RlcnMuXG4gICAgICAgIHRoaXMuRGlmZl9FZGl0Q29zdCA9IDQ7XG4gICAgICAgIC8vIEF0IHdoYXQgcG9pbnQgaXMgbm8gbWF0Y2ggZGVjbGFyZWQgKDAuMCA9IHBlcmZlY3Rpb24sIDEuMCA9IHZlcnkgbG9vc2UpLlxuICAgICAgICB0aGlzLk1hdGNoX1RocmVzaG9sZCA9IDAuNTtcbiAgICAgICAgLy8gSG93IGZhciB0byBzZWFyY2ggZm9yIGEgbWF0Y2ggKDAgPSBleGFjdCBsb2NhdGlvbiwgMTAwMCsgPSBicm9hZCBtYXRjaCkuXG4gICAgICAgIC8vIEEgbWF0Y2ggdGhpcyBtYW55IGNoYXJhY3RlcnMgYXdheSBmcm9tIHRoZSBleHBlY3RlZCBsb2NhdGlvbiB3aWxsIGFkZFxuICAgICAgICAvLyAxLjAgdG8gdGhlIHNjb3JlICgwLjAgaXMgYSBwZXJmZWN0IG1hdGNoKS5cbiAgICAgICAgdGhpcy5NYXRjaF9EaXN0YW5jZSA9IDEwMDA7XG4gICAgICAgIC8vIFdoZW4gZGVsZXRpbmcgYSBsYXJnZSBibG9jayBvZiB0ZXh0IChvdmVyIH42NCBjaGFyYWN0ZXJzKSwgaG93IGNsb3NlIGRvXG4gICAgICAgIC8vIHRoZSBjb250ZW50cyBoYXZlIHRvIGJlIHRvIG1hdGNoIHRoZSBleHBlY3RlZCBjb250ZW50cy4gKDAuMCA9IHBlcmZlY3Rpb24sXG4gICAgICAgIC8vIDEuMCA9IHZlcnkgbG9vc2UpLiAgTm90ZSB0aGF0IE1hdGNoX1RocmVzaG9sZCBjb250cm9scyBob3cgY2xvc2VseSB0aGVcbiAgICAgICAgLy8gZW5kIHBvaW50cyBvZiBhIGRlbGV0ZSBuZWVkIHRvIG1hdGNoLlxuICAgICAgICB0aGlzLlBhdGNoX0RlbGV0ZVRocmVzaG9sZCA9IDAuNTtcbiAgICAgICAgLy8gQ2h1bmsgc2l6ZSBmb3IgY29udGV4dCBsZW5ndGguXG4gICAgICAgIHRoaXMuUGF0Y2hfTWFyZ2luID0gNDtcbiAgICAgICAgLy8gVGhlIG51bWJlciBvZiBiaXRzIGluIGFuIGludC5cbiAgICAgICAgdGhpcy5NYXRjaF9NYXhCaXRzID0gMzI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGF0YSBzdHJ1Y3R1cmUgcmVwcmVzZW50aW5nIGEgZGlmZiBpcyBhbiBhcnJheSBvZiB0dXBsZXM6XG4gICAgICAgICAqIFtbRGlmZk9wLkRlbGV0ZSwgJ0hlbGxvJ10sIFtEaWZmT3AuSW5zZXJ0LCAnR29vZGJ5ZSddLCBbRGlmZk9wLkVxdWFsLCAnIHdvcmxkLiddXVxuICAgICAgICAgKiB3aGljaCBtZWFuczogZGVsZXRlICdIZWxsbycsIGFkZCAnR29vZGJ5ZScgYW5kIGtlZXAgJyB3b3JsZC4nXG4gICAgICAgICAqL1xuICAgICAgICAvLyBEZWZpbmUgc29tZSByZWdleCBwYXR0ZXJucyBmb3IgbWF0Y2hpbmcgYm91bmRhcmllcy5cbiAgICAgICAgdGhpcy53aGl0ZXNwYWNlUmVnZXhfID0gbmV3IFJlZ0V4cCgnL1xccy8nKTtcbiAgICAgICAgdGhpcy5saW5lYnJlYWtSZWdleF8gPSBuZXcgUmVnRXhwKCcvW1xcclxcbl0vJyk7XG4gICAgICAgIHRoaXMuYmxhbmtsaW5lRW5kUmVnZXhfID0gbmV3IFJlZ0V4cCgnL1xcblxccj9cXG4kLycpO1xuICAgICAgICB0aGlzLmJsYW5rbGluZVN0YXJ0UmVnZXhfID0gbmV3IFJlZ0V4cCgnL15cXHI/XFxuXFxyP1xcbi8nKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnQgYSBkaWZmIGFycmF5IGludG8gYSBwcmV0dHkgSFRNTCByZXBvcnQuXG4gICAgICAgICAqIEBwYXJhbSB7IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5EaWZmPn0gZGlmZnMgQXJyYXkgb2YgZGlmZiB0dXBsZXMuXG4gICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gSFRNTCByZXByZXNlbnRhdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGlmZl9wcmV0dHlIdG1sID0gZnVuY3Rpb24gKGRpZmZzKSB7XG4gICAgICAgICAgICB2YXIgaHRtbCA9IFtdO1xuICAgICAgICAgICAgdmFyIHBhdHRlcm5fYW1wID0gLyYvZztcbiAgICAgICAgICAgIHZhciBwYXR0ZXJuX2x0ID0gLzwvZztcbiAgICAgICAgICAgIHZhciBwYXR0ZXJuX2d0ID0gLz4vZztcbiAgICAgICAgICAgIHZhciBwYXR0ZXJuX3BhcmEgPSAvXFxuL2c7XG4gICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IGRpZmZzLmxlbmd0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9wID0gZGlmZnNbeF1bMF07IC8vIE9wZXJhdGlvbiAoaW5zZXJ0LCBkZWxldGUsIGVxdWFsKVxuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gZGlmZnNbeF1bMV07IC8vIFRleHQgb2YgY2hhbmdlLlxuICAgICAgICAgICAgICAgIHZhciB0ZXh0ID0gZGF0YS5yZXBsYWNlKHBhdHRlcm5fYW1wLCAnJmFtcDsnKS5yZXBsYWNlKHBhdHRlcm5fbHQsICcmbHQ7JylcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UocGF0dGVybl9ndCwgJyZndDsnKS5yZXBsYWNlKHBhdHRlcm5fcGFyYSwgJyZwYXJhOzxicj4nKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG9wKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMSAvKiBJbnNlcnQgKi86XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sW3hdID0gJzxpbnMgc3R5bGU9XCJiYWNrZ3JvdW5kOiNlNmZmZTY7XCI+JyArIHRleHQgKyAnPC9pbnM+JztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIC0xIC8qIERlbGV0ZSAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWxbeF0gPSAnPGRlbCBzdHlsZT1cImJhY2tncm91bmQ6I2ZmZTZlNjtcIj4nICsgdGV4dCArICc8L2RlbD4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMCAvKiBFcXVhbCAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWxbeF0gPSAnPHNwYW4+JyArIHRleHQgKyAnPC9zcGFuPic7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaHRtbC5qb2luKCcnKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExvb2sgdGhyb3VnaCB0aGUgcGF0Y2hlcyBhbmQgYnJlYWsgdXAgYW55IHdoaWNoIGFyZSBsb25nZXIgdGhhbiB0aGUgbWF4aW11bVxuICAgICAgICAgKiBsaW1pdCBvZiB0aGUgbWF0Y2ggYWxnb3JpdGhtLlxuICAgICAgICAgKiBJbnRlbmRlZCB0byBiZSBjYWxsZWQgb25seSBmcm9tIHdpdGhpbiBwYXRjaF9hcHBseS5cbiAgICAgICAgICogQHBhcmFtIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLnBhdGNoX29iaj59IHBhdGNoZXMgQXJyYXkgb2YgUGF0Y2ggb2JqZWN0cy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGF0Y2hfc3BsaXRNYXggPSBmdW5jdGlvbiAocGF0Y2hlcykge1xuICAgICAgICAgICAgdmFyIHBhdGNoX3NpemUgPSB0aGlzLk1hdGNoX01heEJpdHM7XG4gICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHBhdGNoZXMubGVuZ3RoOyB4KyspIHtcbiAgICAgICAgICAgICAgICBpZiAocGF0Y2hlc1t4XS5sZW5ndGgxIDw9IHBhdGNoX3NpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBiaWdwYXRjaCA9IHBhdGNoZXNbeF07XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBiaWcgb2xkIHBhdGNoLlxuICAgICAgICAgICAgICAgIHBhdGNoZXMuc3BsaWNlKHgtLSwgMSk7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0MSA9IGJpZ3BhdGNoLnN0YXJ0MTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnQyID0gYmlncGF0Y2guc3RhcnQyO1xuICAgICAgICAgICAgICAgIHZhciBwcmVjb250ZXh0ID0gJyc7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGJpZ3BhdGNoLmRpZmZzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgb25lIG9mIHNldmVyYWwgc21hbGxlciBwYXRjaGVzLlxuICAgICAgICAgICAgICAgICAgICB2YXIgcGF0Y2ggPSBuZXcgcGF0Y2hfb2JqKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbXB0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHBhdGNoLnN0YXJ0MSA9IHN0YXJ0MSAtIHByZWNvbnRleHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBwYXRjaC5zdGFydDIgPSBzdGFydDIgLSBwcmVjb250ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZWNvbnRleHQgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRjaC5sZW5ndGgxID0gcGF0Y2gubGVuZ3RoMiA9IHByZWNvbnRleHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0Y2guZGlmZnMucHVzaChbMCAvKiBFcXVhbCAqLywgcHJlY29udGV4dF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChiaWdwYXRjaC5kaWZmcy5sZW5ndGggIT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGNoLmxlbmd0aDEgPCBwYXRjaF9zaXplIC0gdGhpcy5QYXRjaF9NYXJnaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkaWZmX3R5cGUgPSBiaWdwYXRjaC5kaWZmc1swXVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkaWZmX3RleHQgPSBiaWdwYXRjaC5kaWZmc1swXVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaWZmX3R5cGUgPT09IDEgLyogSW5zZXJ0ICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW5zZXJ0aW9ucyBhcmUgaGFybWxlc3MuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0Y2gubGVuZ3RoMiArPSBkaWZmX3RleHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0MiArPSBkaWZmX3RleHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGNoLmRpZmZzLnB1c2goYmlncGF0Y2guZGlmZnMuc2hpZnQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRpZmZfdHlwZSA9PT0gLTEgLyogRGVsZXRlICovICYmIHBhdGNoLmRpZmZzLmxlbmd0aCA9PSAxICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0Y2guZGlmZnNbMF1bMF0gPT0gMCAvKiBFcXVhbCAqLyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpZmZfdGV4dC5sZW5ndGggPiAyICogcGF0Y2hfc2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBsYXJnZSBkZWxldGlvbi4gIExldCBpdCBwYXNzIGluIG9uZSBjaHVuay5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRjaC5sZW5ndGgxICs9IGRpZmZfdGV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQxICs9IGRpZmZfdGV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRjaC5kaWZmcy5wdXNoKFtkaWZmX3R5cGUsIGRpZmZfdGV4dF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpZ3BhdGNoLmRpZmZzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEZWxldGlvbiBvciBlcXVhbGl0eS4gIE9ubHkgdGFrZSBhcyBtdWNoIGFzIHdlIGNhbiBzdG9tYWNoLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpZmZfdGV4dCA9IGRpZmZfdGV4dC5zdWJzdHJpbmcoMCwgcGF0Y2hfc2l6ZSAtIHBhdGNoLmxlbmd0aDEgLSB0aGlzLlBhdGNoX01hcmdpbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0Y2gubGVuZ3RoMSArPSBkaWZmX3RleHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0MSArPSBkaWZmX3RleHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaWZmX3R5cGUgPT09IDAgLyogRXF1YWwgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0Y2gubGVuZ3RoMiArPSBkaWZmX3RleHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDIgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGNoLmRpZmZzLnB1c2goW2RpZmZfdHlwZSwgZGlmZl90ZXh0XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpZmZfdGV4dCA9PSBiaWdwYXRjaC5kaWZmc1swXVsxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaWdwYXRjaC5kaWZmcy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmlncGF0Y2guZGlmZnNbMF1bMV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmlncGF0Y2guZGlmZnNbMF1bMV0uc3Vic3RyaW5nKGRpZmZfdGV4dC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBoZWFkIGNvbnRleHQgZm9yIHRoZSBuZXh0IHBhdGNoLlxuICAgICAgICAgICAgICAgICAgICBwcmVjb250ZXh0ID0gdGhpcy5kaWZmX3RleHQyKHBhdGNoLmRpZmZzKTtcbiAgICAgICAgICAgICAgICAgICAgcHJlY29udGV4dCA9XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVjb250ZXh0LnN1YnN0cmluZyhwcmVjb250ZXh0Lmxlbmd0aCAtIHRoaXMuUGF0Y2hfTWFyZ2luKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwZW5kIHRoZSBlbmQgY29udGV4dCBmb3IgdGhpcyBwYXRjaC5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvc3Rjb250ZXh0ID0gdGhpcy5kaWZmX3RleHQxKGJpZ3BhdGNoLmRpZmZzKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN1YnN0cmluZygwLCB0aGlzLlBhdGNoX01hcmdpbik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3N0Y29udGV4dCAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGNoLmxlbmd0aDEgKz0gcG9zdGNvbnRleHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0Y2gubGVuZ3RoMiArPSBwb3N0Y29udGV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGF0Y2guZGlmZnMubGVuZ3RoICE9PSAwICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0Y2guZGlmZnNbcGF0Y2guZGlmZnMubGVuZ3RoIC0gMV1bMF0gPT09IDAgLyogRXF1YWwgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRjaC5kaWZmc1twYXRjaC5kaWZmcy5sZW5ndGggLSAxXVsxXSArPSBwb3N0Y29udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGNoLmRpZmZzLnB1c2goWzAgLyogRXF1YWwgKi8sIHBvc3Rjb250ZXh0XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0Y2hlcy5zcGxpY2UoKyt4LCAwLCBwYXRjaCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gdHdvIHRleHRzLiAgU2ltcGxpZmllcyB0aGUgcHJvYmxlbSBieSBzdHJpcHBpbmdcbiAgICAgKiBhbnkgY29tbW9uIHByZWZpeCBvciBzdWZmaXggb2ZmIHRoZSB0ZXh0cyBiZWZvcmUgZGlmZmluZy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgT2xkIHN0cmluZyB0byBiZSBkaWZmZWQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQyIE5ldyBzdHJpbmcgdG8gYmUgZGlmZmVkLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9jaGVja2xpbmVzIE9wdGlvbmFsIHNwZWVkdXAgZmxhZy4gSWYgcHJlc2VudCBhbmQgZmFsc2UsXG4gICAgICogICAgIHRoZW4gZG9uJ3QgcnVuIGEgbGluZS1sZXZlbCBkaWZmIGZpcnN0IHRvIGlkZW50aWZ5IHRoZSBjaGFuZ2VkIGFyZWFzLlxuICAgICAqICAgICBEZWZhdWx0cyB0byB0cnVlLCB3aGljaCBkb2VzIGEgZmFzdGVyLCBzbGlnaHRseSBsZXNzIG9wdGltYWwgZGlmZi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3B0X2RlYWRsaW5lIE9wdGlvbmFsIHRpbWUgd2hlbiB0aGUgZGlmZiBzaG91bGQgYmUgY29tcGxldGVcbiAgICAgKiAgICAgYnkuICBVc2VkIGludGVybmFsbHkgZm9yIHJlY3Vyc2l2ZSBjYWxscy4gIFVzZXJzIHNob3VsZCBzZXQgRGlmZlRpbWVvdXRcbiAgICAgKiAgICAgaW5zdGVhZC5cbiAgICAgKiBAcmV0dXJuIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLkRpZmY+fSBBcnJheSBvZiBkaWZmIHR1cGxlcy5cbiAgICAgKi9cbiAgICBEaWZmTWF0Y2hQYXRjaC5wcm90b3R5cGUuZGlmZl9tYWluID0gZnVuY3Rpb24gKHRleHQxLCB0ZXh0Miwgb3B0X2NoZWNrbGluZXMsIG9wdF9kZWFkbGluZSkge1xuICAgICAgICAvLyBTZXQgYSBkZWFkbGluZSBieSB3aGljaCB0aW1lIHRoZSBkaWZmIG11c3QgYmUgY29tcGxldGUuXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0X2RlYWRsaW5lID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5EaWZmX1RpbWVvdXQgPD0gMCkge1xuICAgICAgICAgICAgICAgIG9wdF9kZWFkbGluZSA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcHRfZGVhZGxpbmUgPSAobmV3IERhdGUpLmdldFRpbWUoKSArIHRoaXMuRGlmZl9UaW1lb3V0ICogMTAwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVhZGxpbmUgPSBvcHRfZGVhZGxpbmU7XG4gICAgICAgIC8vIENoZWNrIGZvciBudWxsIGlucHV0cy5cbiAgICAgICAgaWYgKHRleHQxID09IG51bGwgfHwgdGV4dDIgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOdWxsIGlucHV0LiAoZGlmZl9tYWluKScpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGZvciBlcXVhbGl0eSAoc3BlZWR1cCkuXG4gICAgICAgIGlmICh0ZXh0MSA9PSB0ZXh0Mikge1xuICAgICAgICAgICAgaWYgKHRleHQxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtbMCAvKiBFcXVhbCAqLywgdGV4dDFdXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9wdF9jaGVja2xpbmVzID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBvcHRfY2hlY2tsaW5lcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNoZWNrbGluZXMgPSBvcHRfY2hlY2tsaW5lcztcbiAgICAgICAgLy8gVHJpbSBvZmYgY29tbW9uIHByZWZpeCAoc3BlZWR1cCkuXG4gICAgICAgIHZhciBjb21tb25sZW5ndGggPSB0aGlzLmRpZmZfY29tbW9uUHJlZml4KHRleHQxLCB0ZXh0Mik7XG4gICAgICAgIHZhciBjb21tb25wcmVmaXggPSB0ZXh0MS5zdWJzdHJpbmcoMCwgY29tbW9ubGVuZ3RoKTtcbiAgICAgICAgdGV4dDEgPSB0ZXh0MS5zdWJzdHJpbmcoY29tbW9ubGVuZ3RoKTtcbiAgICAgICAgdGV4dDIgPSB0ZXh0Mi5zdWJzdHJpbmcoY29tbW9ubGVuZ3RoKTtcbiAgICAgICAgLy8gVHJpbSBvZmYgY29tbW9uIHN1ZmZpeCAoc3BlZWR1cCkuXG4gICAgICAgIGNvbW1vbmxlbmd0aCA9IHRoaXMuZGlmZl9jb21tb25TdWZmaXgodGV4dDEsIHRleHQyKTtcbiAgICAgICAgdmFyIGNvbW1vbnN1ZmZpeCA9IHRleHQxLnN1YnN0cmluZyh0ZXh0MS5sZW5ndGggLSBjb21tb25sZW5ndGgpO1xuICAgICAgICB0ZXh0MSA9IHRleHQxLnN1YnN0cmluZygwLCB0ZXh0MS5sZW5ndGggLSBjb21tb25sZW5ndGgpO1xuICAgICAgICB0ZXh0MiA9IHRleHQyLnN1YnN0cmluZygwLCB0ZXh0Mi5sZW5ndGggLSBjb21tb25sZW5ndGgpO1xuICAgICAgICAvLyBDb21wdXRlIHRoZSBkaWZmIG9uIHRoZSBtaWRkbGUgYmxvY2suXG4gICAgICAgIHZhciBkaWZmcyA9IHRoaXMuZGlmZl9jb21wdXRlXyh0ZXh0MSwgdGV4dDIsIGNoZWNrbGluZXMsIGRlYWRsaW5lKTtcbiAgICAgICAgLy8gUmVzdG9yZSB0aGUgcHJlZml4IGFuZCBzdWZmaXguXG4gICAgICAgIGlmIChjb21tb25wcmVmaXgpIHtcbiAgICAgICAgICAgIGRpZmZzLnVuc2hpZnQoWzAgLyogRXF1YWwgKi8sIGNvbW1vbnByZWZpeF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21tb25zdWZmaXgpIHtcbiAgICAgICAgICAgIGRpZmZzLnB1c2goWzAgLyogRXF1YWwgKi8sIGNvbW1vbnN1ZmZpeF0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGlmZl9jbGVhbnVwTWVyZ2UoZGlmZnMpO1xuICAgICAgICByZXR1cm4gZGlmZnM7XG4gICAgfTtcbiAgICA7XG4gICAgLyoqXG4gICAgICogRmluZCB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiB0d28gdGV4dHMuICBBc3N1bWVzIHRoYXQgdGhlIHRleHRzIGRvIG5vdFxuICAgICAqIGhhdmUgYW55IGNvbW1vbiBwcmVmaXggb3Igc3VmZml4LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MSBPbGQgc3RyaW5nIHRvIGJlIGRpZmZlZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgTmV3IHN0cmluZyB0byBiZSBkaWZmZWQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBjaGVja2xpbmVzIFNwZWVkdXAgZmxhZy4gIElmIGZhbHNlLCB0aGVuIGRvbid0IHJ1biBhXG4gICAgICogICAgIGxpbmUtbGV2ZWwgZGlmZiBmaXJzdCB0byBpZGVudGlmeSB0aGUgY2hhbmdlZCBhcmVhcy5cbiAgICAgKiAgICAgSWYgdHJ1ZSwgdGhlbiBydW4gYSBmYXN0ZXIsIHNsaWdodGx5IGxlc3Mgb3B0aW1hbCBkaWZmLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZWFkbGluZSBUaW1lIHdoZW4gdGhlIGRpZmYgc2hvdWxkIGJlIGNvbXBsZXRlIGJ5LlxuICAgICAqIEByZXR1cm4geyFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2guRGlmZj59IEFycmF5IG9mIGRpZmYgdHVwbGVzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgRGlmZk1hdGNoUGF0Y2gucHJvdG90eXBlLmRpZmZfY29tcHV0ZV8gPSBmdW5jdGlvbiAodGV4dDEsIHRleHQyLCBjaGVja2xpbmVzLCBkZWFkbGluZSkge1xuICAgICAgICB2YXIgZGlmZnM7XG4gICAgICAgIGlmICghdGV4dDEpIHtcbiAgICAgICAgICAgIC8vIEp1c3QgYWRkIHNvbWUgdGV4dCAoc3BlZWR1cCkuXG4gICAgICAgICAgICByZXR1cm4gW1sxIC8qIEluc2VydCAqLywgdGV4dDJdXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRleHQyKSB7XG4gICAgICAgICAgICAvLyBKdXN0IGRlbGV0ZSBzb21lIHRleHQgKHNwZWVkdXApLlxuICAgICAgICAgICAgcmV0dXJuIFtbLTEgLyogRGVsZXRlICovLCB0ZXh0MV1dO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsb25ndGV4dCA9IHRleHQxLmxlbmd0aCA+IHRleHQyLmxlbmd0aCA/IHRleHQxIDogdGV4dDI7XG4gICAgICAgIHZhciBzaG9ydHRleHQgPSB0ZXh0MS5sZW5ndGggPiB0ZXh0Mi5sZW5ndGggPyB0ZXh0MiA6IHRleHQxO1xuICAgICAgICB2YXIgaSA9IGxvbmd0ZXh0LmluZGV4T2Yoc2hvcnR0ZXh0KTtcbiAgICAgICAgaWYgKGkgIT0gLTEpIHtcbiAgICAgICAgICAgIC8vIFNob3J0ZXIgdGV4dCBpcyBpbnNpZGUgdGhlIGxvbmdlciB0ZXh0IChzcGVlZHVwKS5cbiAgICAgICAgICAgIGRpZmZzID0gW1sxIC8qIEluc2VydCAqLywgbG9uZ3RleHQuc3Vic3RyaW5nKDAsIGkpXSxcbiAgICAgICAgICAgICAgICBbMCAvKiBFcXVhbCAqLywgc2hvcnR0ZXh0XSxcbiAgICAgICAgICAgICAgICBbMSAvKiBJbnNlcnQgKi8sIGxvbmd0ZXh0LnN1YnN0cmluZyhpICsgc2hvcnR0ZXh0Lmxlbmd0aCldXTtcbiAgICAgICAgICAgIC8vIFN3YXAgaW5zZXJ0aW9ucyBmb3IgZGVsZXRpb25zIGlmIGRpZmYgaXMgcmV2ZXJzZWQuXG4gICAgICAgICAgICBpZiAodGV4dDEubGVuZ3RoID4gdGV4dDIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZGlmZnNbMF1bMF0gPSBkaWZmc1syXVswXSA9IC0xIC8qIERlbGV0ZSAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkaWZmcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvcnR0ZXh0Lmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICAvLyBTaW5nbGUgY2hhcmFjdGVyIHN0cmluZy5cbiAgICAgICAgICAgIC8vIEFmdGVyIHRoZSBwcmV2aW91cyBzcGVlZHVwLCB0aGUgY2hhcmFjdGVyIGNhbid0IGJlIGFuIGVxdWFsaXR5LlxuICAgICAgICAgICAgcmV0dXJuIFtbLTEgLyogRGVsZXRlICovLCB0ZXh0MV0sIFsxIC8qIEluc2VydCAqLywgdGV4dDJdXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayB0byBzZWUgaWYgdGhlIHByb2JsZW0gY2FuIGJlIHNwbGl0IGluIHR3by5cbiAgICAgICAgdmFyIGhtID0gdGhpcy5kaWZmX2hhbGZNYXRjaF8odGV4dDEsIHRleHQyKTtcbiAgICAgICAgaWYgKGhtKSB7XG4gICAgICAgICAgICAvLyBBIGhhbGYtbWF0Y2ggd2FzIGZvdW5kLCBzb3J0IG91dCB0aGUgcmV0dXJuIGRhdGEuXG4gICAgICAgICAgICB2YXIgdGV4dDFfYSA9IGhtWzBdO1xuICAgICAgICAgICAgdmFyIHRleHQxX2IgPSBobVsxXTtcbiAgICAgICAgICAgIHZhciB0ZXh0Ml9hID0gaG1bMl07XG4gICAgICAgICAgICB2YXIgdGV4dDJfYiA9IGhtWzNdO1xuICAgICAgICAgICAgdmFyIG1pZF9jb21tb24gPSBobVs0XTtcbiAgICAgICAgICAgIC8vIFNlbmQgYm90aCBwYWlycyBvZmYgZm9yIHNlcGFyYXRlIHByb2Nlc3NpbmcuXG4gICAgICAgICAgICB2YXIgZGlmZnNfYSA9IHRoaXMuZGlmZl9tYWluKHRleHQxX2EsIHRleHQyX2EsIGNoZWNrbGluZXMsIGRlYWRsaW5lKTtcbiAgICAgICAgICAgIHZhciBkaWZmc19iID0gdGhpcy5kaWZmX21haW4odGV4dDFfYiwgdGV4dDJfYiwgY2hlY2tsaW5lcywgZGVhZGxpbmUpO1xuICAgICAgICAgICAgLy8gTWVyZ2UgdGhlIHJlc3VsdHMuXG4gICAgICAgICAgICByZXR1cm4gZGlmZnNfYS5jb25jYXQoW1swIC8qIEVxdWFsICovLCBtaWRfY29tbW9uXV0sIGRpZmZzX2IpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGVja2xpbmVzICYmIHRleHQxLmxlbmd0aCA+IDEwMCAmJiB0ZXh0Mi5sZW5ndGggPiAxMDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRpZmZfbGluZU1vZGVfKHRleHQxLCB0ZXh0MiwgZGVhZGxpbmUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmRpZmZfYmlzZWN0Xyh0ZXh0MSwgdGV4dDIsIGRlYWRsaW5lKTtcbiAgICB9O1xuICAgIDtcbiAgICAvKipcbiAgICAgKiBEbyBhIHF1aWNrIGxpbmUtbGV2ZWwgZGlmZiBvbiBib3RoIHN0cmluZ3MsIHRoZW4gcmVkaWZmIHRoZSBwYXJ0cyBmb3JcbiAgICAgKiBncmVhdGVyIGFjY3VyYWN5LlxuICAgICAqIFRoaXMgc3BlZWR1cCBjYW4gcHJvZHVjZSBub24tbWluaW1hbCBkaWZmcy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgT2xkIHN0cmluZyB0byBiZSBkaWZmZWQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQyIE5ldyBzdHJpbmcgdG8gYmUgZGlmZmVkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZWFkbGluZSBUaW1lIHdoZW4gdGhlIGRpZmYgc2hvdWxkIGJlIGNvbXBsZXRlIGJ5LlxuICAgICAqIEByZXR1cm4geyFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2guRGlmZj59IEFycmF5IG9mIGRpZmYgdHVwbGVzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgRGlmZk1hdGNoUGF0Y2gucHJvdG90eXBlLmRpZmZfbGluZU1vZGVfID0gZnVuY3Rpb24gKHRleHQxLCB0ZXh0MiwgZGVhZGxpbmUpIHtcbiAgICAgICAgLy8gU2NhbiB0aGUgdGV4dCBvbiBhIGxpbmUtYnktbGluZSBiYXNpcyBmaXJzdC5cbiAgICAgICAgdmFyIGEgPSB0aGlzLmRpZmZfbGluZXNUb0NoYXJzXyh0ZXh0MSwgdGV4dDIpO1xuICAgICAgICB0ZXh0MSA9IGEuY2hhcnMxO1xuICAgICAgICB0ZXh0MiA9IGEuY2hhcnMyO1xuICAgICAgICB2YXIgbGluZWFycmF5ID0gYS5saW5lQXJyYXk7XG4gICAgICAgIHZhciBkaWZmcyA9IHRoaXMuZGlmZl9tYWluKHRleHQxLCB0ZXh0MiwgZmFsc2UsIGRlYWRsaW5lKTtcbiAgICAgICAgLy8gQ29udmVydCB0aGUgZGlmZiBiYWNrIHRvIG9yaWdpbmFsIHRleHQuXG4gICAgICAgIHRoaXMuZGlmZl9jaGFyc1RvTGluZXNfKGRpZmZzLCBsaW5lYXJyYXkpO1xuICAgICAgICAvLyBFbGltaW5hdGUgZnJlYWsgbWF0Y2hlcyAoZS5nLiBibGFuayBsaW5lcylcbiAgICAgICAgdGhpcy5kaWZmX2NsZWFudXBTZW1hbnRpYyhkaWZmcyk7XG4gICAgICAgIC8vIFJlZGlmZiBhbnkgcmVwbGFjZW1lbnQgYmxvY2tzLCB0aGlzIHRpbWUgY2hhcmFjdGVyLWJ5LWNoYXJhY3Rlci5cbiAgICAgICAgLy8gQWRkIGEgZHVtbXkgZW50cnkgYXQgdGhlIGVuZC5cbiAgICAgICAgZGlmZnMucHVzaChbMCAvKiBFcXVhbCAqLywgJyddKTtcbiAgICAgICAgdmFyIHBvaW50ZXIgPSAwO1xuICAgICAgICB2YXIgY291bnRfZGVsZXRlID0gMDtcbiAgICAgICAgdmFyIGNvdW50X2luc2VydCA9IDA7XG4gICAgICAgIHZhciB0ZXh0X2RlbGV0ZSA9ICcnO1xuICAgICAgICB2YXIgdGV4dF9pbnNlcnQgPSAnJztcbiAgICAgICAgd2hpbGUgKHBvaW50ZXIgPCBkaWZmcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoZGlmZnNbcG9pbnRlcl1bMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDEgLyogSW5zZXJ0ICovOlxuICAgICAgICAgICAgICAgICAgICBjb3VudF9pbnNlcnQrKztcbiAgICAgICAgICAgICAgICAgICAgdGV4dF9pbnNlcnQgKz0gZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLTEgLyogRGVsZXRlICovOlxuICAgICAgICAgICAgICAgICAgICBjb3VudF9kZWxldGUrKztcbiAgICAgICAgICAgICAgICAgICAgdGV4dF9kZWxldGUgKz0gZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMCAvKiBFcXVhbCAqLzpcbiAgICAgICAgICAgICAgICAgICAgLy8gVXBvbiByZWFjaGluZyBhbiBlcXVhbGl0eSwgY2hlY2sgZm9yIHByaW9yIHJlZHVuZGFuY2llcy5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50X2RlbGV0ZSA+PSAxICYmIGNvdW50X2luc2VydCA+PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEZWxldGUgdGhlIG9mZmVuZGluZyByZWNvcmRzIGFuZCBhZGQgdGhlIG1lcmdlZCBvbmVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIgLSBjb3VudF9kZWxldGUgLSBjb3VudF9pbnNlcnQsIGNvdW50X2RlbGV0ZSArIGNvdW50X2luc2VydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVyID0gcG9pbnRlciAtIGNvdW50X2RlbGV0ZSAtIGNvdW50X2luc2VydDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiID0gdGhpcy5kaWZmX21haW4odGV4dF9kZWxldGUsIHRleHRfaW5zZXJ0LCBmYWxzZSwgZGVhZGxpbmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IGIubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciwgMCwgYltqXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVyID0gcG9pbnRlciArIGIubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvdW50X2luc2VydCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50X2RlbGV0ZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRleHRfZGVsZXRlID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIHRleHRfaW5zZXJ0ID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9pbnRlcisrO1xuICAgICAgICB9XG4gICAgICAgIGRpZmZzLnBvcCgpOyAvLyBSZW1vdmUgdGhlIGR1bW15IGVudHJ5IGF0IHRoZSBlbmQuXG4gICAgICAgIHJldHVybiBkaWZmcztcbiAgICB9O1xuICAgIDtcbiAgICAvKipcbiAgICAgKiBGaW5kIHRoZSAnbWlkZGxlIHNuYWtlJyBvZiBhIGRpZmYsIHNwbGl0IHRoZSBwcm9ibGVtIGluIHR3b1xuICAgICAqIGFuZCByZXR1cm4gdGhlIHJlY3Vyc2l2ZWx5IGNvbnN0cnVjdGVkIGRpZmYuXG4gICAgICogU2VlIE15ZXJzIDE5ODYgcGFwZXI6IEFuIE8oTkQpIERpZmZlcmVuY2UgQWxnb3JpdGhtIGFuZCBJdHMgY29uc3RpYXRpb25zLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MSBPbGQgc3RyaW5nIHRvIGJlIGRpZmZlZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgTmV3IHN0cmluZyB0byBiZSBkaWZmZWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlYWRsaW5lIFRpbWUgYXQgd2hpY2ggdG8gYmFpbCBpZiBub3QgeWV0IGNvbXBsZXRlLlxuICAgICAqIEByZXR1cm4geyFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2guRGlmZj59IEFycmF5IG9mIGRpZmYgdHVwbGVzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgRGlmZk1hdGNoUGF0Y2gucHJvdG90eXBlLmRpZmZfYmlzZWN0XyA9IGZ1bmN0aW9uICh0ZXh0MSwgdGV4dDIsIGRlYWRsaW5lKSB7XG4gICAgICAgIC8vIENhY2hlIHRoZSB0ZXh0IGxlbmd0aHMgdG8gcHJldmVudCBtdWx0aXBsZSBjYWxscy5cbiAgICAgICAgdmFyIHRleHQxX2xlbmd0aCA9IHRleHQxLmxlbmd0aDtcbiAgICAgICAgdmFyIHRleHQyX2xlbmd0aCA9IHRleHQyLmxlbmd0aDtcbiAgICAgICAgdmFyIG1heF9kID0gTWF0aC5jZWlsKCh0ZXh0MV9sZW5ndGggKyB0ZXh0Ml9sZW5ndGgpIC8gMik7XG4gICAgICAgIHZhciB2X29mZnNldCA9IG1heF9kO1xuICAgICAgICB2YXIgdl9sZW5ndGggPSAyICogbWF4X2Q7XG4gICAgICAgIHZhciB2MSA9IG5ldyBBcnJheSh2X2xlbmd0aCk7XG4gICAgICAgIHZhciB2MiA9IG5ldyBBcnJheSh2X2xlbmd0aCk7XG4gICAgICAgIC8vIFNldHRpbmcgYWxsIGVsZW1lbnRzIHRvIC0xIGlzIGZhc3RlciBpbiBDaHJvbWUgJiBGaXJlZm94IHRoYW4gbWl4aW5nXG4gICAgICAgIC8vIGludGVnZXJzIGFuZCB1bmRlZmluZWQuXG4gICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgdl9sZW5ndGg7IHgrKykge1xuICAgICAgICAgICAgdjFbeF0gPSAtMTtcbiAgICAgICAgICAgIHYyW3hdID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgdjFbdl9vZmZzZXQgKyAxXSA9IDA7XG4gICAgICAgIHYyW3Zfb2Zmc2V0ICsgMV0gPSAwO1xuICAgICAgICB2YXIgZGVsdGEgPSB0ZXh0MV9sZW5ndGggLSB0ZXh0Ml9sZW5ndGg7XG4gICAgICAgIC8vIElmIHRoZSB0b3RhbCBudW1iZXIgb2YgY2hhcmFjdGVycyBpcyBvZGQsIHRoZW4gdGhlIGZyb250IHBhdGggd2lsbCBjb2xsaWRlXG4gICAgICAgIC8vIHdpdGggdGhlIHJldmVyc2UgcGF0aC5cbiAgICAgICAgdmFyIGZyb250ID0gKGRlbHRhICUgMiAhPSAwKTtcbiAgICAgICAgLy8gT2Zmc2V0cyBmb3Igc3RhcnQgYW5kIGVuZCBvZiBrIGxvb3AuXG4gICAgICAgIC8vIFByZXZlbnRzIG1hcHBpbmcgb2Ygc3BhY2UgYmV5b25kIHRoZSBncmlkLlxuICAgICAgICB2YXIgazFzdGFydCA9IDA7XG4gICAgICAgIHZhciBrMWVuZCA9IDA7XG4gICAgICAgIHZhciBrMnN0YXJ0ID0gMDtcbiAgICAgICAgdmFyIGsyZW5kID0gMDtcbiAgICAgICAgZm9yICh2YXIgZCA9IDA7IGQgPCBtYXhfZDsgZCsrKSB7XG4gICAgICAgICAgICAvLyBCYWlsIG91dCBpZiBkZWFkbGluZSBpcyByZWFjaGVkLlxuICAgICAgICAgICAgaWYgKChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgPiBkZWFkbGluZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2FsayB0aGUgZnJvbnQgcGF0aCBvbmUgc3RlcC5cbiAgICAgICAgICAgIGZvciAodmFyIGsxID0gLWQgKyBrMXN0YXJ0OyBrMSA8PSBkIC0gazFlbmQ7IGsxICs9IDIpIHtcbiAgICAgICAgICAgICAgICB2YXIgazFfb2Zmc2V0ID0gdl9vZmZzZXQgKyBrMTtcbiAgICAgICAgICAgICAgICB2YXIgeDEgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgaWYgKGsxID09IC1kIHx8IChrMSAhPSBkICYmIHYxW2sxX29mZnNldCAtIDFdIDwgdjFbazFfb2Zmc2V0ICsgMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHgxID0gdjFbazFfb2Zmc2V0ICsgMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB4MSA9IHYxW2sxX29mZnNldCAtIDFdICsgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHkxID0geDEgLSBrMTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoeDEgPCB0ZXh0MV9sZW5ndGggJiYgeTEgPCB0ZXh0Ml9sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgdGV4dDEuY2hhckF0KHgxKSA9PSB0ZXh0Mi5jaGFyQXQoeTEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHgxKys7XG4gICAgICAgICAgICAgICAgICAgIHkxKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHYxW2sxX29mZnNldF0gPSB4MTtcbiAgICAgICAgICAgICAgICBpZiAoeDEgPiB0ZXh0MV9sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmFuIG9mZiB0aGUgcmlnaHQgb2YgdGhlIGdyYXBoLlxuICAgICAgICAgICAgICAgICAgICBrMWVuZCArPSAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh5MSA+IHRleHQyX2xlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBSYW4gb2ZmIHRoZSBib3R0b20gb2YgdGhlIGdyYXBoLlxuICAgICAgICAgICAgICAgICAgICBrMXN0YXJ0ICs9IDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZyb250KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrMl9vZmZzZXQgPSB2X29mZnNldCArIGRlbHRhIC0gazE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrMl9vZmZzZXQgPj0gMCAmJiBrMl9vZmZzZXQgPCB2X2xlbmd0aCAmJiB2MltrMl9vZmZzZXRdICE9IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNaXJyb3IgeDIgb250byB0b3AtbGVmdCBjb29yZGluYXRlIHN5c3RlbS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4MiA9IHRleHQxX2xlbmd0aCAtIHYyW2syX29mZnNldF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeDEgPj0geDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPdmVybGFwIGRldGVjdGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRpZmZfYmlzZWN0U3BsaXRfKHRleHQxLCB0ZXh0MiwgeDEsIHkxLCBkZWFkbGluZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXYWxrIHRoZSByZXZlcnNlIHBhdGggb25lIHN0ZXAuXG4gICAgICAgICAgICBmb3IgKHZhciBrMiA9IC1kICsgazJzdGFydDsgazIgPD0gZCAtIGsyZW5kOyBrMiArPSAyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGsyX29mZnNldCA9IHZfb2Zmc2V0ICsgazI7XG4gICAgICAgICAgICAgICAgdmFyIHgyID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIGlmIChrMiA9PSAtZCB8fCAoazIgIT0gZCAmJiB2MltrMl9vZmZzZXQgLSAxXSA8IHYyW2syX29mZnNldCArIDFdKSkge1xuICAgICAgICAgICAgICAgICAgICB4MiA9IHYyW2syX29mZnNldCArIDFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgeDIgPSB2MltrMl9vZmZzZXQgLSAxXSArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB5MiA9IHgyIC0gazI7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHgyIDwgdGV4dDFfbGVuZ3RoICYmIHkyIDwgdGV4dDJfbGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAgIHRleHQxLmNoYXJBdCh0ZXh0MV9sZW5ndGggLSB4MiAtIDEpID09XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0Mi5jaGFyQXQodGV4dDJfbGVuZ3RoIC0geTIgLSAxKSkge1xuICAgICAgICAgICAgICAgICAgICB4MisrO1xuICAgICAgICAgICAgICAgICAgICB5MisrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2MltrMl9vZmZzZXRdID0geDI7XG4gICAgICAgICAgICAgICAgaWYgKHgyID4gdGV4dDFfbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJhbiBvZmYgdGhlIGxlZnQgb2YgdGhlIGdyYXBoLlxuICAgICAgICAgICAgICAgICAgICBrMmVuZCArPSAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh5MiA+IHRleHQyX2xlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBSYW4gb2ZmIHRoZSB0b3Agb2YgdGhlIGdyYXBoLlxuICAgICAgICAgICAgICAgICAgICBrMnN0YXJ0ICs9IDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFmcm9udCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgazFfb2Zmc2V0ID0gdl9vZmZzZXQgKyBkZWx0YSAtIGsyO1xuICAgICAgICAgICAgICAgICAgICBpZiAoazFfb2Zmc2V0ID49IDAgJiYgazFfb2Zmc2V0IDwgdl9sZW5ndGggJiYgdjFbazFfb2Zmc2V0XSAhPSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHgxID0gdjFbazFfb2Zmc2V0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB5MSA9IHZfb2Zmc2V0ICsgeDEgLSBrMV9vZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNaXJyb3IgeDIgb250byB0b3AtbGVmdCBjb29yZGluYXRlIHN5c3RlbS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHgyID0gdGV4dDFfbGVuZ3RoIC0geDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeDEgPj0geDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPdmVybGFwIGRldGVjdGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRpZmZfYmlzZWN0U3BsaXRfKHRleHQxLCB0ZXh0MiwgeDEsIHkxLCBkZWFkbGluZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGlmZiB0b29rIHRvbyBsb25nIGFuZCBoaXQgdGhlIGRlYWRsaW5lIG9yXG4gICAgICAgIC8vIG51bWJlciBvZiBkaWZmcyBlcXVhbHMgbnVtYmVyIG9mIGNoYXJhY3RlcnMsIG5vIGNvbW1vbmFsaXR5IGF0IGFsbC5cbiAgICAgICAgcmV0dXJuIFtbLTEgLyogRGVsZXRlICovLCB0ZXh0MV0sIFsxIC8qIEluc2VydCAqLywgdGV4dDJdXTtcbiAgICB9O1xuICAgIDtcbiAgICAvKipcbiAgICAgKiBHaXZlbiB0aGUgbG9jYXRpb24gb2YgdGhlICdtaWRkbGUgc25ha2UnLCBzcGxpdCB0aGUgZGlmZiBpbiB0d28gcGFydHNcbiAgICAgKiBhbmQgcmVjdXJzZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgT2xkIHN0cmluZyB0byBiZSBkaWZmZWQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQyIE5ldyBzdHJpbmcgdG8gYmUgZGlmZmVkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IEluZGV4IG9mIHNwbGl0IHBvaW50IGluIHRleHQxLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IEluZGV4IG9mIHNwbGl0IHBvaW50IGluIHRleHQyLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZWFkbGluZSBUaW1lIGF0IHdoaWNoIHRvIGJhaWwgaWYgbm90IHlldCBjb21wbGV0ZS5cbiAgICAgKiBAcmV0dXJuIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLkRpZmY+fSBBcnJheSBvZiBkaWZmIHR1cGxlcy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIERpZmZNYXRjaFBhdGNoLnByb3RvdHlwZS5kaWZmX2Jpc2VjdFNwbGl0XyA9IGZ1bmN0aW9uICh0ZXh0MSwgdGV4dDIsIHgsIHksIGRlYWRsaW5lKSB7XG4gICAgICAgIHZhciB0ZXh0MWEgPSB0ZXh0MS5zdWJzdHJpbmcoMCwgeCk7XG4gICAgICAgIHZhciB0ZXh0MmEgPSB0ZXh0Mi5zdWJzdHJpbmcoMCwgeSk7XG4gICAgICAgIHZhciB0ZXh0MWIgPSB0ZXh0MS5zdWJzdHJpbmcoeCk7XG4gICAgICAgIHZhciB0ZXh0MmIgPSB0ZXh0Mi5zdWJzdHJpbmcoeSk7XG4gICAgICAgIC8vIENvbXB1dGUgYm90aCBkaWZmcyBzZXJpYWxseS5cbiAgICAgICAgdmFyIGRpZmZzID0gdGhpcy5kaWZmX21haW4odGV4dDFhLCB0ZXh0MmEsIGZhbHNlLCBkZWFkbGluZSk7XG4gICAgICAgIHZhciBkaWZmc2IgPSB0aGlzLmRpZmZfbWFpbih0ZXh0MWIsIHRleHQyYiwgZmFsc2UsIGRlYWRsaW5lKTtcbiAgICAgICAgcmV0dXJuIGRpZmZzLmNvbmNhdChkaWZmc2IpO1xuICAgIH07XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFNwbGl0IHR3byB0ZXh0cyBpbnRvIGFuIGFycmF5IG9mIHN0cmluZ3MuICBSZWR1Y2UgdGhlIHRleHRzIHRvIGEgc3RyaW5nIG9mXG4gICAgICogaGFzaGVzIHdoZXJlIGVhY2ggVW5pY29kZSBjaGFyYWN0ZXIgcmVwcmVzZW50cyBvbmUgbGluZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgRmlyc3Qgc3RyaW5nLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MiBTZWNvbmQgc3RyaW5nLlxuICAgICAqIEByZXR1cm4ge3tjaGFyczE6IHN0cmluZywgY2hhcnMyOiBzdHJpbmcsIGxpbmVBcnJheTogIUFycmF5LjxzdHJpbmc+fX1cbiAgICAgKiAgICAgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGVuY29kZWQgdGV4dDEsIHRoZSBlbmNvZGVkIHRleHQyIGFuZFxuICAgICAqICAgICB0aGUgYXJyYXkgb2YgdW5pcXVlIHN0cmluZ3MuXG4gICAgICogICAgIFRoZSB6ZXJvdGggZWxlbWVudCBvZiB0aGUgYXJyYXkgb2YgdW5pcXVlIHN0cmluZ3MgaXMgaW50ZW50aW9uYWxseSBibGFuay5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIERpZmZNYXRjaFBhdGNoLnByb3RvdHlwZS5kaWZmX2xpbmVzVG9DaGFyc18gPSBmdW5jdGlvbiAodGV4dDEsIHRleHQyKSB7XG4gICAgICAgIHZhciBsaW5lQXJyYXkgPSBbXTsgLy8gZS5nLiBsaW5lQXJyYXlbNF0gPT0gJ0hlbGxvXFxuJ1xuICAgICAgICB2YXIgbGluZUhhc2ggPSB7fTsgLy8gZS5nLiBsaW5lSGFzaFsnSGVsbG9cXG4nXSA9PSA0XG4gICAgICAgIC8vICdcXHgwMCcgaXMgYSB2YWxpZCBjaGFyYWN0ZXIsIGJ1dCBjb25zdGlvdXMgZGVidWdnZXJzIGRvbid0IGxpa2UgaXQuXG4gICAgICAgIC8vIFNvIHdlJ2xsIGluc2VydCBhIGp1bmsgZW50cnkgdG8gYXZvaWQgZ2VuZXJhdGluZyBhIG51bGwgY2hhcmFjdGVyLlxuICAgICAgICBsaW5lQXJyYXlbMF0gPSAnJztcbiAgICAgICAgdmFyIGNoYXJzMSA9IHRoaXMuZGlmZl9saW5lc1RvQ2hhcnNNdW5nZV8odGV4dDEsIGxpbmVBcnJheSwgbGluZUhhc2gpO1xuICAgICAgICB2YXIgY2hhcnMyID0gdGhpcy5kaWZmX2xpbmVzVG9DaGFyc011bmdlXyh0ZXh0MiwgbGluZUFycmF5LCBsaW5lSGFzaCk7XG4gICAgICAgIHJldHVybiB7IGNoYXJzMTogY2hhcnMxLCBjaGFyczI6IGNoYXJzMiwgbGluZUFycmF5OiBsaW5lQXJyYXkgfTtcbiAgICB9O1xuICAgIDtcbiAgICAvKipcbiAgICAgKiBTcGxpdCBhIHRleHQgaW50byBhbiBhcnJheSBvZiBzdHJpbmdzLiAgUmVkdWNlIHRoZSB0ZXh0cyB0byBhIHN0cmluZyBvZlxuICAgICAqIGhhc2hlcyB3aGVyZSBlYWNoIFVuaWNvZGUgY2hhcmFjdGVyIHJlcHJlc2VudHMgb25lIGxpbmUuXG4gICAgICogTW9kaWZpZXMgbGluZWFycmF5IGFuZCBsaW5laGFzaCB0aHJvdWdoIGJlaW5nIGEgY2xvc3VyZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBTdHJpbmcgdG8gZW5jb2RlLlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gRW5jb2RlZCBzdHJpbmcuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBEaWZmTWF0Y2hQYXRjaC5wcm90b3R5cGUuZGlmZl9saW5lc1RvQ2hhcnNNdW5nZV8gPSBmdW5jdGlvbiAodGV4dCwgbGluZUFycmF5LCBsaW5lSGFzaCkge1xuICAgICAgICB2YXIgY2hhcnMgPSAnJztcbiAgICAgICAgLy8gV2FsayB0aGUgdGV4dCwgcHVsbGluZyBvdXQgYSBzdWJzdHJpbmcgZm9yIGVhY2ggbGluZS5cbiAgICAgICAgLy8gdGV4dC5zcGxpdCgnXFxuJykgd291bGQgd291bGQgdGVtcG9yYXJpbHkgZG91YmxlIG91ciBtZW1vcnkgZm9vdHByaW50LlxuICAgICAgICAvLyBNb2RpZnlpbmcgdGV4dCB3b3VsZCBjcmVhdGUgbWFueSBsYXJnZSBzdHJpbmdzIHRvIGdhcmJhZ2UgY29sbGVjdC5cbiAgICAgICAgdmFyIGxpbmVTdGFydCA9IDA7XG4gICAgICAgIHZhciBsaW5lRW5kID0gLTE7XG4gICAgICAgIC8vIEtlZXBpbmcgb3VyIG93biBsZW5ndGggY29uc3RpYWJsZSBpcyBmYXN0ZXIgdGhhbiBsb29raW5nIGl0IHVwLlxuICAgICAgICB2YXIgbGluZUFycmF5TGVuZ3RoID0gbGluZUFycmF5Lmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGxpbmVFbmQgPCB0ZXh0Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIGxpbmVFbmQgPSB0ZXh0LmluZGV4T2YoJ1xcbicsIGxpbmVTdGFydCk7XG4gICAgICAgICAgICBpZiAobGluZUVuZCA9PSAtMSkge1xuICAgICAgICAgICAgICAgIGxpbmVFbmQgPSB0ZXh0Lmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbGluZSA9IHRleHQuc3Vic3RyaW5nKGxpbmVTdGFydCwgbGluZUVuZCArIDEpO1xuICAgICAgICAgICAgbGluZVN0YXJ0ID0gbGluZUVuZCArIDE7XG4gICAgICAgICAgICBpZiAobGluZUhhc2guaGFzT3duUHJvcGVydHkgPyBsaW5lSGFzaC5oYXNPd25Qcm9wZXJ0eShsaW5lKSA6XG4gICAgICAgICAgICAgICAgKGxpbmVIYXNoW2xpbmVdICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICAgICAgY2hhcnMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShsaW5lSGFzaFtsaW5lXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaGFycyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGxpbmVBcnJheUxlbmd0aCk7XG4gICAgICAgICAgICAgICAgbGluZUhhc2hbbGluZV0gPSBsaW5lQXJyYXlMZW5ndGg7XG4gICAgICAgICAgICAgICAgbGluZUFycmF5W2xpbmVBcnJheUxlbmd0aCsrXSA9IGxpbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoYXJzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVoeWRyYXRlIHRoZSB0ZXh0IGluIGEgZGlmZiBmcm9tIGEgc3RyaW5nIG9mIGxpbmUgaGFzaGVzIHRvIHJlYWwgbGluZXMgb2ZcbiAgICAgKiB0ZXh0LlxuICAgICAqIEBwYXJhbSB7IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5EaWZmPn0gZGlmZnMgQXJyYXkgb2YgZGlmZiB0dXBsZXMuXG4gICAgICogQHBhcmFtIHshQXJyYXkuPHN0cmluZz59IGxpbmVBcnJheSBBcnJheSBvZiB1bmlxdWUgc3RyaW5ncy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIERpZmZNYXRjaFBhdGNoLnByb3RvdHlwZS5kaWZmX2NoYXJzVG9MaW5lc18gPSBmdW5jdGlvbiAoZGlmZnMsIGxpbmVBcnJheSkge1xuICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IGRpZmZzLmxlbmd0aDsgeCsrKSB7XG4gICAgICAgICAgICB2YXIgY2hhcnMgPSBkaWZmc1t4XVsxXTtcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGNoYXJzLmxlbmd0aDsgeSsrKSB7XG4gICAgICAgICAgICAgICAgdGV4dFt5XSA9IGxpbmVBcnJheVtjaGFycy5jaGFyQ29kZUF0KHkpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpZmZzW3hdWzFdID0gdGV4dC5qb2luKCcnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgO1xuICAgIC8qKlxuICAgICAqIERldGVybWluZSB0aGUgY29tbW9uIHByZWZpeCBvZiB0d28gc3RyaW5ncy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgRmlyc3Qgc3RyaW5nLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MiBTZWNvbmQgc3RyaW5nLlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIGNvbW1vbiB0byB0aGUgc3RhcnQgb2YgZWFjaFxuICAgICAqICAgICBzdHJpbmcuXG4gICAgICovXG4gICAgRGlmZk1hdGNoUGF0Y2gucHJvdG90eXBlLmRpZmZfY29tbW9uUHJlZml4ID0gZnVuY3Rpb24gKHRleHQxLCB0ZXh0Mikge1xuICAgICAgICAvLyBRdWljayBjaGVjayBmb3IgY29tbW9uIG51bGwgY2FzZXMuXG4gICAgICAgIGlmICghdGV4dDEgfHwgIXRleHQyIHx8IHRleHQxLmNoYXJBdCgwKSAhPSB0ZXh0Mi5jaGFyQXQoMCkpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJpbmFyeSBzZWFyY2guXG4gICAgICAgIC8vIFBlcmZvcm1hbmNlIGFuYWx5c2lzOiBodHRwOi8vbmVpbC5mcmFzZXIubmFtZS9uZXdzLzIwMDcvMTAvMDkvXG4gICAgICAgIHZhciBwb2ludGVybWluID0gMDtcbiAgICAgICAgdmFyIHBvaW50ZXJtYXggPSBNYXRoLm1pbih0ZXh0MS5sZW5ndGgsIHRleHQyLmxlbmd0aCk7XG4gICAgICAgIHZhciBwb2ludGVybWlkID0gcG9pbnRlcm1heDtcbiAgICAgICAgdmFyIHBvaW50ZXJzdGFydCA9IDA7XG4gICAgICAgIHdoaWxlIChwb2ludGVybWluIDwgcG9pbnRlcm1pZCkge1xuICAgICAgICAgICAgaWYgKHRleHQxLnN1YnN0cmluZyhwb2ludGVyc3RhcnQsIHBvaW50ZXJtaWQpID09XG4gICAgICAgICAgICAgICAgdGV4dDIuc3Vic3RyaW5nKHBvaW50ZXJzdGFydCwgcG9pbnRlcm1pZCkpIHtcbiAgICAgICAgICAgICAgICBwb2ludGVybWluID0gcG9pbnRlcm1pZDtcbiAgICAgICAgICAgICAgICBwb2ludGVyc3RhcnQgPSBwb2ludGVybWluO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcG9pbnRlcm1heCA9IHBvaW50ZXJtaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb2ludGVybWlkID0gTWF0aC5mbG9vcigocG9pbnRlcm1heCAtIHBvaW50ZXJtaW4pIC8gMiArIHBvaW50ZXJtaW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb2ludGVybWlkO1xuICAgIH07XG4gICAgO1xuICAgIC8qKlxuICAgICAqIERldGVybWluZSB0aGUgY29tbW9uIHN1ZmZpeCBvZiB0d28gc3RyaW5ncy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgRmlyc3Qgc3RyaW5nLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MiBTZWNvbmQgc3RyaW5nLlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIGNvbW1vbiB0byB0aGUgZW5kIG9mIGVhY2ggc3RyaW5nLlxuICAgICAqL1xuICAgIERpZmZNYXRjaFBhdGNoLnByb3RvdHlwZS5kaWZmX2NvbW1vblN1ZmZpeCA9IGZ1bmN0aW9uICh0ZXh0MSwgdGV4dDIpIHtcbiAgICAgICAgLy8gUXVpY2sgY2hlY2sgZm9yIGNvbW1vbiBudWxsIGNhc2VzLlxuICAgICAgICBpZiAoIXRleHQxIHx8ICF0ZXh0MiB8fFxuICAgICAgICAgICAgdGV4dDEuY2hhckF0KHRleHQxLmxlbmd0aCAtIDEpICE9IHRleHQyLmNoYXJBdCh0ZXh0Mi5sZW5ndGggLSAxKSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQmluYXJ5IHNlYXJjaC5cbiAgICAgICAgLy8gUGVyZm9ybWFuY2UgYW5hbHlzaXM6IGh0dHA6Ly9uZWlsLmZyYXNlci5uYW1lL25ld3MvMjAwNy8xMC8wOS9cbiAgICAgICAgdmFyIHBvaW50ZXJtaW4gPSAwO1xuICAgICAgICB2YXIgcG9pbnRlcm1heCA9IE1hdGgubWluKHRleHQxLmxlbmd0aCwgdGV4dDIubGVuZ3RoKTtcbiAgICAgICAgdmFyIHBvaW50ZXJtaWQgPSBwb2ludGVybWF4O1xuICAgICAgICB2YXIgcG9pbnRlcmVuZCA9IDA7XG4gICAgICAgIHdoaWxlIChwb2ludGVybWluIDwgcG9pbnRlcm1pZCkge1xuICAgICAgICAgICAgaWYgKHRleHQxLnN1YnN0cmluZyh0ZXh0MS5sZW5ndGggLSBwb2ludGVybWlkLCB0ZXh0MS5sZW5ndGggLSBwb2ludGVyZW5kKSA9PVxuICAgICAgICAgICAgICAgIHRleHQyLnN1YnN0cmluZyh0ZXh0Mi5sZW5ndGggLSBwb2ludGVybWlkLCB0ZXh0Mi5sZW5ndGggLSBwb2ludGVyZW5kKSkge1xuICAgICAgICAgICAgICAgIHBvaW50ZXJtaW4gPSBwb2ludGVybWlkO1xuICAgICAgICAgICAgICAgIHBvaW50ZXJlbmQgPSBwb2ludGVybWluO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcG9pbnRlcm1heCA9IHBvaW50ZXJtaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb2ludGVybWlkID0gTWF0aC5mbG9vcigocG9pbnRlcm1heCAtIHBvaW50ZXJtaW4pIC8gMiArIHBvaW50ZXJtaW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb2ludGVybWlkO1xuICAgIH07XG4gICAgO1xuICAgIC8qKlxuICAgICAqIERldGVybWluZSBpZiB0aGUgc3VmZml4IG9mIG9uZSBzdHJpbmcgaXMgdGhlIHByZWZpeCBvZiBhbm90aGVyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MSBGaXJzdCBzdHJpbmcuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQyIFNlY29uZCBzdHJpbmcuXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgY29tbW9uIHRvIHRoZSBlbmQgb2YgdGhlIGZpcnN0XG4gICAgICogICAgIHN0cmluZyBhbmQgdGhlIHN0YXJ0IG9mIHRoZSBzZWNvbmQgc3RyaW5nLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgRGlmZk1hdGNoUGF0Y2gucHJvdG90eXBlLmRpZmZfY29tbW9uT3ZlcmxhcF8gPSBmdW5jdGlvbiAodGV4dDEsIHRleHQyKSB7XG4gICAgICAgIC8vIENhY2hlIHRoZSB0ZXh0IGxlbmd0aHMgdG8gcHJldmVudCBtdWx0aXBsZSBjYWxscy5cbiAgICAgICAgdmFyIHRleHQxX2xlbmd0aCA9IHRleHQxLmxlbmd0aDtcbiAgICAgICAgdmFyIHRleHQyX2xlbmd0aCA9IHRleHQyLmxlbmd0aDtcbiAgICAgICAgLy8gRWxpbWluYXRlIHRoZSBudWxsIGNhc2UuXG4gICAgICAgIGlmICh0ZXh0MV9sZW5ndGggPT0gMCB8fCB0ZXh0Ml9sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVHJ1bmNhdGUgdGhlIGxvbmdlciBzdHJpbmcuXG4gICAgICAgIGlmICh0ZXh0MV9sZW5ndGggPiB0ZXh0Ml9sZW5ndGgpIHtcbiAgICAgICAgICAgIHRleHQxID0gdGV4dDEuc3Vic3RyaW5nKHRleHQxX2xlbmd0aCAtIHRleHQyX2xlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGV4dDFfbGVuZ3RoIDwgdGV4dDJfbGVuZ3RoKSB7XG4gICAgICAgICAgICB0ZXh0MiA9IHRleHQyLnN1YnN0cmluZygwLCB0ZXh0MV9sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0ZXh0X2xlbmd0aCA9IE1hdGgubWluKHRleHQxX2xlbmd0aCwgdGV4dDJfbGVuZ3RoKTtcbiAgICAgICAgLy8gUXVpY2sgY2hlY2sgZm9yIHRoZSB3b3JzdCBjYXNlLlxuICAgICAgICBpZiAodGV4dDEgPT0gdGV4dDIpIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0X2xlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdGFydCBieSBsb29raW5nIGZvciBhIHNpbmdsZSBjaGFyYWN0ZXIgbWF0Y2hcbiAgICAgICAgLy8gYW5kIGluY3JlYXNlIGxlbmd0aCB1bnRpbCBubyBtYXRjaCBpcyBmb3VuZC5cbiAgICAgICAgLy8gUGVyZm9ybWFuY2UgYW5hbHlzaXM6IGh0dHA6Ly9uZWlsLmZyYXNlci5uYW1lL25ld3MvMjAxMC8xMS8wNC9cbiAgICAgICAgdmFyIGJlc3QgPSAwO1xuICAgICAgICB2YXIgbGVuZ3RoID0gMTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIHZhciBwYXR0ZXJuID0gdGV4dDEuc3Vic3RyaW5nKHRleHRfbGVuZ3RoIC0gbGVuZ3RoKTtcbiAgICAgICAgICAgIHZhciBmb3VuZCA9IHRleHQyLmluZGV4T2YocGF0dGVybik7XG4gICAgICAgICAgICBpZiAoZm91bmQgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxlbmd0aCArPSBmb3VuZDtcbiAgICAgICAgICAgIGlmIChmb3VuZCA9PSAwIHx8IHRleHQxLnN1YnN0cmluZyh0ZXh0X2xlbmd0aCAtIGxlbmd0aCkgPT1cbiAgICAgICAgICAgICAgICB0ZXh0Mi5zdWJzdHJpbmcoMCwgbGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgIGJlc3QgPSBsZW5ndGg7XG4gICAgICAgICAgICAgICAgbGVuZ3RoKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIDtcbiAgICAvKipcbiAgICAgKiBEbyB0aGUgdHdvIHRleHRzIHNoYXJlIGEgc3Vic3RyaW5nIHdoaWNoIGlzIGF0IGxlYXN0IGhhbGYgdGhlIGxlbmd0aCBvZiB0aGVcbiAgICAgKiBsb25nZXIgdGV4dD9cbiAgICAgKiBUaGlzIHNwZWVkdXAgY2FuIHByb2R1Y2Ugbm9uLW1pbmltYWwgZGlmZnMuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQxIEZpcnN0IHN0cmluZy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgU2Vjb25kIHN0cmluZy5cbiAgICAgKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nPn0gRml2ZSBlbGVtZW50IEFycmF5LCBjb250YWluaW5nIHRoZSBwcmVmaXggb2ZcbiAgICAgKiAgICAgdGV4dDEsIHRoZSBzdWZmaXggb2YgdGV4dDEsIHRoZSBwcmVmaXggb2YgdGV4dDIsIHRoZSBzdWZmaXggb2ZcbiAgICAgKiAgICAgdGV4dDIgYW5kIHRoZSBjb21tb24gbWlkZGxlLiAgT3IgbnVsbCBpZiB0aGVyZSB3YXMgbm8gbWF0Y2guXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBEaWZmTWF0Y2hQYXRjaC5wcm90b3R5cGUuZGlmZl9oYWxmTWF0Y2hfID0gZnVuY3Rpb24gKHRleHQxLCB0ZXh0Mikge1xuICAgICAgICBpZiAodGhpcy5EaWZmX1RpbWVvdXQgPD0gMCkge1xuICAgICAgICAgICAgLy8gRG9uJ3QgcmlzayByZXR1cm5pbmcgYSBub24tb3B0aW1hbCBkaWZmIGlmIHdlIGhhdmUgdW5saW1pdGVkIHRpbWUuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbG9uZ3RleHQgPSB0ZXh0MS5sZW5ndGggPiB0ZXh0Mi5sZW5ndGggPyB0ZXh0MSA6IHRleHQyO1xuICAgICAgICB2YXIgc2hvcnR0ZXh0ID0gdGV4dDEubGVuZ3RoID4gdGV4dDIubGVuZ3RoID8gdGV4dDIgOiB0ZXh0MTtcbiAgICAgICAgaWYgKGxvbmd0ZXh0Lmxlbmd0aCA8IDQgfHwgc2hvcnR0ZXh0Lmxlbmd0aCAqIDIgPCBsb25ndGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsOyAvLyBQb2ludGxlc3MuXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRtcCA9IHRoaXM7IC8vICd0aGlzJyBiZWNvbWVzICd3aW5kb3cnIGluIGEgY2xvc3VyZS5cbiAgICAgICAgLy8gRmlyc3QgY2hlY2sgaWYgdGhlIHNlY29uZCBxdWFydGVyIGlzIHRoZSBzZWVkIGZvciBhIGhhbGYtbWF0Y2guXG4gICAgICAgIHZhciBobTEgPSB0aGlzLmRpZmZfaGFsZk1hdGNoSV8obG9uZ3RleHQsIHNob3J0dGV4dCwgTWF0aC5jZWlsKGxvbmd0ZXh0Lmxlbmd0aCAvIDQpLCBkbXApO1xuICAgICAgICAvLyBDaGVjayBhZ2FpbiBiYXNlZCBvbiB0aGUgdGhpcmQgcXVhcnRlci5cbiAgICAgICAgdmFyIGhtMiA9IHRoaXMuZGlmZl9oYWxmTWF0Y2hJXyhsb25ndGV4dCwgc2hvcnR0ZXh0LCBNYXRoLmNlaWwobG9uZ3RleHQubGVuZ3RoIC8gMiksIGRtcCk7XG4gICAgICAgIHZhciBobTtcbiAgICAgICAgaWYgKCFobTEgJiYgIWhtMikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWhtMikge1xuICAgICAgICAgICAgaG0gPSBobTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWhtMSkge1xuICAgICAgICAgICAgaG0gPSBobTI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBCb3RoIG1hdGNoZWQuICBTZWxlY3QgdGhlIGxvbmdlc3QuXG4gICAgICAgICAgICBobSA9IGhtMVs0XS5sZW5ndGggPiBobTJbNF0ubGVuZ3RoID8gaG0xIDogaG0yO1xuICAgICAgICB9XG4gICAgICAgIC8vIEEgaGFsZi1tYXRjaCB3YXMgZm91bmQsIHNvcnQgb3V0IHRoZSByZXR1cm4gZGF0YS5cbiAgICAgICAgdmFyIHRleHQxX2EsIHRleHQxX2IsIHRleHQyX2EsIHRleHQyX2I7XG4gICAgICAgIGlmICh0ZXh0MS5sZW5ndGggPiB0ZXh0Mi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRleHQxX2EgPSBobVswXTtcbiAgICAgICAgICAgIHRleHQxX2IgPSBobVsxXTtcbiAgICAgICAgICAgIHRleHQyX2EgPSBobVsyXTtcbiAgICAgICAgICAgIHRleHQyX2IgPSBobVszXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRleHQyX2EgPSBobVswXTtcbiAgICAgICAgICAgIHRleHQyX2IgPSBobVsxXTtcbiAgICAgICAgICAgIHRleHQxX2EgPSBobVsyXTtcbiAgICAgICAgICAgIHRleHQxX2IgPSBobVszXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWlkX2NvbW1vbiA9IGhtWzRdO1xuICAgICAgICByZXR1cm4gW3RleHQxX2EsIHRleHQxX2IsIHRleHQyX2EsIHRleHQyX2IsIG1pZF9jb21tb25dO1xuICAgIH07XG4gICAgO1xuICAgIC8qKlxuICAgICAqIERvZXMgYSBzdWJzdHJpbmcgb2Ygc2hvcnR0ZXh0IGV4aXN0IHdpdGhpbiBsb25ndGV4dCBzdWNoIHRoYXQgdGhlIHN1YnN0cmluZ1xuICAgICAqIGlzIGF0IGxlYXN0IGhhbGYgdGhlIGxlbmd0aCBvZiBsb25ndGV4dD9cbiAgICAgKiBDbG9zdXJlLCBidXQgZG9lcyBub3QgcmVmZXJlbmNlIGFueSBleHRlcm5hbCBjb25zdGlhYmxlcy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbG9uZ3RleHQgTG9uZ2VyIHN0cmluZy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2hvcnR0ZXh0IFNob3J0ZXIgc3RyaW5nLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpIFN0YXJ0IGluZGV4IG9mIHF1YXJ0ZXIgbGVuZ3RoIHN1YnN0cmluZyB3aXRoaW4gbG9uZ3RleHQuXG4gICAgICogQHJldHVybiB7QXJyYXkuPHN0cmluZz59IEZpdmUgZWxlbWVudCBBcnJheSwgY29udGFpbmluZyB0aGUgcHJlZml4IG9mXG4gICAgICogICAgIGxvbmd0ZXh0LCB0aGUgc3VmZml4IG9mIGxvbmd0ZXh0LCB0aGUgcHJlZml4IG9mIHNob3J0dGV4dCwgdGhlIHN1ZmZpeFxuICAgICAqICAgICBvZiBzaG9ydHRleHQgYW5kIHRoZSBjb21tb24gbWlkZGxlLiAgT3IgbnVsbCBpZiB0aGVyZSB3YXMgbm8gbWF0Y2guXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBEaWZmTWF0Y2hQYXRjaC5wcm90b3R5cGUuZGlmZl9oYWxmTWF0Y2hJXyA9IGZ1bmN0aW9uIChsb25ndGV4dCwgc2hvcnR0ZXh0LCBpLCBkbXApIHtcbiAgICAgICAgLy8gU3RhcnQgd2l0aCBhIDEvNCBsZW5ndGggc3Vic3RyaW5nIGF0IHBvc2l0aW9uIGkgYXMgYSBzZWVkLlxuICAgICAgICB2YXIgc2VlZCA9IGxvbmd0ZXh0LnN1YnN0cmluZyhpLCBpICsgTWF0aC5mbG9vcihsb25ndGV4dC5sZW5ndGggLyA0KSk7XG4gICAgICAgIHZhciBqID0gLTE7XG4gICAgICAgIHZhciBiZXN0X2NvbW1vbiA9ICcnO1xuICAgICAgICB2YXIgYmVzdF9sb25ndGV4dF9hLCBiZXN0X2xvbmd0ZXh0X2IsIGJlc3Rfc2hvcnR0ZXh0X2EsIGJlc3Rfc2hvcnR0ZXh0X2I7XG4gICAgICAgIHdoaWxlICgoaiA9IHNob3J0dGV4dC5pbmRleE9mKHNlZWQsIGogKyAxKSkgIT0gLTEpIHtcbiAgICAgICAgICAgIHZhciBwcmVmaXhMZW5ndGggPSBkbXAuZGlmZl9jb21tb25QcmVmaXgobG9uZ3RleHQuc3Vic3RyaW5nKGkpLCBzaG9ydHRleHQuc3Vic3RyaW5nKGopKTtcbiAgICAgICAgICAgIHZhciBzdWZmaXhMZW5ndGggPSBkbXAuZGlmZl9jb21tb25TdWZmaXgobG9uZ3RleHQuc3Vic3RyaW5nKDAsIGkpLCBzaG9ydHRleHQuc3Vic3RyaW5nKDAsIGopKTtcbiAgICAgICAgICAgIGlmIChiZXN0X2NvbW1vbi5sZW5ndGggPCBzdWZmaXhMZW5ndGggKyBwcmVmaXhMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBiZXN0X2NvbW1vbiA9IHNob3J0dGV4dC5zdWJzdHJpbmcoaiAtIHN1ZmZpeExlbmd0aCwgaikgK1xuICAgICAgICAgICAgICAgICAgICBzaG9ydHRleHQuc3Vic3RyaW5nKGosIGogKyBwcmVmaXhMZW5ndGgpO1xuICAgICAgICAgICAgICAgIGJlc3RfbG9uZ3RleHRfYSA9IGxvbmd0ZXh0LnN1YnN0cmluZygwLCBpIC0gc3VmZml4TGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBiZXN0X2xvbmd0ZXh0X2IgPSBsb25ndGV4dC5zdWJzdHJpbmcoaSArIHByZWZpeExlbmd0aCk7XG4gICAgICAgICAgICAgICAgYmVzdF9zaG9ydHRleHRfYSA9IHNob3J0dGV4dC5zdWJzdHJpbmcoMCwgaiAtIHN1ZmZpeExlbmd0aCk7XG4gICAgICAgICAgICAgICAgYmVzdF9zaG9ydHRleHRfYiA9IHNob3J0dGV4dC5zdWJzdHJpbmcoaiArIHByZWZpeExlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJlc3RfY29tbW9uLmxlbmd0aCAqIDIgPj0gbG9uZ3RleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gW2Jlc3RfbG9uZ3RleHRfYSwgYmVzdF9sb25ndGV4dF9iLFxuICAgICAgICAgICAgICAgIGJlc3Rfc2hvcnR0ZXh0X2EsIGJlc3Rfc2hvcnR0ZXh0X2IsIGJlc3RfY29tbW9uXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWR1Y2UgdGhlIG51bWJlciBvZiBlZGl0cyBieSBlbGltaW5hdGluZyBzZW1hbnRpY2FsbHkgdHJpdmlhbCBlcXVhbGl0aWVzLlxuICAgICAqIEBwYXJhbSB7IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5EaWZmPn0gZGlmZnMgQXJyYXkgb2YgZGlmZiB0dXBsZXMuXG4gICAgICovXG4gICAgRGlmZk1hdGNoUGF0Y2gucHJvdG90eXBlLmRpZmZfY2xlYW51cFNlbWFudGljID0gZnVuY3Rpb24gKGRpZmZzKSB7XG4gICAgICAgIHZhciBjaGFuZ2VzID0gZmFsc2U7XG4gICAgICAgIHZhciBlcXVhbGl0aWVzID0gW107IC8vIFN0YWNrIG9mIGluZGljZXMgd2hlcmUgZXF1YWxpdGllcyBhcmUgZm91bmQuXG4gICAgICAgIHZhciBlcXVhbGl0aWVzTGVuZ3RoID0gMDsgLy8gS2VlcGluZyBvdXIgb3duIGxlbmd0aCBjb25zdCBpcyBmYXN0ZXIgaW4gSlMuXG4gICAgICAgIC8qKiBAdHlwZSB7P3N0cmluZ30gKi9cbiAgICAgICAgdmFyIGxhc3RlcXVhbGl0eSA9IG51bGw7XG4gICAgICAgIC8vIEFsd2F5cyBlcXVhbCB0byBkaWZmc1tlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGggLSAxXV1bMV1cbiAgICAgICAgdmFyIHBvaW50ZXIgPSAwOyAvLyBJbmRleCBvZiBjdXJyZW50IHBvc2l0aW9uLlxuICAgICAgICAvLyBOdW1iZXIgb2YgY2hhcmFjdGVycyB0aGF0IGNoYW5nZWQgcHJpb3IgdG8gdGhlIGVxdWFsaXR5LlxuICAgICAgICB2YXIgbGVuZ3RoX2luc2VydGlvbnMxID0gMDtcbiAgICAgICAgdmFyIGxlbmd0aF9kZWxldGlvbnMxID0gMDtcbiAgICAgICAgLy8gTnVtYmVyIG9mIGNoYXJhY3RlcnMgdGhhdCBjaGFuZ2VkIGFmdGVyIHRoZSBlcXVhbGl0eS5cbiAgICAgICAgdmFyIGxlbmd0aF9pbnNlcnRpb25zMiA9IDA7XG4gICAgICAgIHZhciBsZW5ndGhfZGVsZXRpb25zMiA9IDA7XG4gICAgICAgIHdoaWxlIChwb2ludGVyIDwgZGlmZnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoZGlmZnNbcG9pbnRlcl1bMF0gPT0gMCAvKiBFcXVhbCAqLykge1xuICAgICAgICAgICAgICAgIGVxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCsrXSA9IHBvaW50ZXI7XG4gICAgICAgICAgICAgICAgbGVuZ3RoX2luc2VydGlvbnMxID0gbGVuZ3RoX2luc2VydGlvbnMyO1xuICAgICAgICAgICAgICAgIGxlbmd0aF9kZWxldGlvbnMxID0gbGVuZ3RoX2RlbGV0aW9uczI7XG4gICAgICAgICAgICAgICAgbGVuZ3RoX2luc2VydGlvbnMyID0gMDtcbiAgICAgICAgICAgICAgICBsZW5ndGhfZGVsZXRpb25zMiA9IDA7XG4gICAgICAgICAgICAgICAgbGFzdGVxdWFsaXR5ID0gZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZGlmZnNbcG9pbnRlcl1bMF0gPT0gMSAvKiBJbnNlcnQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoX2luc2VydGlvbnMyICs9IGRpZmZzW3BvaW50ZXJdWzFdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aF9kZWxldGlvbnMyICs9IGRpZmZzW3BvaW50ZXJdWzFdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRWxpbWluYXRlIGFuIGVxdWFsaXR5IHRoYXQgaXMgc21hbGxlciBvciBlcXVhbCB0byB0aGUgZWRpdHMgb24gYm90aFxuICAgICAgICAgICAgICAgIC8vIHNpZGVzIG9mIGl0LlxuICAgICAgICAgICAgICAgIGlmIChsYXN0ZXF1YWxpdHkgJiYgKGxhc3RlcXVhbGl0eS5sZW5ndGggPD1cbiAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgobGVuZ3RoX2luc2VydGlvbnMxLCBsZW5ndGhfZGVsZXRpb25zMSkpICYmXG4gICAgICAgICAgICAgICAgICAgIChsYXN0ZXF1YWxpdHkubGVuZ3RoIDw9IE1hdGgubWF4KGxlbmd0aF9pbnNlcnRpb25zMiwgbGVuZ3RoX2RlbGV0aW9uczIpKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBEdXBsaWNhdGUgcmVjb3JkLlxuICAgICAgICAgICAgICAgICAgICBkaWZmcy5zcGxpY2UoZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoIC0gMV0sIDAsIFstMSAvKiBEZWxldGUgKi8sIGxhc3RlcXVhbGl0eV0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBDaGFuZ2Ugc2Vjb25kIGNvcHkgdG8gaW5zZXJ0LlxuICAgICAgICAgICAgICAgICAgICBkaWZmc1tlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGggLSAxXSArIDFdWzBdID0gMSAvKiBJbnNlcnQgKi87XG4gICAgICAgICAgICAgICAgICAgIC8vIFRocm93IGF3YXkgdGhlIGVxdWFsaXR5IHdlIGp1c3QgZGVsZXRlZC5cbiAgICAgICAgICAgICAgICAgICAgZXF1YWxpdGllc0xlbmd0aC0tO1xuICAgICAgICAgICAgICAgICAgICAvLyBUaHJvdyBhd2F5IHRoZSBwcmV2aW91cyBlcXVhbGl0eSAoaXQgbmVlZHMgdG8gYmUgcmVldmFsdWF0ZWQpLlxuICAgICAgICAgICAgICAgICAgICBlcXVhbGl0aWVzTGVuZ3RoLS07XG4gICAgICAgICAgICAgICAgICAgIHBvaW50ZXIgPSBlcXVhbGl0aWVzTGVuZ3RoID4gMCA/IGVxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCAtIDFdIDogLTE7XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aF9pbnNlcnRpb25zMSA9IDA7IC8vIFJlc2V0IHRoZSBjb3VudGVycy5cbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoX2RlbGV0aW9uczEgPSAwO1xuICAgICAgICAgICAgICAgICAgICBsZW5ndGhfaW5zZXJ0aW9uczIgPSAwO1xuICAgICAgICAgICAgICAgICAgICBsZW5ndGhfZGVsZXRpb25zMiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RlcXVhbGl0eSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvaW50ZXIrKztcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIGRpZmYuXG4gICAgICAgIGlmIChjaGFuZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLmRpZmZfY2xlYW51cE1lcmdlKGRpZmZzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRpZmZfY2xlYW51cFNlbWFudGljTG9zc2xlc3MoZGlmZnMpO1xuICAgICAgICAvLyBGaW5kIGFueSBvdmVybGFwcyBiZXR3ZWVuIGRlbGV0aW9ucyBhbmQgaW5zZXJ0aW9ucy5cbiAgICAgICAgLy8gZS5nOiA8ZGVsPmFiY3h4eDwvZGVsPjxpbnM+eHh4ZGVmPC9pbnM+XG4gICAgICAgIC8vICAgLT4gPGRlbD5hYmM8L2RlbD54eHg8aW5zPmRlZjwvaW5zPlxuICAgICAgICAvLyBlLmc6IDxkZWw+eHh4YWJjPC9kZWw+PGlucz5kZWZ4eHg8L2lucz5cbiAgICAgICAgLy8gICAtPiA8aW5zPmRlZjwvaW5zPnh4eDxkZWw+YWJjPC9kZWw+XG4gICAgICAgIC8vIE9ubHkgZXh0cmFjdCBhbiBvdmVybGFwIGlmIGl0IGlzIGFzIGJpZyBhcyB0aGUgZWRpdCBhaGVhZCBvciBiZWhpbmQgaXQuXG4gICAgICAgIHBvaW50ZXIgPSAxO1xuICAgICAgICB3aGlsZSAocG9pbnRlciA8IGRpZmZzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGRpZmZzW3BvaW50ZXIgLSAxXVswXSA9PSAtMSAvKiBEZWxldGUgKi8gJiZcbiAgICAgICAgICAgICAgICBkaWZmc1twb2ludGVyXVswXSA9PSAxIC8qIEluc2VydCAqLykge1xuICAgICAgICAgICAgICAgIHZhciBkZWxldGlvbiA9IGRpZmZzW3BvaW50ZXIgLSAxXVsxXTtcbiAgICAgICAgICAgICAgICB2YXIgaW5zZXJ0aW9uID0gZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgICAgICAgICAgICAgdmFyIG92ZXJsYXBfbGVuZ3RoMSA9IHRoaXMuZGlmZl9jb21tb25PdmVybGFwXyhkZWxldGlvbiwgaW5zZXJ0aW9uKTtcbiAgICAgICAgICAgICAgICB2YXIgb3ZlcmxhcF9sZW5ndGgyID0gdGhpcy5kaWZmX2NvbW1vbk92ZXJsYXBfKGluc2VydGlvbiwgZGVsZXRpb24pO1xuICAgICAgICAgICAgICAgIGlmIChvdmVybGFwX2xlbmd0aDEgPj0gb3ZlcmxhcF9sZW5ndGgyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdmVybGFwX2xlbmd0aDEgPj0gZGVsZXRpb24ubGVuZ3RoIC8gMiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcF9sZW5ndGgxID49IGluc2VydGlvbi5sZW5ndGggLyAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPdmVybGFwIGZvdW5kLiAgSW5zZXJ0IGFuIGVxdWFsaXR5IGFuZCB0cmltIHRoZSBzdXJyb3VuZGluZyBlZGl0cy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyLCAwLCBbMCAvKiBFcXVhbCAqLywgaW5zZXJ0aW9uLnN1YnN0cmluZygwLCBvdmVybGFwX2xlbmd0aDEpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaWZmc1twb2ludGVyIC0gMV1bMV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0aW9uLnN1YnN0cmluZygwLCBkZWxldGlvbi5sZW5ndGggLSBvdmVybGFwX2xlbmd0aDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlmZnNbcG9pbnRlciArIDFdWzFdID0gaW5zZXJ0aW9uLnN1YnN0cmluZyhvdmVybGFwX2xlbmd0aDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRlcisrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3ZlcmxhcF9sZW5ndGgyID49IGRlbGV0aW9uLmxlbmd0aCAvIDIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXBfbGVuZ3RoMiA+PSBpbnNlcnRpb24ubGVuZ3RoIC8gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV2ZXJzZSBvdmVybGFwIGZvdW5kLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW5zZXJ0IGFuIGVxdWFsaXR5IGFuZCBzd2FwIGFuZCB0cmltIHRoZSBzdXJyb3VuZGluZyBlZGl0cy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyLCAwLCBbMCAvKiBFcXVhbCAqLywgZGVsZXRpb24uc3Vic3RyaW5nKDAsIG92ZXJsYXBfbGVuZ3RoMildKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZmZzW3BvaW50ZXIgLSAxXVswXSA9IDEgLyogSW5zZXJ0ICovO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlmZnNbcG9pbnRlciAtIDFdWzFdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRpb24uc3Vic3RyaW5nKDAsIGluc2VydGlvbi5sZW5ndGggLSBvdmVybGFwX2xlbmd0aDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlmZnNbcG9pbnRlciArIDFdWzBdID0gLTEgLyogRGVsZXRlICovO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlmZnNbcG9pbnRlciArIDFdWzFdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGlvbi5zdWJzdHJpbmcob3ZlcmxhcF9sZW5ndGgyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ZXIrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwb2ludGVyKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb2ludGVyKys7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIDtcbiAgICAvKipcbiAgICAgKiBMb29rIGZvciBzaW5nbGUgZWRpdHMgc3Vycm91bmRlZCBvbiBib3RoIHNpZGVzIGJ5IGVxdWFsaXRpZXNcbiAgICAgKiB3aGljaCBjYW4gYmUgc2hpZnRlZCBzaWRld2F5cyB0byBhbGlnbiB0aGUgZWRpdCB0byBhIHdvcmQgYm91bmRhcnkuXG4gICAgICogZS5nOiBUaGUgYzxpbnM+YXQgYzwvaW5zPmFtZS4gLT4gVGhlIDxpbnM+Y2F0IDwvaW5zPmNhbWUuXG4gICAgICogQHBhcmFtIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLkRpZmY+fSBkaWZmcyBBcnJheSBvZiBkaWZmIHR1cGxlcy5cbiAgICAgKi9cbiAgICBEaWZmTWF0Y2hQYXRjaC5wcm90b3R5cGUuZGlmZl9jbGVhbnVwU2VtYW50aWNMb3NzbGVzcyA9IGZ1bmN0aW9uIChkaWZmcykge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2l2ZW4gdHdvIHN0cmluZ3MsIGNvbXB1dGUgYSBzY29yZSByZXByZXNlbnRpbmcgd2hldGhlciB0aGUgaW50ZXJuYWxcbiAgICAgICAgICogYm91bmRhcnkgZmFsbHMgb24gbG9naWNhbCBib3VuZGFyaWVzLlxuICAgICAgICAgKiBTY29yZXMgcmFuZ2UgZnJvbSA2IChiZXN0KSB0byAwICh3b3JzdCkuXG4gICAgICAgICAqIENsb3N1cmUsIGJ1dCBkb2VzIG5vdCByZWZlcmVuY2UgYW55IGV4dGVybmFsIGNvbnN0aWFibGVzLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gb25lIEZpcnN0IHN0cmluZy5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHR3byBTZWNvbmQgc3RyaW5nLlxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBzY29yZS5cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGRpZmZfY2xlYW51cFNlbWFudGljU2NvcmVfKG9uZSwgdHdvKSB7XG4gICAgICAgICAgICBpZiAoIW9uZSB8fCAhdHdvKSB7XG4gICAgICAgICAgICAgICAgLy8gRWRnZXMgYXJlIHRoZSBiZXN0LlxuICAgICAgICAgICAgICAgIHJldHVybiA2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG5vbkFscGhhTnVtZXJpY1JlZ2V4XyA9IG5ldyBSZWdFeHAoJy9bXmEtekEtWjAtOV0vJyk7XG4gICAgICAgICAgICAvLyBFYWNoIHBvcnQgb2YgdGhpcyBmdW5jdGlvbiBiZWhhdmVzIHNsaWdodGx5IGRpZmZlcmVudGx5IGR1ZSB0b1xuICAgICAgICAgICAgLy8gc3VidGxlIGRpZmZlcmVuY2VzIGluIGVhY2ggbGFuZ3VhZ2UncyBkZWZpbml0aW9uIG9mIHRoaW5ncyBsaWtlXG4gICAgICAgICAgICAvLyAnd2hpdGVzcGFjZScuICBTaW5jZSB0aGlzIGZ1bmN0aW9uJ3MgcHVycG9zZSBpcyBsYXJnZWx5IGNvc21ldGljLFxuICAgICAgICAgICAgLy8gdGhlIGNob2ljZSBoYXMgYmVlbiBtYWRlIHRvIHVzZSBlYWNoIGxhbmd1YWdlJ3MgbmF0aXZlIGZlYXR1cmVzXG4gICAgICAgICAgICAvLyByYXRoZXIgdGhhbiBmb3JjZSB0b3RhbCBjb25mb3JtaXR5LlxuICAgICAgICAgICAgdmFyIGNoYXIxID0gb25lLmNoYXJBdChvbmUubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICB2YXIgY2hhcjIgPSB0d28uY2hhckF0KDApO1xuICAgICAgICAgICAgdmFyIG5vbkFscGhhTnVtZXJpYzEgPSBjaGFyMS5tYXRjaChub25BbHBoYU51bWVyaWNSZWdleF8pO1xuICAgICAgICAgICAgdmFyIG5vbkFscGhhTnVtZXJpYzIgPSBjaGFyMi5tYXRjaChub25BbHBoYU51bWVyaWNSZWdleF8pO1xuICAgICAgICAgICAgdmFyIHdoaXRlc3BhY2UxID0gbm9uQWxwaGFOdW1lcmljMSAmJlxuICAgICAgICAgICAgICAgIGNoYXIxLm1hdGNoKHRoaXMud2hpdGVzcGFjZVJlZ2V4Xyk7XG4gICAgICAgICAgICB2YXIgd2hpdGVzcGFjZTIgPSBub25BbHBoYU51bWVyaWMyICYmXG4gICAgICAgICAgICAgICAgY2hhcjIubWF0Y2godGhpcy53aGl0ZXNwYWNlUmVnZXhfKTtcbiAgICAgICAgICAgIHZhciBsaW5lQnJlYWsxID0gd2hpdGVzcGFjZTEgJiZcbiAgICAgICAgICAgICAgICBjaGFyMS5tYXRjaCh0aGlzLmxpbmVicmVha1JlZ2V4Xyk7XG4gICAgICAgICAgICB2YXIgbGluZUJyZWFrMiA9IHdoaXRlc3BhY2UyICYmXG4gICAgICAgICAgICAgICAgY2hhcjIubWF0Y2godGhpcy5saW5lYnJlYWtSZWdleF8pO1xuICAgICAgICAgICAgdmFyIGJsYW5rTGluZTEgPSBsaW5lQnJlYWsxICYmXG4gICAgICAgICAgICAgICAgb25lLm1hdGNoKHRoaXMuYmxhbmtsaW5lRW5kUmVnZXhfKTtcbiAgICAgICAgICAgIHZhciBibGFua0xpbmUyID0gbGluZUJyZWFrMiAmJlxuICAgICAgICAgICAgICAgIHR3by5tYXRjaCh0aGlzLmJsYW5rbGluZVN0YXJ0UmVnZXhfKTtcbiAgICAgICAgICAgIGlmIChibGFua0xpbmUxIHx8IGJsYW5rTGluZTIpIHtcbiAgICAgICAgICAgICAgICAvLyBGaXZlIHBvaW50cyBmb3IgYmxhbmsgbGluZXMuXG4gICAgICAgICAgICAgICAgcmV0dXJuIDU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsaW5lQnJlYWsxIHx8IGxpbmVCcmVhazIpIHtcbiAgICAgICAgICAgICAgICAvLyBGb3VyIHBvaW50cyBmb3IgbGluZSBicmVha3MuXG4gICAgICAgICAgICAgICAgcmV0dXJuIDQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChub25BbHBoYU51bWVyaWMxICYmICF3aGl0ZXNwYWNlMSAmJiB3aGl0ZXNwYWNlMikge1xuICAgICAgICAgICAgICAgIC8vIFRocmVlIHBvaW50cyBmb3IgZW5kIG9mIHNlbnRlbmNlcy5cbiAgICAgICAgICAgICAgICByZXR1cm4gMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHdoaXRlc3BhY2UxIHx8IHdoaXRlc3BhY2UyKSB7XG4gICAgICAgICAgICAgICAgLy8gVHdvIHBvaW50cyBmb3Igd2hpdGVzcGFjZS5cbiAgICAgICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5vbkFscGhhTnVtZXJpYzEgfHwgbm9uQWxwaGFOdW1lcmljMikge1xuICAgICAgICAgICAgICAgIC8vIE9uZSBwb2ludCBmb3Igbm9uLWFscGhhbnVtZXJpYy5cbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwb2ludGVyID0gMTtcbiAgICAgICAgLy8gSW50ZW50aW9uYWxseSBpZ25vcmUgdGhlIGZpcnN0IGFuZCBsYXN0IGVsZW1lbnQgKGRvbid0IG5lZWQgY2hlY2tpbmcpLlxuICAgICAgICB3aGlsZSAocG9pbnRlciA8IGRpZmZzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIGlmIChkaWZmc1twb2ludGVyIC0gMV1bMF0gPT0gMCAvKiBFcXVhbCAqLyAmJlxuICAgICAgICAgICAgICAgIGRpZmZzW3BvaW50ZXIgKyAxXVswXSA9PSAwIC8qIEVxdWFsICovKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHNpbmdsZSBlZGl0IHN1cnJvdW5kZWQgYnkgZXF1YWxpdGllcy5cbiAgICAgICAgICAgICAgICB2YXIgZXF1YWxpdHkxID0gZGlmZnNbcG9pbnRlciAtIDFdWzFdO1xuICAgICAgICAgICAgICAgIHZhciBlZGl0ID0gZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgICAgICAgICAgICAgdmFyIGVxdWFsaXR5MiA9IGRpZmZzW3BvaW50ZXIgKyAxXVsxXTtcbiAgICAgICAgICAgICAgICAvLyBGaXJzdCwgc2hpZnQgdGhlIGVkaXQgYXMgZmFyIGxlZnQgYXMgcG9zc2libGUuXG4gICAgICAgICAgICAgICAgdmFyIGNvbW1vbk9mZnNldCA9IHRoaXMuZGlmZl9jb21tb25TdWZmaXgoZXF1YWxpdHkxLCBlZGl0KTtcbiAgICAgICAgICAgICAgICBpZiAoY29tbW9uT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb21tb25TdHJpbmcgPSBlZGl0LnN1YnN0cmluZyhlZGl0Lmxlbmd0aCAtIGNvbW1vbk9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIGVxdWFsaXR5MSA9IGVxdWFsaXR5MS5zdWJzdHJpbmcoMCwgZXF1YWxpdHkxLmxlbmd0aCAtIGNvbW1vbk9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIGVkaXQgPSBjb21tb25TdHJpbmcgKyBlZGl0LnN1YnN0cmluZygwLCBlZGl0Lmxlbmd0aCAtIGNvbW1vbk9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIGVxdWFsaXR5MiA9IGNvbW1vblN0cmluZyArIGVxdWFsaXR5MjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gU2Vjb25kLCBzdGVwIGNoYXJhY3RlciBieSBjaGFyYWN0ZXIgcmlnaHQsIGxvb2tpbmcgZm9yIHRoZSBiZXN0IGZpdC5cbiAgICAgICAgICAgICAgICB2YXIgYmVzdEVxdWFsaXR5MSA9IGVxdWFsaXR5MTtcbiAgICAgICAgICAgICAgICB2YXIgYmVzdEVkaXQgPSBlZGl0O1xuICAgICAgICAgICAgICAgIHZhciBiZXN0RXF1YWxpdHkyID0gZXF1YWxpdHkyO1xuICAgICAgICAgICAgICAgIHZhciBiZXN0U2NvcmUgPSBkaWZmX2NsZWFudXBTZW1hbnRpY1Njb3JlXyhlcXVhbGl0eTEsIGVkaXQpICtcbiAgICAgICAgICAgICAgICAgICAgZGlmZl9jbGVhbnVwU2VtYW50aWNTY29yZV8oZWRpdCwgZXF1YWxpdHkyKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoZWRpdC5jaGFyQXQoMCkgPT09IGVxdWFsaXR5Mi5jaGFyQXQoMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXF1YWxpdHkxICs9IGVkaXQuY2hhckF0KDApO1xuICAgICAgICAgICAgICAgICAgICBlZGl0ID0gZWRpdC5zdWJzdHJpbmcoMSkgKyBlcXVhbGl0eTIuY2hhckF0KDApO1xuICAgICAgICAgICAgICAgICAgICBlcXVhbGl0eTIgPSBlcXVhbGl0eTIuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2NvcmUgPSBkaWZmX2NsZWFudXBTZW1hbnRpY1Njb3JlXyhlcXVhbGl0eTEsIGVkaXQpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZmZfY2xlYW51cFNlbWFudGljU2NvcmVfKGVkaXQsIGVxdWFsaXR5Mik7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSA+PSBlbmNvdXJhZ2VzIHRyYWlsaW5nIHJhdGhlciB0aGFuIGxlYWRpbmcgd2hpdGVzcGFjZSBvbiBlZGl0cy5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjb3JlID49IGJlc3RTY29yZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdFNjb3JlID0gc2NvcmU7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0RXF1YWxpdHkxID0gZXF1YWxpdHkxO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdEVkaXQgPSBlZGl0O1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdEVxdWFsaXR5MiA9IGVxdWFsaXR5MjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGlmZnNbcG9pbnRlciAtIDFdWzFdICE9IGJlc3RFcXVhbGl0eTEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBhbiBpbXByb3ZlbWVudCwgc2F2ZSBpdCBiYWNrIHRvIHRoZSBkaWZmLlxuICAgICAgICAgICAgICAgICAgICBpZiAoYmVzdEVxdWFsaXR5MSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlmZnNbcG9pbnRlciAtIDFdWzFdID0gYmVzdEVxdWFsaXR5MTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyIC0gMSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVyLS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGlmZnNbcG9pbnRlcl1bMV0gPSBiZXN0RWRpdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJlc3RFcXVhbGl0eTIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZmZzW3BvaW50ZXIgKyAxXVsxXSA9IGJlc3RFcXVhbGl0eTI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciArIDEsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRlci0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9pbnRlcisrO1xuICAgICAgICB9XG4gICAgfTtcbiAgICA7XG4gICAgLyoqXG4gICAgICogUmVkdWNlIHRoZSBudW1iZXIgb2YgZWRpdHMgYnkgZWxpbWluYXRpbmcgb3BlcmF0aW9uYWxseSB0cml2aWFsIGVxdWFsaXRpZXMuXG4gICAgICogQHBhcmFtIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLkRpZmY+fSBkaWZmcyBBcnJheSBvZiBkaWZmIHR1cGxlcy5cbiAgICAgKi9cbiAgICBEaWZmTWF0Y2hQYXRjaC5wcm90b3R5cGUuZGlmZl9jbGVhbnVwRWZmaWNpZW5jeSA9IGZ1bmN0aW9uIChkaWZmcykge1xuICAgICAgICB2YXIgY2hhbmdlcyA9IGZhbHNlO1xuICAgICAgICB2YXIgZXF1YWxpdGllcyA9IFtdOyAvLyBTdGFjayBvZiBpbmRpY2VzIHdoZXJlIGVxdWFsaXRpZXMgYXJlIGZvdW5kLlxuICAgICAgICB2YXIgZXF1YWxpdGllc0xlbmd0aCA9IDA7IC8vIEtlZXBpbmcgb3VyIG93biBsZW5ndGggY29uc3QgaXMgZmFzdGVyIGluIEpTLlxuICAgICAgICAvKiogQHR5cGUgez9zdHJpbmd9ICovXG4gICAgICAgIHZhciBsYXN0ZXF1YWxpdHkgPSBudWxsO1xuICAgICAgICAvLyBBbHdheXMgZXF1YWwgdG8gZGlmZnNbZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoIC0gMV1dWzFdXG4gICAgICAgIHZhciBwb2ludGVyID0gMDsgLy8gSW5kZXggb2YgY3VycmVudCBwb3NpdGlvbi5cbiAgICAgICAgLy8gSXMgdGhlcmUgYW4gaW5zZXJ0aW9uIG9wZXJhdGlvbiBiZWZvcmUgdGhlIGxhc3QgZXF1YWxpdHkuXG4gICAgICAgIHZhciBwcmVfaW5zID0gZmFsc2U7XG4gICAgICAgIC8vIElzIHRoZXJlIGEgZGVsZXRpb24gb3BlcmF0aW9uIGJlZm9yZSB0aGUgbGFzdCBlcXVhbGl0eS5cbiAgICAgICAgdmFyIHByZV9kZWwgPSBmYWxzZTtcbiAgICAgICAgLy8gSXMgdGhlcmUgYW4gaW5zZXJ0aW9uIG9wZXJhdGlvbiBhZnRlciB0aGUgbGFzdCBlcXVhbGl0eS5cbiAgICAgICAgdmFyIHBvc3RfaW5zID0gZmFsc2U7XG4gICAgICAgIC8vIElzIHRoZXJlIGEgZGVsZXRpb24gb3BlcmF0aW9uIGFmdGVyIHRoZSBsYXN0IGVxdWFsaXR5LlxuICAgICAgICB2YXIgcG9zdF9kZWwgPSBmYWxzZTtcbiAgICAgICAgd2hpbGUgKHBvaW50ZXIgPCBkaWZmcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChkaWZmc1twb2ludGVyXVswXSA9PSAwIC8qIEVxdWFsICovKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRpZmZzW3BvaW50ZXJdWzFdLmxlbmd0aCA8IHRoaXMuRGlmZl9FZGl0Q29zdCAmJlxuICAgICAgICAgICAgICAgICAgICAocG9zdF9pbnMgfHwgcG9zdF9kZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENhbmRpZGF0ZSBmb3VuZC5cbiAgICAgICAgICAgICAgICAgICAgZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoKytdID0gcG9pbnRlcjtcbiAgICAgICAgICAgICAgICAgICAgcHJlX2lucyA9IHBvc3RfaW5zO1xuICAgICAgICAgICAgICAgICAgICBwcmVfZGVsID0gcG9zdF9kZWw7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RlcXVhbGl0eSA9IGRpZmZzW3BvaW50ZXJdWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90IGEgY2FuZGlkYXRlLCBhbmQgY2FuIG5ldmVyIGJlY29tZSBvbmUuXG4gICAgICAgICAgICAgICAgICAgIGVxdWFsaXRpZXNMZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICBsYXN0ZXF1YWxpdHkgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwb3N0X2lucyA9IHBvc3RfZGVsID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZGlmZnNbcG9pbnRlcl1bMF0gPT0gLTEgLyogRGVsZXRlICovKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc3RfZGVsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc3RfaW5zID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAqIEZpdmUgdHlwZXMgdG8gYmUgc3BsaXQ6XG4gICAgICAgICAgICAgICAgKiA8aW5zPkE8L2lucz48ZGVsPkI8L2RlbD5YWTxpbnM+QzwvaW5zPjxkZWw+RDwvZGVsPlxuICAgICAgICAgICAgICAgICogPGlucz5BPC9pbnM+WDxpbnM+QzwvaW5zPjxkZWw+RDwvZGVsPlxuICAgICAgICAgICAgICAgICogPGlucz5BPC9pbnM+PGRlbD5CPC9kZWw+WDxpbnM+QzwvaW5zPlxuICAgICAgICAgICAgICAgICogPGlucz5BPC9kZWw+WDxpbnM+QzwvaW5zPjxkZWw+RDwvZGVsPlxuICAgICAgICAgICAgICAgICogPGlucz5BPC9pbnM+PGRlbD5CPC9kZWw+WDxkZWw+QzwvZGVsPlxuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaWYgKGxhc3RlcXVhbGl0eSAmJiAoKHByZV9pbnMgJiYgcHJlX2RlbCAmJiBwb3N0X2lucyAmJiBwb3N0X2RlbCkgfHxcbiAgICAgICAgICAgICAgICAgICAgKChsYXN0ZXF1YWxpdHkubGVuZ3RoIDwgdGhpcy5EaWZmX0VkaXRDb3N0IC8gMikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICgocHJlX2lucyA/IDEgOiAwKSArIChwcmVfZGVsID8gMSA6IDApICsgKHBvc3RfaW5zID8gMSA6IDApICsgKHBvc3RfZGVsID8gMSA6IDApID09IDMpKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRHVwbGljYXRlIHJlY29yZC5cbiAgICAgICAgICAgICAgICAgICAgZGlmZnMuc3BsaWNlKGVxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCAtIDFdLCAwLCBbLTEgLyogRGVsZXRlICovLCBsYXN0ZXF1YWxpdHldKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hhbmdlIHNlY29uZCBjb3B5IHRvIGluc2VydC5cbiAgICAgICAgICAgICAgICAgICAgZGlmZnNbZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoIC0gMV0gKyAxXVswXSA9IDEgLyogSW5zZXJ0ICovO1xuICAgICAgICAgICAgICAgICAgICBlcXVhbGl0aWVzTGVuZ3RoLS07IC8vIFRocm93IGF3YXkgdGhlIGVxdWFsaXR5IHdlIGp1c3QgZGVsZXRlZDtcbiAgICAgICAgICAgICAgICAgICAgbGFzdGVxdWFsaXR5ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZV9pbnMgJiYgcHJlX2RlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm8gY2hhbmdlcyBtYWRlIHdoaWNoIGNvdWxkIGFmZmVjdCBwcmV2aW91cyBlbnRyeSwga2VlcCBnb2luZy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc3RfaW5zID0gcG9zdF9kZWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXF1YWxpdGllc0xlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcXVhbGl0aWVzTGVuZ3RoLS07IC8vIFRocm93IGF3YXkgdGhlIHByZXZpb3VzIGVxdWFsaXR5LlxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRlciA9IGVxdWFsaXRpZXNMZW5ndGggPiAwID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGggLSAxXSA6IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zdF9pbnMgPSBwb3N0X2RlbCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvaW50ZXIrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlcykge1xuICAgICAgICAgICAgdGhpcy5kaWZmX2NsZWFudXBNZXJnZShkaWZmcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIDtcbiAgICAvKipcbiAgICAgKiBSZW9yZGVyIGFuZCBtZXJnZSBsaWtlIGVkaXQgc2VjdGlvbnMuICBNZXJnZSBlcXVhbGl0aWVzLlxuICAgICAqIEFueSBlZGl0IHNlY3Rpb24gY2FuIG1vdmUgYXMgbG9uZyBhcyBpdCBkb2Vzbid0IGNyb3NzIGFuIGVxdWFsaXR5LlxuICAgICAqIEBwYXJhbSB7IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5EaWZmPn0gZGlmZnMgQXJyYXkgb2YgZGlmZiB0dXBsZXMuXG4gICAgICovXG4gICAgRGlmZk1hdGNoUGF0Y2gucHJvdG90eXBlLmRpZmZfY2xlYW51cE1lcmdlID0gZnVuY3Rpb24gKGRpZmZzKSB7XG4gICAgICAgIGRpZmZzLnB1c2goWzAgLyogRXF1YWwgKi8sICcnXSk7IC8vIEFkZCBhIGR1bW15IGVudHJ5IGF0IHRoZSBlbmQuXG4gICAgICAgIHZhciBwb2ludGVyID0gMDtcbiAgICAgICAgdmFyIGNvdW50X2RlbGV0ZSA9IDA7XG4gICAgICAgIHZhciBjb3VudF9pbnNlcnQgPSAwO1xuICAgICAgICB2YXIgdGV4dF9kZWxldGUgPSAnJztcbiAgICAgICAgdmFyIHRleHRfaW5zZXJ0ID0gJyc7XG4gICAgICAgIHZhciBjb21tb25sZW5ndGg7XG4gICAgICAgIHdoaWxlIChwb2ludGVyIDwgZGlmZnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGRpZmZzW3BvaW50ZXJdWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxIC8qIEluc2VydCAqLzpcbiAgICAgICAgICAgICAgICAgICAgY291bnRfaW5zZXJ0Kys7XG4gICAgICAgICAgICAgICAgICAgIHRleHRfaW5zZXJ0ICs9IGRpZmZzW3BvaW50ZXJdWzFdO1xuICAgICAgICAgICAgICAgICAgICBwb2ludGVyKys7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLTEgLyogRGVsZXRlICovOlxuICAgICAgICAgICAgICAgICAgICBjb3VudF9kZWxldGUrKztcbiAgICAgICAgICAgICAgICAgICAgdGV4dF9kZWxldGUgKz0gZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgICAgICAgICAgICAgICAgIHBvaW50ZXIrKztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAwIC8qIEVxdWFsICovOlxuICAgICAgICAgICAgICAgICAgICAvLyBVcG9uIHJlYWNoaW5nIGFuIGVxdWFsaXR5LCBjaGVjayBmb3IgcHJpb3IgcmVkdW5kYW5jaWVzLlxuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnRfZGVsZXRlICsgY291bnRfaW5zZXJ0ID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50X2RlbGV0ZSAhPT0gMCAmJiBjb3VudF9pbnNlcnQgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGYWN0b3Igb3V0IGFueSBjb21tb24gcHJlZml4aWVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1vbmxlbmd0aCA9IHRoaXMuZGlmZl9jb21tb25QcmVmaXgodGV4dF9pbnNlcnQsIHRleHRfZGVsZXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tbW9ubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocG9pbnRlciAtIGNvdW50X2RlbGV0ZSAtIGNvdW50X2luc2VydCkgPiAwICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWZmc1twb2ludGVyIC0gY291bnRfZGVsZXRlIC0gY291bnRfaW5zZXJ0IC0gMV1bMF0gPT1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwIC8qIEVxdWFsICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWZmc1twb2ludGVyIC0gY291bnRfZGVsZXRlIC0gY291bnRfaW5zZXJ0IC0gMV1bMV0gKz1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0X2luc2VydC5zdWJzdHJpbmcoMCwgY29tbW9ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpZmZzLnNwbGljZSgwLCAwLCBbMCAvKiBFcXVhbCAqLyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0X2luc2VydC5zdWJzdHJpbmcoMCwgY29tbW9ubGVuZ3RoKV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRlcisrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRfaW5zZXJ0ID0gdGV4dF9pbnNlcnQuc3Vic3RyaW5nKGNvbW1vbmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRfZGVsZXRlID0gdGV4dF9kZWxldGUuc3Vic3RyaW5nKGNvbW1vbmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZhY3RvciBvdXQgYW55IGNvbW1vbiBzdWZmaXhpZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbW9ubGVuZ3RoID0gdGhpcy5kaWZmX2NvbW1vblN1ZmZpeCh0ZXh0X2luc2VydCwgdGV4dF9kZWxldGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21tb25sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlmZnNbcG9pbnRlcl1bMV0gPSB0ZXh0X2luc2VydC5zdWJzdHJpbmcodGV4dF9pbnNlcnQubGVuZ3RoIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1vbmxlbmd0aCkgKyBkaWZmc1twb2ludGVyXVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dF9pbnNlcnQgPSB0ZXh0X2luc2VydC5zdWJzdHJpbmcoMCwgdGV4dF9pbnNlcnQubGVuZ3RoIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1vbmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRfZGVsZXRlID0gdGV4dF9kZWxldGUuc3Vic3RyaW5nKDAsIHRleHRfZGVsZXRlLmxlbmd0aCAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21tb25sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlbGV0ZSB0aGUgb2ZmZW5kaW5nIHJlY29yZHMgYW5kIGFkZCB0aGUgbWVyZ2VkIG9uZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY291bnRfZGVsZXRlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIgLSBjb3VudF9pbnNlcnQsIGNvdW50X2RlbGV0ZSArIGNvdW50X2luc2VydCwgWzEgLyogSW5zZXJ0ICovLCB0ZXh0X2luc2VydF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY291bnRfaW5zZXJ0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIgLSBjb3VudF9kZWxldGUsIGNvdW50X2RlbGV0ZSArIGNvdW50X2luc2VydCwgWy0xIC8qIERlbGV0ZSAqLywgdGV4dF9kZWxldGVdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyIC0gY291bnRfZGVsZXRlIC0gY291bnRfaW5zZXJ0LCBjb3VudF9kZWxldGUgKyBjb3VudF9pbnNlcnQsIFstMSAvKiBEZWxldGUgKi8sIHRleHRfZGVsZXRlXSwgWzEgLyogSW5zZXJ0ICovLCB0ZXh0X2luc2VydF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRlciA9IHBvaW50ZXIgLSBjb3VudF9kZWxldGUgLSBjb3VudF9pbnNlcnQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjb3VudF9kZWxldGUgPyAxIDogMCkgKyAoY291bnRfaW5zZXJ0ID8gMSA6IDApICsgMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwb2ludGVyICE9PSAwICYmIGRpZmZzW3BvaW50ZXIgLSAxXVswXSA9PSAwIC8qIEVxdWFsICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNZXJnZSB0aGlzIGVxdWFsaXR5IHdpdGggdGhlIHByZXZpb3VzIG9uZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZmZzW3BvaW50ZXIgLSAxXVsxXSArPSBkaWZmc1twb2ludGVyXVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ZXIrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb3VudF9pbnNlcnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICBjb3VudF9kZWxldGUgPSAwO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0X2RlbGV0ZSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0X2luc2VydCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlmZnNbZGlmZnMubGVuZ3RoIC0gMV1bMV0gPT09ICcnKSB7XG4gICAgICAgICAgICBkaWZmcy5wb3AoKTsgLy8gUmVtb3ZlIHRoZSBkdW1teSBlbnRyeSBhdCB0aGUgZW5kLlxuICAgICAgICB9XG4gICAgICAgIC8vIFNlY29uZCBwYXNzOiBsb29rIGZvciBzaW5nbGUgZWRpdHMgc3Vycm91bmRlZCBvbiBib3RoIHNpZGVzIGJ5IGVxdWFsaXRpZXNcbiAgICAgICAgLy8gd2hpY2ggY2FuIGJlIHNoaWZ0ZWQgc2lkZXdheXMgdG8gZWxpbWluYXRlIGFuIGVxdWFsaXR5LlxuICAgICAgICAvLyBlLmc6IEE8aW5zPkJBPC9pbnM+QyAtPiA8aW5zPkFCPC9pbnM+QUNcbiAgICAgICAgdmFyIGNoYW5nZXMgPSBmYWxzZTtcbiAgICAgICAgcG9pbnRlciA9IDE7XG4gICAgICAgIC8vIEludGVudGlvbmFsbHkgaWdub3JlIHRoZSBmaXJzdCBhbmQgbGFzdCBlbGVtZW50IChkb24ndCBuZWVkIGNoZWNraW5nKS5cbiAgICAgICAgd2hpbGUgKHBvaW50ZXIgPCBkaWZmcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBpZiAoZGlmZnNbcG9pbnRlciAtIDFdWzBdID09IDAgLyogRXF1YWwgKi8gJiZcbiAgICAgICAgICAgICAgICBkaWZmc1twb2ludGVyICsgMV1bMF0gPT0gMCAvKiBFcXVhbCAqLykge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBzaW5nbGUgZWRpdCBzdXJyb3VuZGVkIGJ5IGVxdWFsaXRpZXMuXG4gICAgICAgICAgICAgICAgaWYgKGRpZmZzW3BvaW50ZXJdWzFdLnN1YnN0cmluZyhkaWZmc1twb2ludGVyXVsxXS5sZW5ndGggLVxuICAgICAgICAgICAgICAgICAgICBkaWZmc1twb2ludGVyIC0gMV1bMV0ubGVuZ3RoKSA9PSBkaWZmc1twb2ludGVyIC0gMV1bMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2hpZnQgdGhlIGVkaXQgb3ZlciB0aGUgcHJldmlvdXMgZXF1YWxpdHkuXG4gICAgICAgICAgICAgICAgICAgIGRpZmZzW3BvaW50ZXJdWzFdID0gZGlmZnNbcG9pbnRlciAtIDFdWzFdICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZmZzW3BvaW50ZXJdWzFdLnN1YnN0cmluZygwLCBkaWZmc1twb2ludGVyXVsxXS5sZW5ndGggLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpZmZzW3BvaW50ZXIgLSAxXVsxXS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBkaWZmc1twb2ludGVyICsgMV1bMV0gPSBkaWZmc1twb2ludGVyIC0gMV1bMV0gKyBkaWZmc1twb2ludGVyICsgMV1bMV07XG4gICAgICAgICAgICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyIC0gMSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChkaWZmc1twb2ludGVyXVsxXS5zdWJzdHJpbmcoMCwgZGlmZnNbcG9pbnRlciArIDFdWzFdLmxlbmd0aCkgPT1cbiAgICAgICAgICAgICAgICAgICAgZGlmZnNbcG9pbnRlciArIDFdWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNoaWZ0IHRoZSBlZGl0IG92ZXIgdGhlIG5leHQgZXF1YWxpdHkuXG4gICAgICAgICAgICAgICAgICAgIGRpZmZzW3BvaW50ZXIgLSAxXVsxXSArPSBkaWZmc1twb2ludGVyICsgMV1bMV07XG4gICAgICAgICAgICAgICAgICAgIGRpZmZzW3BvaW50ZXJdWzFdID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZmZzW3BvaW50ZXJdWzFdLnN1YnN0cmluZyhkaWZmc1twb2ludGVyICsgMV1bMV0ubGVuZ3RoKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlmZnNbcG9pbnRlciArIDFdWzFdO1xuICAgICAgICAgICAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciArIDEsIDEpO1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb2ludGVyKys7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgc2hpZnRzIHdlcmUgbWFkZSwgdGhlIGRpZmYgbmVlZHMgcmVvcmRlcmluZyBhbmQgYW5vdGhlciBzaGlmdCBzd2VlcC5cbiAgICAgICAgaWYgKGNoYW5nZXMpIHtcbiAgICAgICAgICAgIHRoaXMuZGlmZl9jbGVhbnVwTWVyZ2UoZGlmZnMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICA7XG4gICAgLyoqXG4gICAgICogbG9jIGlzIGEgbG9jYXRpb24gaW4gdGV4dDEsIGNvbXB1dGUgYW5kIHJldHVybiB0aGUgZXF1aXZhbGVudCBsb2NhdGlvbiBpblxuICAgICAqIHRleHQyLlxuICAgICAqIGUuZy4gJ1RoZSBjYXQnIHZzICdUaGUgYmlnIGNhdCcsIDEtPjEsIDUtPjhcbiAgICAgKiBAcGFyYW0geyFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2guRGlmZj59IGRpZmZzIEFycmF5IG9mIGRpZmYgdHVwbGVzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsb2MgTG9jYXRpb24gd2l0aGluIHRleHQxLlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gTG9jYXRpb24gd2l0aGluIHRleHQyLlxuICAgICAqL1xuICAgIERpZmZNYXRjaFBhdGNoLnByb3RvdHlwZS5kaWZmX3hJbmRleCA9IGZ1bmN0aW9uIChkaWZmcywgbG9jKSB7XG4gICAgICAgIHZhciBjaGFyczEgPSAwO1xuICAgICAgICB2YXIgY2hhcnMyID0gMDtcbiAgICAgICAgdmFyIGxhc3RfY2hhcnMxID0gMDtcbiAgICAgICAgdmFyIGxhc3RfY2hhcnMyID0gMDtcbiAgICAgICAgdmFyIHg7XG4gICAgICAgIGZvciAoeCA9IDA7IHggPCBkaWZmcy5sZW5ndGg7IHgrKykge1xuICAgICAgICAgICAgaWYgKGRpZmZzW3hdWzBdICE9PSAxIC8qIEluc2VydCAqLykge1xuICAgICAgICAgICAgICAgIGNoYXJzMSArPSBkaWZmc1t4XVsxXS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGlmZnNbeF1bMF0gIT09IC0xIC8qIERlbGV0ZSAqLykge1xuICAgICAgICAgICAgICAgIGNoYXJzMiArPSBkaWZmc1t4XVsxXS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hhcnMxID4gbG9jKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0X2NoYXJzMSA9IGNoYXJzMTtcbiAgICAgICAgICAgIGxhc3RfY2hhcnMyID0gY2hhcnMyO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdhcyB0aGUgbG9jYXRpb24gd2FzIGRlbGV0ZWQ/XG4gICAgICAgIGlmIChkaWZmcy5sZW5ndGggIT0geCAmJiBkaWZmc1t4XVswXSA9PT0gLTEgLyogRGVsZXRlICovKSB7XG4gICAgICAgICAgICByZXR1cm4gbGFzdF9jaGFyczI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSByZW1haW5pbmcgY2hhcmFjdGVyIGxlbmd0aC5cbiAgICAgICAgcmV0dXJuIGxhc3RfY2hhcnMyICsgKGxvYyAtIGxhc3RfY2hhcnMxKTtcbiAgICB9O1xuICAgIDtcbiAgICAvKipcbiAgICAgKiBDb21wdXRlIGFuZCByZXR1cm4gdGhlIHNvdXJjZSB0ZXh0IChhbGwgZXF1YWxpdGllcyBhbmQgZGVsZXRpb25zKS5cbiAgICAgKiBAcGFyYW0geyFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2guRGlmZj59IGRpZmZzIEFycmF5IG9mIGRpZmYgdHVwbGVzLlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gU291cmNlIHRleHQuXG4gICAgICovXG4gICAgRGlmZk1hdGNoUGF0Y2gucHJvdG90eXBlLmRpZmZfdGV4dDEgPSBmdW5jdGlvbiAoZGlmZnMpIHtcbiAgICAgICAgdmFyIHRleHQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBkaWZmcy5sZW5ndGg7IHgrKykge1xuICAgICAgICAgICAgaWYgKGRpZmZzW3hdWzBdICE9PSAxIC8qIEluc2VydCAqLykge1xuICAgICAgICAgICAgICAgIHRleHRbeF0gPSBkaWZmc1t4XVsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGV4dC5qb2luKCcnKTtcbiAgICB9O1xuICAgIDtcbiAgICAvKipcbiAgICAgKiBDb21wdXRlIGFuZCByZXR1cm4gdGhlIGRlc3RpbmF0aW9uIHRleHQgKGFsbCBlcXVhbGl0aWVzIGFuZCBpbnNlcnRpb25zKS5cbiAgICAgKiBAcGFyYW0geyFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2guRGlmZj59IGRpZmZzIEFycmF5IG9mIGRpZmYgdHVwbGVzLlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gRGVzdGluYXRpb24gdGV4dC5cbiAgICAgKi9cbiAgICBEaWZmTWF0Y2hQYXRjaC5wcm90b3R5cGUuZGlmZl90ZXh0MiA9IGZ1bmN0aW9uIChkaWZmcykge1xuICAgICAgICB2YXIgdGV4dCA9IFtdO1xuICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IGRpZmZzLmxlbmd0aDsgeCsrKSB7XG4gICAgICAgICAgICBpZiAoZGlmZnNbeF1bMF0gIT09IC0xIC8qIERlbGV0ZSAqLykge1xuICAgICAgICAgICAgICAgIHRleHRbeF0gPSBkaWZmc1t4XVsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGV4dC5qb2luKCcnKTtcbiAgICB9O1xuICAgIDtcbiAgICAvKipcbiAgICAgKiBDb21wdXRlIHRoZSBMZXZlbnNodGVpbiBkaXN0YW5jZTsgdGhlIG51bWJlciBvZiBpbnNlcnRlZCwgZGVsZXRlZCBvclxuICAgICAqIHN1YnN0aXR1dGVkIGNoYXJhY3RlcnMuXG4gICAgICogQHBhcmFtIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLkRpZmY+fSBkaWZmcyBBcnJheSBvZiBkaWZmIHR1cGxlcy5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IE51bWJlciBvZiBjaGFuZ2VzLlxuICAgICAqL1xuICAgIERpZmZNYXRjaFBhdGNoLnByb3RvdHlwZS5kaWZmX2xldmVuc2h0ZWluID0gZnVuY3Rpb24gKGRpZmZzKSB7XG4gICAgICAgIHZhciBsZXZlbnNodGVpbiA9IDA7XG4gICAgICAgIHZhciBpbnNlcnRpb25zID0gMDtcbiAgICAgICAgdmFyIGRlbGV0aW9ucyA9IDA7XG4gICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgZGlmZnMubGVuZ3RoOyB4KyspIHtcbiAgICAgICAgICAgIHZhciBvcCA9IGRpZmZzW3hdWzBdO1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBkaWZmc1t4XVsxXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3ApIHtcbiAgICAgICAgICAgICAgICBjYXNlIDEgLyogSW5zZXJ0ICovOlxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRpb25zICs9IGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC0xIC8qIERlbGV0ZSAqLzpcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRpb25zICs9IGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDAgLyogRXF1YWwgKi86XG4gICAgICAgICAgICAgICAgICAgIC8vIEEgZGVsZXRpb24gYW5kIGFuIGluc2VydGlvbiBpcyBvbmUgc3Vic3RpdHV0aW9uLlxuICAgICAgICAgICAgICAgICAgICBsZXZlbnNodGVpbiArPSBNYXRoLm1heChpbnNlcnRpb25zLCBkZWxldGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBpbnNlcnRpb25zID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRpb25zID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV2ZW5zaHRlaW4gKz0gTWF0aC5tYXgoaW5zZXJ0aW9ucywgZGVsZXRpb25zKTtcbiAgICAgICAgcmV0dXJuIGxldmVuc2h0ZWluO1xuICAgIH07XG4gICAgO1xuICAgIC8qKlxuICAgICAqIENydXNoIHRoZSBkaWZmIGludG8gYW4gZW5jb2RlZCBzdHJpbmcgd2hpY2ggZGVzY3JpYmVzIHRoZSBvcGVyYXRpb25zXG4gICAgICogcmVxdWlyZWQgdG8gdHJhbnNmb3JtIHRleHQxIGludG8gdGV4dDIuXG4gICAgICogRS5nLiA9M1xcdC0yXFx0K2luZyAgLT4gS2VlcCAzIGNoYXJzLCBkZWxldGUgMiBjaGFycywgaW5zZXJ0ICdpbmcnLlxuICAgICAqIE9wZXJhdGlvbnMgYXJlIHRhYi1zZXBhcmF0ZWQuICBJbnNlcnRlZCB0ZXh0IGlzIGVzY2FwZWQgdXNpbmcgJXh4IG5vdGF0aW9uLlxuICAgICAqIEBwYXJhbSB7IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5EaWZmPn0gZGlmZnMgQXJyYXkgb2YgZGlmZiB0dXBsZXMuXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBEZWx0YSB0ZXh0LlxuICAgICAqL1xuICAgIERpZmZNYXRjaFBhdGNoLnByb3RvdHlwZS5kaWZmX3RvRGVsdGEgPSBmdW5jdGlvbiAoZGlmZnMpIHtcbiAgICAgICAgdmFyIHRleHQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBkaWZmcy5sZW5ndGg7IHgrKykge1xuICAgICAgICAgICAgc3dpdGNoIChkaWZmc1t4XVswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMSAvKiBJbnNlcnQgKi86XG4gICAgICAgICAgICAgICAgICAgIHRleHRbeF0gPSAnKycgKyBlbmNvZGVVUkkoZGlmZnNbeF1bMV0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC0xIC8qIERlbGV0ZSAqLzpcbiAgICAgICAgICAgICAgICAgICAgdGV4dFt4XSA9ICctJyArIGRpZmZzW3hdWzFdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAwIC8qIEVxdWFsICovOlxuICAgICAgICAgICAgICAgICAgICB0ZXh0W3hdID0gJz0nICsgZGlmZnNbeF1bMV0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGV4dC5qb2luKCdcXHQnKS5yZXBsYWNlKC8lMjAvZywgJyAnKTtcbiAgICB9O1xuICAgIDtcbiAgICAvKipcbiAgICAgKiBHaXZlbiB0aGUgb3JpZ2luYWwgdGV4dDEsIGFuZCBhbiBlbmNvZGVkIHN0cmluZyB3aGljaCBkZXNjcmliZXMgdGhlXG4gICAgICogb3BlcmF0aW9ucyByZXF1aXJlZCB0byB0cmFuc2Zvcm0gdGV4dDEgaW50byB0ZXh0MiwgY29tcHV0ZSB0aGUgZnVsbCBkaWZmLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MSBTb3VyY2Ugc3RyaW5nIGZvciB0aGUgZGlmZi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGVsdGEgRGVsdGEgdGV4dC5cbiAgICAgKiBAcmV0dXJuIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLkRpZmY+fSBBcnJheSBvZiBkaWZmIHR1cGxlcy5cbiAgICAgKiBAdGhyb3dzIHshRXJyb3J9IElmIGludmFsaWQgaW5wdXQuXG4gICAgICovXG4gICAgRGlmZk1hdGNoUGF0Y2gucHJvdG90eXBlLmRpZmZfZnJvbURlbHRhID0gZnVuY3Rpb24gKHRleHQxLCBkZWx0YSkge1xuICAgICAgICB2YXIgZGlmZnMgPSBbXTtcbiAgICAgICAgdmFyIGRpZmZzTGVuZ3RoID0gMDsgLy8gS2VlcGluZyBvdXIgb3duIGxlbmd0aCBjb25zdCBpcyBmYXN0ZXIgaW4gSlMuXG4gICAgICAgIHZhciBwb2ludGVyID0gMDsgLy8gQ3Vyc29yIGluIHRleHQxXG4gICAgICAgIHZhciB0b2tlbnMgPSBkZWx0YS5zcGxpdCgvXFx0L2cpO1xuICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHRva2Vucy5sZW5ndGg7IHgrKykge1xuICAgICAgICAgICAgLy8gRWFjaCB0b2tlbiBiZWdpbnMgd2l0aCBhIG9uZSBjaGFyYWN0ZXIgcGFyYW1ldGVyIHdoaWNoIHNwZWNpZmllcyB0aGVcbiAgICAgICAgICAgIC8vIG9wZXJhdGlvbiBvZiB0aGlzIHRva2VuIChkZWxldGUsIGluc2VydCwgZXF1YWxpdHkpLlxuICAgICAgICAgICAgdmFyIHBhcmFtID0gdG9rZW5zW3hdLnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgIHN3aXRjaCAodG9rZW5zW3hdLmNoYXJBdCgwKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJysnOlxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlmZnNbZGlmZnNMZW5ndGgrK10gPSBbMSAvKiBJbnNlcnQgKi8sIGRlY29kZVVSSShwYXJhbSldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFsZm9ybWVkIFVSSSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBlc2NhcGUgaW4gZGlmZl9mcm9tRGVsdGE6ICcgKyBwYXJhbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgICAgICAgLy8gRmFsbCB0aHJvdWdoLlxuICAgICAgICAgICAgICAgIGNhc2UgJz0nOlxuICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IHBhcnNlSW50KHBhcmFtLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc05hTihuKSB8fCBuIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG51bWJlciBpbiBkaWZmX2Zyb21EZWx0YTogJyArIHBhcmFtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IHRleHQxLnN1YnN0cmluZyhwb2ludGVyLCBwb2ludGVyICs9IG4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW5zW3hdLmNoYXJBdCgwKSA9PSAnPScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZmZzW2RpZmZzTGVuZ3RoKytdID0gWzAgLyogRXF1YWwgKi8sIHRleHRdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlmZnNbZGlmZnNMZW5ndGgrK10gPSBbLTEgLyogRGVsZXRlICovLCB0ZXh0XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAvLyBCbGFuayB0b2tlbnMgYXJlIG9rIChmcm9tIGEgdHJhaWxpbmcgXFx0KS5cbiAgICAgICAgICAgICAgICAgICAgLy8gQW55dGhpbmcgZWxzZSBpcyBhbiBlcnJvci5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2Vuc1t4XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGRpZmYgb3BlcmF0aW9uIGluIGRpZmZfZnJvbURlbHRhOiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnNbeF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvaW50ZXIgIT0gdGV4dDEubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlbHRhIGxlbmd0aCAoJyArIHBvaW50ZXIgK1xuICAgICAgICAgICAgICAgICcpIGRvZXMgbm90IGVxdWFsIHNvdXJjZSB0ZXh0IGxlbmd0aCAoJyArIHRleHQxLmxlbmd0aCArICcpLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaWZmcztcbiAgICB9O1xuICAgIDtcbiAgICAvKipcbiAgICAgKiBMb2NhdGUgdGhlIGJlc3QgaW5zdGFuY2Ugb2YgJ3BhdHRlcm4nIGluICd0ZXh0JyBuZWFyICdsb2MnLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRoZSB0ZXh0IHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0dGVybiBUaGUgcGF0dGVybiB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsb2MgVGhlIGxvY2F0aW9uIHRvIHNlYXJjaCBhcm91bmQuXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBCZXN0IG1hdGNoIGluZGV4IG9yIC0xLlxuICAgICAqL1xuICAgIERpZmZNYXRjaFBhdGNoLnByb3RvdHlwZS5tYXRjaF9tYWluID0gZnVuY3Rpb24gKHRleHQsIHBhdHRlcm4sIGxvYykge1xuICAgICAgICAvLyBDaGVjayBmb3IgbnVsbCBpbnB1dHMuXG4gICAgICAgIGlmICh0ZXh0ID09IG51bGwgfHwgcGF0dGVybiA9PSBudWxsIHx8IGxvYyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ051bGwgaW5wdXQuIChtYXRjaF9tYWluKScpO1xuICAgICAgICB9XG4gICAgICAgIGxvYyA9IE1hdGgubWF4KDAsIE1hdGgubWluKGxvYywgdGV4dC5sZW5ndGgpKTtcbiAgICAgICAgaWYgKHRleHQgPT0gcGF0dGVybikge1xuICAgICAgICAgICAgLy8gU2hvcnRjdXQgKHBvdGVudGlhbGx5IG5vdCBndWFyYW50ZWVkIGJ5IHRoZSBhbGdvcml0aG0pXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIE5vdGhpbmcgdG8gbWF0Y2guXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGV4dC5zdWJzdHJpbmcobG9jLCBsb2MgKyBwYXR0ZXJuLmxlbmd0aCkgPT0gcGF0dGVybikge1xuICAgICAgICAgICAgLy8gUGVyZmVjdCBtYXRjaCBhdCB0aGUgcGVyZmVjdCBzcG90ISAgKEluY2x1ZGVzIGNhc2Ugb2YgbnVsbCBwYXR0ZXJuKVxuICAgICAgICAgICAgcmV0dXJuIGxvYztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIERvIGEgZnV6enkgY29tcGFyZS5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hdGNoX2JpdGFwXyh0ZXh0LCBwYXR0ZXJuLCBsb2MpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICA7XG4gICAgLyoqXG4gICAgICogTG9jYXRlIHRoZSBiZXN0IGluc3RhbmNlIG9mICdwYXR0ZXJuJyBpbiAndGV4dCcgbmVhciAnbG9jJyB1c2luZyB0aGVcbiAgICAgKiBCaXRhcCBhbGdvcml0aG0uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGhlIHRleHQgdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXR0ZXJuIFRoZSBwYXR0ZXJuIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxvYyBUaGUgbG9jYXRpb24gdG8gc2VhcmNoIGFyb3VuZC5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IEJlc3QgbWF0Y2ggaW5kZXggb3IgLTEuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBEaWZmTWF0Y2hQYXRjaC5wcm90b3R5cGUubWF0Y2hfYml0YXBfID0gZnVuY3Rpb24gKHRleHQsIHBhdHRlcm4sIGxvYykge1xuICAgICAgICBpZiAocGF0dGVybi5sZW5ndGggPiB0aGlzLk1hdGNoX01heEJpdHMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUGF0dGVybiB0b28gbG9uZyBmb3IgdGhpcyBicm93c2VyLicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEluaXRpYWxpc2UgdGhlIGFscGhhYmV0LlxuICAgICAgICB2YXIgcyA9IHRoaXMubWF0Y2hfYWxwaGFiZXRfKHBhdHRlcm4pO1xuICAgICAgICB2YXIgZG1wID0gdGhpczsgLy8gJ3RoaXMnIGJlY29tZXMgJ3dpbmRvdycgaW4gYSBjbG9zdXJlLlxuICAgICAgICAvKipcbiAgICAgICAgICogQ29tcHV0ZSBhbmQgcmV0dXJuIHRoZSBzY29yZSBmb3IgYSBtYXRjaCB3aXRoIGUgZXJyb3JzIGFuZCB4IGxvY2F0aW9uLlxuICAgICAgICAgKiBBY2Nlc3NlcyBsb2MgYW5kIHBhdHRlcm4gdGhyb3VnaCBiZWluZyBhIGNsb3N1cmUuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlIE51bWJlciBvZiBlcnJvcnMgaW4gbWF0Y2guXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IExvY2F0aW9uIG9mIG1hdGNoLlxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IE92ZXJhbGwgc2NvcmUgZm9yIG1hdGNoICgwLjAgPSBnb29kLCAxLjAgPSBiYWQpLlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gbWF0Y2hfYml0YXBTY29yZV8oZSwgeCkge1xuICAgICAgICAgICAgdmFyIGFjY3VyYWN5ID0gZSAvIHBhdHRlcm4ubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIHByb3hpbWl0eSA9IE1hdGguYWJzKGxvYyAtIHgpO1xuICAgICAgICAgICAgaWYgKCFkbXAuTWF0Y2hfRGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAvLyBEb2RnZSBkaXZpZGUgYnkgemVybyBlcnJvci5cbiAgICAgICAgICAgICAgICByZXR1cm4gcHJveGltaXR5ID8gMS4wIDogYWNjdXJhY3k7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWNjdXJhY3kgKyAocHJveGltaXR5IC8gZG1wLk1hdGNoX0Rpc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBIaWdoZXN0IHNjb3JlIGJleW9uZCB3aGljaCB3ZSBnaXZlIHVwLlxuICAgICAgICB2YXIgc2NvcmVfdGhyZXNob2xkID0gdGhpcy5NYXRjaF9UaHJlc2hvbGQ7XG4gICAgICAgIC8vIElzIHRoZXJlIGEgbmVhcmJ5IGV4YWN0IG1hdGNoPyAoc3BlZWR1cClcbiAgICAgICAgdmFyIGJlc3RfbG9jID0gdGV4dC5pbmRleE9mKHBhdHRlcm4sIGxvYyk7XG4gICAgICAgIGlmIChiZXN0X2xvYyAhPSAtMSkge1xuICAgICAgICAgICAgc2NvcmVfdGhyZXNob2xkID0gTWF0aC5taW4obWF0Y2hfYml0YXBTY29yZV8oMCwgYmVzdF9sb2MpLCBzY29yZV90aHJlc2hvbGQpO1xuICAgICAgICAgICAgLy8gV2hhdCBhYm91dCBpbiB0aGUgb3RoZXIgZGlyZWN0aW9uPyAoc3BlZWR1cClcbiAgICAgICAgICAgIGJlc3RfbG9jID0gdGV4dC5sYXN0SW5kZXhPZihwYXR0ZXJuLCBsb2MgKyBwYXR0ZXJuLmxlbmd0aCk7XG4gICAgICAgICAgICBpZiAoYmVzdF9sb2MgIT0gLTEpIHtcbiAgICAgICAgICAgICAgICBzY29yZV90aHJlc2hvbGQgPVxuICAgICAgICAgICAgICAgICAgICBNYXRoLm1pbihtYXRjaF9iaXRhcFNjb3JlXygwLCBiZXN0X2xvYyksIHNjb3JlX3RocmVzaG9sZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW5pdGlhbGlzZSB0aGUgYml0IGFycmF5cy5cbiAgICAgICAgdmFyIG1hdGNobWFzayA9IDEgPDwgKHBhdHRlcm4ubGVuZ3RoIC0gMSk7XG4gICAgICAgIGJlc3RfbG9jID0gLTE7XG4gICAgICAgIHZhciBiaW5fbWluLCBiaW5fbWlkO1xuICAgICAgICB2YXIgYmluX21heCA9IHBhdHRlcm4ubGVuZ3RoICsgdGV4dC5sZW5ndGg7XG4gICAgICAgIHZhciBsYXN0X3JkO1xuICAgICAgICBmb3IgKHZhciBkID0gMDsgZCA8IHBhdHRlcm4ubGVuZ3RoOyBkKyspIHtcbiAgICAgICAgICAgIC8vIFNjYW4gZm9yIHRoZSBiZXN0IG1hdGNoOyBlYWNoIGl0ZXJhdGlvbiBhbGxvd3MgZm9yIG9uZSBtb3JlIGVycm9yLlxuICAgICAgICAgICAgLy8gUnVuIGEgYmluYXJ5IHNlYXJjaCB0byBkZXRlcm1pbmUgaG93IGZhciBmcm9tICdsb2MnIHdlIGNhbiBzdHJheSBhdCB0aGlzXG4gICAgICAgICAgICAvLyBlcnJvciBsZXZlbC5cbiAgICAgICAgICAgIGJpbl9taW4gPSAwO1xuICAgICAgICAgICAgYmluX21pZCA9IGJpbl9tYXg7XG4gICAgICAgICAgICB3aGlsZSAoYmluX21pbiA8IGJpbl9taWQpIHtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hfYml0YXBTY29yZV8oZCwgbG9jICsgYmluX21pZCkgPD0gc2NvcmVfdGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgICAgIGJpbl9taW4gPSBiaW5fbWlkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYmluX21heCA9IGJpbl9taWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJpbl9taWQgPSBNYXRoLmZsb29yKChiaW5fbWF4IC0gYmluX21pbikgLyAyICsgYmluX21pbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVc2UgdGhlIHJlc3VsdCBmcm9tIHRoaXMgaXRlcmF0aW9uIGFzIHRoZSBtYXhpbXVtIGZvciB0aGUgbmV4dC5cbiAgICAgICAgICAgIGJpbl9tYXggPSBiaW5fbWlkO1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gTWF0aC5tYXgoMSwgbG9jIC0gYmluX21pZCArIDEpO1xuICAgICAgICAgICAgdmFyIGZpbmlzaCA9IE1hdGgubWluKGxvYyArIGJpbl9taWQsIHRleHQubGVuZ3RoKSArIHBhdHRlcm4ubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIHJkID0gQXJyYXkoZmluaXNoICsgMik7XG4gICAgICAgICAgICByZFtmaW5pc2ggKyAxXSA9ICgxIDw8IGQpIC0gMTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSBmaW5pc2g7IGogPj0gc3RhcnQ7IGotLSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBhbHBoYWJldCAocykgaXMgYSBzcGFyc2UgaGFzaCwgc28gdGhlIGZvbGxvd2luZyBsaW5lIGdlbmVyYXRlc1xuICAgICAgICAgICAgICAgIC8vIHdhcm5pbmdzLlxuICAgICAgICAgICAgICAgIHZhciBjaGFyTWF0Y2ggPSBzW3RleHQuY2hhckF0KGogLSAxKV07XG4gICAgICAgICAgICAgICAgaWYgKGQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmRbal0gPSAoKHJkW2ogKyAxXSA8PCAxKSB8IDEpICYgY2hhck1hdGNoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmRbal0gPSAoKChyZFtqICsgMV0gPDwgMSkgfCAxKSAmIGNoYXJNYXRjaCkgfFxuICAgICAgICAgICAgICAgICAgICAgICAgKCgobGFzdF9yZFtqICsgMV0gfCBsYXN0X3JkW2pdKSA8PCAxKSB8IDEpIHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RfcmRbaiArIDFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmRbal0gJiBtYXRjaG1hc2spIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjb3JlID0gbWF0Y2hfYml0YXBTY29yZV8oZCwgaiAtIDEpO1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIG1hdGNoIHdpbGwgYWxtb3N0IGNlcnRhaW5seSBiZSBiZXR0ZXIgdGhhbiBhbnkgZXhpc3RpbmcgbWF0Y2guXG4gICAgICAgICAgICAgICAgICAgIC8vIEJ1dCBjaGVjayBhbnl3YXkuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzY29yZSA8PSBzY29yZV90aHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRvbGQgeW91IHNvLlxuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcmVfdGhyZXNob2xkID0gc2NvcmU7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0X2xvYyA9IGogLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJlc3RfbG9jID4gbG9jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiBwYXNzaW5nIGxvYywgZG9uJ3QgZXhjZWVkIG91ciBjdXJyZW50IGRpc3RhbmNlIGZyb20gbG9jLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gTWF0aC5tYXgoMSwgMiAqIGxvYyAtIGJlc3RfbG9jKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFscmVhZHkgcGFzc2VkIGxvYywgZG93bmhpbGwgZnJvbSBoZXJlIG9uIGluLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm8gaG9wZSBmb3IgYSAoYmV0dGVyKSBtYXRjaCBhdCBncmVhdGVyIGVycm9yIGxldmVscy5cbiAgICAgICAgICAgIGlmIChtYXRjaF9iaXRhcFNjb3JlXyhkICsgMSwgbG9jKSA+IHNjb3JlX3RocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdF9yZCA9IHJkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiZXN0X2xvYztcbiAgICB9O1xuICAgIDtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXNlIHRoZSBhbHBoYWJldCBmb3IgdGhlIEJpdGFwIGFsZ29yaXRobS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0dGVybiBUaGUgdGV4dCB0byBlbmNvZGUuXG4gICAgICogQHJldHVybiB7IU9iamVjdH0gSGFzaCBvZiBjaGFyYWN0ZXIgbG9jYXRpb25zLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgRGlmZk1hdGNoUGF0Y2gucHJvdG90eXBlLm1hdGNoX2FscGhhYmV0XyA9IGZ1bmN0aW9uIChwYXR0ZXJuKSB7XG4gICAgICAgIHZhciBzID0ge307XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0dGVybi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc1twYXR0ZXJuLmNoYXJBdChpKV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0dGVybi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc1twYXR0ZXJuLmNoYXJBdChpKV0gfD0gMSA8PCAocGF0dGVybi5sZW5ndGggLSBpIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfTtcbiAgICA7XG4gICAgLyoqXG4gICAgICogSW5jcmVhc2UgdGhlIGNvbnRleHQgdW50aWwgaXQgaXMgdW5pcXVlLFxuICAgICAqIGJ1dCBkb24ndCBsZXQgdGhlIHBhdHRlcm4gZXhwYW5kIGJleW9uZCBNYXRjaF9NYXhCaXRzLlxuICAgICAqIEBwYXJhbSB7IWRpZmZfbWF0Y2hfcGF0Y2gucGF0Y2hfb2JqfSBwYXRjaCBUaGUgcGF0Y2ggdG8gZ3Jvdy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBTb3VyY2UgdGV4dC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIERpZmZNYXRjaFBhdGNoLnByb3RvdHlwZS5wYXRjaF9hZGRDb250ZXh0XyA9IGZ1bmN0aW9uIChwYXRjaCwgdGV4dCkge1xuICAgICAgICBpZiAodGV4dC5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXR0ZXJuID0gdGV4dC5zdWJzdHJpbmcocGF0Y2guc3RhcnQyLCBwYXRjaC5zdGFydDIgKyBwYXRjaC5sZW5ndGgxKTtcbiAgICAgICAgdmFyIHBhZGRpbmcgPSAwO1xuICAgICAgICAvLyBMb29rIGZvciB0aGUgZmlyc3QgYW5kIGxhc3QgbWF0Y2hlcyBvZiBwYXR0ZXJuIGluIHRleHQuICBJZiB0d28gZGlmZmVyZW50XG4gICAgICAgIC8vIG1hdGNoZXMgYXJlIGZvdW5kLCBpbmNyZWFzZSB0aGUgcGF0dGVybiBsZW5ndGguXG4gICAgICAgIHdoaWxlICh0ZXh0LmluZGV4T2YocGF0dGVybikgIT0gdGV4dC5sYXN0SW5kZXhPZihwYXR0ZXJuKSAmJlxuICAgICAgICAgICAgcGF0dGVybi5sZW5ndGggPCB0aGlzLk1hdGNoX01heEJpdHMgLSB0aGlzLlBhdGNoX01hcmdpbiAtXG4gICAgICAgICAgICAgICAgdGhpcy5QYXRjaF9NYXJnaW4pIHtcbiAgICAgICAgICAgIHBhZGRpbmcgKz0gdGhpcy5QYXRjaF9NYXJnaW47XG4gICAgICAgICAgICBwYXR0ZXJuID0gdGV4dC5zdWJzdHJpbmcocGF0Y2guc3RhcnQyIC0gcGFkZGluZywgcGF0Y2guc3RhcnQyICsgcGF0Y2gubGVuZ3RoMSArIHBhZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCBvbmUgY2h1bmsgZm9yIGdvb2QgbHVjay5cbiAgICAgICAgcGFkZGluZyArPSB0aGlzLlBhdGNoX01hcmdpbjtcbiAgICAgICAgLy8gQWRkIHRoZSBwcmVmaXguXG4gICAgICAgIHZhciBwcmVmaXggPSB0ZXh0LnN1YnN0cmluZyhwYXRjaC5zdGFydDIgLSBwYWRkaW5nLCBwYXRjaC5zdGFydDIpO1xuICAgICAgICBpZiAocHJlZml4KSB7XG4gICAgICAgICAgICBwYXRjaC5kaWZmcy51bnNoaWZ0KFswIC8qIEVxdWFsICovLCBwcmVmaXhdKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIHN1ZmZpeC5cbiAgICAgICAgdmFyIHN1ZmZpeCA9IHRleHQuc3Vic3RyaW5nKHBhdGNoLnN0YXJ0MiArIHBhdGNoLmxlbmd0aDEsIHBhdGNoLnN0YXJ0MiArIHBhdGNoLmxlbmd0aDEgKyBwYWRkaW5nKTtcbiAgICAgICAgaWYgKHN1ZmZpeCkge1xuICAgICAgICAgICAgcGF0Y2guZGlmZnMucHVzaChbMCAvKiBFcXVhbCAqLywgc3VmZml4XSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUm9sbCBiYWNrIHRoZSBzdGFydCBwb2ludHMuXG4gICAgICAgIHBhdGNoLnN0YXJ0MSAtPSBwcmVmaXgubGVuZ3RoO1xuICAgICAgICBwYXRjaC5zdGFydDIgLT0gcHJlZml4Lmxlbmd0aDtcbiAgICAgICAgLy8gRXh0ZW5kIHRoZSBsZW5ndGhzLlxuICAgICAgICBwYXRjaC5sZW5ndGgxICs9IHByZWZpeC5sZW5ndGggKyBzdWZmaXgubGVuZ3RoO1xuICAgICAgICBwYXRjaC5sZW5ndGgyICs9IHByZWZpeC5sZW5ndGggKyBzdWZmaXgubGVuZ3RoO1xuICAgIH07XG4gICAgO1xuICAgIC8qKlxuICAgICAqIENvbXB1dGUgYSBsaXN0IG9mIHBhdGNoZXMgdG8gdHVybiB0ZXh0MSBpbnRvIHRleHQyLlxuICAgICAqIFVzZSBkaWZmcyBpZiBwcm92aWRlZCwgb3RoZXJ3aXNlIGNvbXB1dGUgaXQgb3Vyc2VsdmVzLlxuICAgICAqIFRoZXJlIGFyZSBmb3VyIHdheXMgdG8gY2FsbCB0aGlzIGZ1bmN0aW9uLCBkZXBlbmRpbmcgb24gd2hhdCBkYXRhIGlzXG4gICAgICogYXZhaWxhYmxlIHRvIHRoZSBjYWxsZXI6XG4gICAgICogTWV0aG9kIDE6XG4gICAgICogYSA9IHRleHQxLCBiID0gdGV4dDJcbiAgICAgKiBNZXRob2QgMjpcbiAgICAgKiBhID0gZGlmZnNcbiAgICAgKiBNZXRob2QgMyAob3B0aW1hbCk6XG4gICAgICogYSA9IHRleHQxLCBiID0gZGlmZnNcbiAgICAgKiBNZXRob2QgNCAoZGVwcmVjYXRlZCwgdXNlIG1ldGhvZCAzKTpcbiAgICAgKiBhID0gdGV4dDEsIGIgPSB0ZXh0MiwgYyA9IGRpZmZzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3whQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLkRpZmY+fSBhIHRleHQxIChtZXRob2RzIDEsMyw0KSBvclxuICAgICAqIEFycmF5IG9mIGRpZmYgdHVwbGVzIGZvciB0ZXh0MSB0byB0ZXh0MiAobWV0aG9kIDIpLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfCFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2guRGlmZj59IG9wdF9iIHRleHQyIChtZXRob2RzIDEsNCkgb3JcbiAgICAgKiBBcnJheSBvZiBkaWZmIHR1cGxlcyBmb3IgdGV4dDEgdG8gdGV4dDIgKG1ldGhvZCAzKSBvciB1bmRlZmluZWQgKG1ldGhvZCAyKS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ3whQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLkRpZmY+fSBvcHRfYyBBcnJheSBvZiBkaWZmIHR1cGxlc1xuICAgICAqIGZvciB0ZXh0MSB0byB0ZXh0MiAobWV0aG9kIDQpIG9yIHVuZGVmaW5lZCAobWV0aG9kcyAxLDIsMykuXG4gICAgICogQHJldHVybiB7IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5wYXRjaF9vYmo+fSBBcnJheSBvZiBQYXRjaCBvYmplY3RzLlxuICAgICAqL1xuICAgIERpZmZNYXRjaFBhdGNoLnByb3RvdHlwZS5wYXRjaF9tYWtlID0gZnVuY3Rpb24gKGEsIG9wdF9iLCBvcHRfYykge1xuICAgICAgICB2YXIgdGV4dDEsIGRpZmZzO1xuICAgICAgICBpZiAodHlwZW9mIGEgPT0gJ3N0cmluZycgJiYgdHlwZW9mIG9wdF9iID09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICB0eXBlb2Ygb3B0X2MgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIE1ldGhvZCAxOiB0ZXh0MSwgdGV4dDJcbiAgICAgICAgICAgIC8vIENvbXB1dGUgZGlmZnMgZnJvbSB0ZXh0MSBhbmQgdGV4dDIuXG4gICAgICAgICAgICB0ZXh0MSA9IChhKTtcbiAgICAgICAgICAgIGRpZmZzID0gdGhpcy5kaWZmX21haW4odGV4dDEsIC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAob3B0X2IpLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChkaWZmcy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaWZmX2NsZWFudXBTZW1hbnRpYyhkaWZmcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5kaWZmX2NsZWFudXBFZmZpY2llbmN5KGRpZmZzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhICYmIHR5cGVvZiBhID09ICdvYmplY3QnICYmIHR5cGVvZiBvcHRfYiA9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgdHlwZW9mIG9wdF9jID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyBNZXRob2QgMjogZGlmZnNcbiAgICAgICAgICAgIC8vIENvbXB1dGUgdGV4dDEgZnJvbSBkaWZmcy5cbiAgICAgICAgICAgIGRpZmZzID0gKGEpO1xuICAgICAgICAgICAgdGV4dDEgPSB0aGlzLmRpZmZfdGV4dDEoZGlmZnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhID09ICdzdHJpbmcnICYmIG9wdF9iICYmIHR5cGVvZiBvcHRfYiA9PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgdHlwZW9mIG9wdF9jID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyBNZXRob2QgMzogdGV4dDEsIGRpZmZzXG4gICAgICAgICAgICB0ZXh0MSA9IChhKTtcbiAgICAgICAgICAgIGRpZmZzID0gKG9wdF9iKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgYSA9PSAnc3RyaW5nJyAmJiB0eXBlb2Ygb3B0X2IgPT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgIG9wdF9jICYmIHR5cGVvZiBvcHRfYyA9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgLy8gTWV0aG9kIDQ6IHRleHQxLCB0ZXh0MiwgZGlmZnNcbiAgICAgICAgICAgIC8vIHRleHQyIGlzIG5vdCB1c2VkLlxuICAgICAgICAgICAgdGV4dDEgPSAoYSk7XG4gICAgICAgICAgICBkaWZmcyA9IChvcHRfYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gY2FsbCBmb3JtYXQgdG8gcGF0Y2hfbWFrZS4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlmZnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gW107IC8vIEdldCByaWQgb2YgdGhlIG51bGwgY2FzZS5cbiAgICAgICAgfVxuICAgICAgICB2YXIgcGF0Y2hlcyA9IFtdO1xuICAgICAgICB2YXIgcGF0Y2ggPSBuZXcgcGF0Y2hfb2JqKCk7XG4gICAgICAgIHZhciBwYXRjaERpZmZMZW5ndGggPSAwOyAvLyBLZWVwaW5nIG91ciBvd24gbGVuZ3RoIGNvbnN0IGlzIGZhc3RlciBpbiBKUy5cbiAgICAgICAgdmFyIGNoYXJfY291bnQxID0gMDsgLy8gTnVtYmVyIG9mIGNoYXJhY3RlcnMgaW50byB0aGUgdGV4dDEgc3RyaW5nLlxuICAgICAgICB2YXIgY2hhcl9jb3VudDIgPSAwOyAvLyBOdW1iZXIgb2YgY2hhcmFjdGVycyBpbnRvIHRoZSB0ZXh0MiBzdHJpbmcuXG4gICAgICAgIC8vIFN0YXJ0IHdpdGggdGV4dDEgKHByZXBhdGNoX3RleHQpIGFuZCBhcHBseSB0aGUgZGlmZnMgdW50aWwgd2UgYXJyaXZlIGF0XG4gICAgICAgIC8vIHRleHQyIChwb3N0cGF0Y2hfdGV4dCkuICBXZSByZWNyZWF0ZSB0aGUgcGF0Y2hlcyBvbmUgYnkgb25lIHRvIGRldGVybWluZVxuICAgICAgICAvLyBjb250ZXh0IGluZm8uXG4gICAgICAgIHZhciBwcmVwYXRjaF90ZXh0ID0gdGV4dDE7XG4gICAgICAgIHZhciBwb3N0cGF0Y2hfdGV4dCA9IHRleHQxO1xuICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IGRpZmZzLmxlbmd0aDsgeCsrKSB7XG4gICAgICAgICAgICB2YXIgZGlmZl90eXBlID0gZGlmZnNbeF1bMF07XG4gICAgICAgICAgICB2YXIgZGlmZl90ZXh0ID0gZGlmZnNbeF1bMV07XG4gICAgICAgICAgICBpZiAoIXBhdGNoRGlmZkxlbmd0aCAmJiBkaWZmX3R5cGUgIT09IDAgLyogRXF1YWwgKi8pIHtcbiAgICAgICAgICAgICAgICAvLyBBIG5ldyBwYXRjaCBzdGFydHMgaGVyZS5cbiAgICAgICAgICAgICAgICBwYXRjaC5zdGFydDEgPSBjaGFyX2NvdW50MTtcbiAgICAgICAgICAgICAgICBwYXRjaC5zdGFydDIgPSBjaGFyX2NvdW50MjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAoZGlmZl90eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxIC8qIEluc2VydCAqLzpcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2guZGlmZnNbcGF0Y2hEaWZmTGVuZ3RoKytdID0gZGlmZnNbeF07XG4gICAgICAgICAgICAgICAgICAgIHBhdGNoLmxlbmd0aDIgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgcG9zdHBhdGNoX3RleHQgPSBwb3N0cGF0Y2hfdGV4dC5zdWJzdHJpbmcoMCwgY2hhcl9jb3VudDIpICsgZGlmZl90ZXh0ICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc3RwYXRjaF90ZXh0LnN1YnN0cmluZyhjaGFyX2NvdW50Mik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLTEgLyogRGVsZXRlICovOlxuICAgICAgICAgICAgICAgICAgICBwYXRjaC5sZW5ndGgxICs9IGRpZmZfdGV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHBhdGNoLmRpZmZzW3BhdGNoRGlmZkxlbmd0aCsrXSA9IGRpZmZzW3hdO1xuICAgICAgICAgICAgICAgICAgICBwb3N0cGF0Y2hfdGV4dCA9IHBvc3RwYXRjaF90ZXh0LnN1YnN0cmluZygwLCBjaGFyX2NvdW50MikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zdHBhdGNoX3RleHQuc3Vic3RyaW5nKGNoYXJfY291bnQyICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWZmX3RleHQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAwIC8qIEVxdWFsICovOlxuICAgICAgICAgICAgICAgICAgICBpZiAoZGlmZl90ZXh0Lmxlbmd0aCA8PSAyICogdGhpcy5QYXRjaF9NYXJnaW4gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGNoRGlmZkxlbmd0aCAmJiBkaWZmcy5sZW5ndGggIT0geCArIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNtYWxsIGVxdWFsaXR5IGluc2lkZSBhIHBhdGNoLlxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0Y2guZGlmZnNbcGF0Y2hEaWZmTGVuZ3RoKytdID0gZGlmZnNbeF07XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRjaC5sZW5ndGgxICs9IGRpZmZfdGV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRjaC5sZW5ndGgyICs9IGRpZmZfdGV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZGlmZl90ZXh0Lmxlbmd0aCA+PSAyICogdGhpcy5QYXRjaF9NYXJnaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRpbWUgZm9yIGEgbmV3IHBhdGNoLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhdGNoRGlmZkxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGF0Y2hfYWRkQ29udGV4dF8ocGF0Y2gsIHByZXBhdGNoX3RleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGNoZXMucHVzaChwYXRjaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0Y2ggPSBuZXcgcGF0Y2hfb2JqKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0Y2hEaWZmTGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVbmxpa2UgVW5pZGlmZiwgb3VyIHBhdGNoIGxpc3RzIGhhdmUgYSByb2xsaW5nIGNvbnRleHQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2dvb2dsZS1kaWZmLW1hdGNoLXBhdGNoL3dpa2kvVW5pZGlmZlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBwcmVwYXRjaCB0ZXh0ICYgcG9zIHRvIHJlZmxlY3QgdGhlIGFwcGxpY2F0aW9uIG9mIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGp1c3QgY29tcGxldGVkIHBhdGNoLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXBhdGNoX3RleHQgPSBwb3N0cGF0Y2hfdGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFyX2NvdW50MSA9IGNoYXJfY291bnQyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBjdXJyZW50IGNoYXJhY3RlciBjb3VudC5cbiAgICAgICAgICAgIGlmIChkaWZmX3R5cGUgIT09IDEgLyogSW5zZXJ0ICovKSB7XG4gICAgICAgICAgICAgICAgY2hhcl9jb3VudDEgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkaWZmX3R5cGUgIT09IC0xIC8qIERlbGV0ZSAqLykge1xuICAgICAgICAgICAgICAgIGNoYXJfY291bnQyICs9IGRpZmZfdGV4dC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUGljayB1cCB0aGUgbGVmdG92ZXIgcGF0Y2ggaWYgbm90IGVtcHR5LlxuICAgICAgICBpZiAocGF0Y2hEaWZmTGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnBhdGNoX2FkZENvbnRleHRfKHBhdGNoLCBwcmVwYXRjaF90ZXh0KTtcbiAgICAgICAgICAgIHBhdGNoZXMucHVzaChwYXRjaCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhdGNoZXM7XG4gICAgfTtcbiAgICA7XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYW4gYXJyYXkgb2YgcGF0Y2hlcywgcmV0dXJuIGFub3RoZXIgYXJyYXkgdGhhdCBpcyBpZGVudGljYWwuXG4gICAgICogQHBhcmFtIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLnBhdGNoX29iaj59IHBhdGNoZXMgQXJyYXkgb2YgUGF0Y2ggb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJuIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLnBhdGNoX29iaj59IEFycmF5IG9mIFBhdGNoIG9iamVjdHMuXG4gICAgICovXG4gICAgRGlmZk1hdGNoUGF0Y2gucHJvdG90eXBlLnBhdGNoX2RlZXBDb3B5ID0gZnVuY3Rpb24gKHBhdGNoZXMpIHtcbiAgICAgICAgLy8gTWFraW5nIGRlZXAgY29waWVzIGlzIGhhcmQgaW4gSmF2YVNjcmlwdC5cbiAgICAgICAgdmFyIHBhdGNoZXNDb3B5ID0gW107XG4gICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgcGF0Y2hlcy5sZW5ndGg7IHgrKykge1xuICAgICAgICAgICAgdmFyIHBhdGNoID0gcGF0Y2hlc1t4XTtcbiAgICAgICAgICAgIHZhciBwYXRjaENvcHkgPSBuZXcgcGF0Y2hfb2JqKCk7XG4gICAgICAgICAgICBwYXRjaENvcHkuZGlmZnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgcGF0Y2guZGlmZnMubGVuZ3RoOyB5KyspIHtcbiAgICAgICAgICAgICAgICBwYXRjaENvcHkuZGlmZnNbeV0gPSBbcGF0Y2guZGlmZnNbeV1bMF0sIHBhdGNoLmRpZmZzW3ldWzFdXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhdGNoQ29weS5zdGFydDEgPSBwYXRjaC5zdGFydDE7XG4gICAgICAgICAgICBwYXRjaENvcHkuc3RhcnQyID0gcGF0Y2guc3RhcnQyO1xuICAgICAgICAgICAgcGF0Y2hDb3B5Lmxlbmd0aDEgPSBwYXRjaC5sZW5ndGgxO1xuICAgICAgICAgICAgcGF0Y2hDb3B5Lmxlbmd0aDIgPSBwYXRjaC5sZW5ndGgyO1xuICAgICAgICAgICAgcGF0Y2hlc0NvcHlbeF0gPSBwYXRjaENvcHk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhdGNoZXNDb3B5O1xuICAgIH07XG4gICAgO1xuICAgIC8qKlxuICAgICAqIE1lcmdlIGEgc2V0IG9mIHBhdGNoZXMgb250byB0aGUgdGV4dC4gIFJldHVybiBhIHBhdGNoZWQgdGV4dCwgYXMgd2VsbFxuICAgICAqIGFzIGEgbGlzdCBvZiB0cnVlL2ZhbHNlIHZhbHVlcyBpbmRpY2F0aW5nIHdoaWNoIHBhdGNoZXMgd2VyZSBhcHBsaWVkLlxuICAgICAqIEBwYXJhbSB7IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5wYXRjaF9vYmo+fSBwYXRjaGVzIEFycmF5IG9mIFBhdGNoIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgT2xkIHRleHQuXG4gICAgICogQHJldHVybiB7IUFycmF5LjxzdHJpbmd8IUFycmF5Ljxib29sZWFuPj59IFR3byBlbGVtZW50IEFycmF5LCBjb250YWluaW5nIHRoZVxuICAgICAqICAgICAgbmV3IHRleHQgYW5kIGFuIGFycmF5IG9mIGJvb2xlYW4gdmFsdWVzLlxuICAgICAqL1xuICAgIERpZmZNYXRjaFBhdGNoLnByb3RvdHlwZS5wYXRjaF9hcHBseSA9IGZ1bmN0aW9uIChwYXRjaGVzLCB0ZXh0KSB7XG4gICAgICAgIGlmIChwYXRjaGVzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gW3RleHQsIFtdXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEZWVwIGNvcHkgdGhlIHBhdGNoZXMgc28gdGhhdCBubyBjaGFuZ2VzIGFyZSBtYWRlIHRvIG9yaWdpbmFscy5cbiAgICAgICAgcGF0Y2hlcyA9IHRoaXMucGF0Y2hfZGVlcENvcHkocGF0Y2hlcyk7XG4gICAgICAgIHZhciBudWxsUGFkZGluZyA9IHRoaXMucGF0Y2hfYWRkUGFkZGluZyhwYXRjaGVzKTtcbiAgICAgICAgdGV4dCA9IG51bGxQYWRkaW5nICsgdGV4dCArIG51bGxQYWRkaW5nO1xuICAgICAgICB0aGlzLnBhdGNoX3NwbGl0TWF4KHBhdGNoZXMpO1xuICAgICAgICAvLyBkZWx0YSBrZWVwcyB0cmFjayBvZiB0aGUgb2Zmc2V0IGJldHdlZW4gdGhlIGV4cGVjdGVkIGFuZCBhY3R1YWwgbG9jYXRpb25cbiAgICAgICAgLy8gb2YgdGhlIHByZXZpb3VzIHBhdGNoLiAgSWYgdGhlcmUgYXJlIHBhdGNoZXMgZXhwZWN0ZWQgYXQgcG9zaXRpb25zIDEwIGFuZFxuICAgICAgICAvLyAyMCwgYnV0IHRoZSBmaXJzdCBwYXRjaCB3YXMgZm91bmQgYXQgMTIsIGRlbHRhIGlzIDIgYW5kIHRoZSBzZWNvbmQgcGF0Y2hcbiAgICAgICAgLy8gaGFzIGFuIGVmZmVjdGl2ZSBleHBlY3RlZCBwb3NpdGlvbiBvZiAyMi5cbiAgICAgICAgdmFyIGRlbHRhID0gMDtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBwYXRjaGVzLmxlbmd0aDsgeCsrKSB7XG4gICAgICAgICAgICB2YXIgZXhwZWN0ZWRfbG9jID0gcGF0Y2hlc1t4XS5zdGFydDIgKyBkZWx0YTtcbiAgICAgICAgICAgIHZhciB0ZXh0MSA9IHRoaXMuZGlmZl90ZXh0MShwYXRjaGVzW3hdLmRpZmZzKTtcbiAgICAgICAgICAgIHZhciBzdGFydF9sb2MgPSB2b2lkIDA7XG4gICAgICAgICAgICB2YXIgZW5kX2xvYyA9IC0xO1xuICAgICAgICAgICAgaWYgKHRleHQxLmxlbmd0aCA+IHRoaXMuTWF0Y2hfTWF4Qml0cykge1xuICAgICAgICAgICAgICAgIC8vIHBhdGNoX3NwbGl0TWF4IHdpbGwgb25seSBwcm92aWRlIGFuIG92ZXJzaXplZCBwYXR0ZXJuIGluIHRoZSBjYXNlIG9mXG4gICAgICAgICAgICAgICAgLy8gYSBtb25zdGVyIGRlbGV0ZS5cbiAgICAgICAgICAgICAgICBzdGFydF9sb2MgPSB0aGlzLm1hdGNoX21haW4odGV4dCwgdGV4dDEuc3Vic3RyaW5nKDAsIHRoaXMuTWF0Y2hfTWF4Qml0cyksIGV4cGVjdGVkX2xvYyk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0X2xvYyAhPSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBlbmRfbG9jID0gdGhpcy5tYXRjaF9tYWluKHRleHQsIHRleHQxLnN1YnN0cmluZyh0ZXh0MS5sZW5ndGggLSB0aGlzLk1hdGNoX01heEJpdHMpLCBleHBlY3RlZF9sb2MgKyB0ZXh0MS5sZW5ndGggLSB0aGlzLk1hdGNoX01heEJpdHMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW5kX2xvYyA9PSAtMSB8fCBzdGFydF9sb2MgPj0gZW5kX2xvYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FuJ3QgZmluZCB2YWxpZCB0cmFpbGluZyBjb250ZXh0LiAgRHJvcCB0aGlzIHBhdGNoLlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRfbG9jID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGFydF9sb2MgPSB0aGlzLm1hdGNoX21haW4odGV4dCwgdGV4dDEsIGV4cGVjdGVkX2xvYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhcnRfbG9jID09IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gTm8gbWF0Y2ggZm91bmQuICA6KFxuICAgICAgICAgICAgICAgIHJlc3VsdHNbeF0gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAvLyBTdWJ0cmFjdCB0aGUgZGVsdGEgZm9yIHRoaXMgZmFpbGVkIHBhdGNoIGZyb20gc3Vic2VxdWVudCBwYXRjaGVzLlxuICAgICAgICAgICAgICAgIGRlbHRhIC09IHBhdGNoZXNbeF0ubGVuZ3RoMiAtIHBhdGNoZXNbeF0ubGVuZ3RoMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEZvdW5kIGEgbWF0Y2guICA6KVxuICAgICAgICAgICAgICAgIHJlc3VsdHNbeF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGRlbHRhID0gc3RhcnRfbG9jIC0gZXhwZWN0ZWRfbG9jO1xuICAgICAgICAgICAgICAgIHZhciB0ZXh0MiA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBpZiAoZW5kX2xvYyA9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0MiA9IHRleHQuc3Vic3RyaW5nKHN0YXJ0X2xvYywgc3RhcnRfbG9jICsgdGV4dDEubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQyID0gdGV4dC5zdWJzdHJpbmcoc3RhcnRfbG9jLCBlbmRfbG9jICsgdGhpcy5NYXRjaF9NYXhCaXRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRleHQxID09IHRleHQyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFBlcmZlY3QgbWF0Y2gsIGp1c3Qgc2hvdmUgdGhlIHJlcGxhY2VtZW50IHRleHQgaW4uXG4gICAgICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCBzdGFydF9sb2MpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlmZl90ZXh0MihwYXRjaGVzW3hdLmRpZmZzKSArXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0LnN1YnN0cmluZyhzdGFydF9sb2MgKyB0ZXh0MS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW1wZXJmZWN0IG1hdGNoLiAgUnVuIGEgZGlmZiB0byBnZXQgYSBmcmFtZXdvcmsgb2YgZXF1aXZhbGVudFxuICAgICAgICAgICAgICAgICAgICAvLyBpbmRpY2VzLlxuICAgICAgICAgICAgICAgICAgICB2YXIgZGlmZnMgPSB0aGlzLmRpZmZfbWFpbih0ZXh0MSwgdGV4dDIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRleHQxLmxlbmd0aCA+IHRoaXMuTWF0Y2hfTWF4Qml0cyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaWZmX2xldmVuc2h0ZWluKGRpZmZzKSAvIHRleHQxLmxlbmd0aCA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5QYXRjaF9EZWxldGVUaHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBlbmQgcG9pbnRzIG1hdGNoLCBidXQgdGhlIGNvbnRlbnQgaXMgdW5hY2NlcHRhYmx5IGJhZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHNbeF0gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlmZl9jbGVhbnVwU2VtYW50aWNMb3NzbGVzcyhkaWZmcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXgxID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleDIgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IHBhdGNoZXNbeF0uZGlmZnMubGVuZ3RoOyB5KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbW9kID0gcGF0Y2hlc1t4XS5kaWZmc1t5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9kWzBdICE9PSAwIC8qIEVxdWFsICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4MiA9IHRoaXMuZGlmZl94SW5kZXgoZGlmZnMsIGluZGV4MSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb2RbMF0gPT09IDEgLyogSW5zZXJ0ICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCBzdGFydF9sb2MgKyBpbmRleDIpICsgbW9kWzFdICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQuc3Vic3RyaW5nKHN0YXJ0X2xvYyArIGluZGV4Mik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1vZFswXSA9PT0gLTEgLyogRGVsZXRlICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCBzdGFydF9sb2MgKyBpbmRleDIpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQuc3Vic3RyaW5nKHN0YXJ0X2xvYyArIHRoaXMuZGlmZl94SW5kZXgoZGlmZnMsIGluZGV4MSArIG1vZFsxXS5sZW5ndGgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZFswXSAhPT0gLTEgLyogRGVsZXRlICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4MSArPSBtb2RbMV0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBTdHJpcCB0aGUgcGFkZGluZyBvZmYuXG4gICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZyhudWxsUGFkZGluZy5sZW5ndGgsIHRleHQubGVuZ3RoIC0gbnVsbFBhZGRpbmcubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIFt0ZXh0LCByZXN1bHRzXTtcbiAgICB9O1xuICAgIDtcbiAgICAvKipcbiAgICAgKiBBZGQgc29tZSBwYWRkaW5nIG9uIHRleHQgc3RhcnQgYW5kIGVuZCBzbyB0aGF0IGVkZ2VzIGNhbiBtYXRjaCBzb21ldGhpbmcuXG4gICAgICogSW50ZW5kZWQgdG8gYmUgY2FsbGVkIG9ubHkgZnJvbSB3aXRoaW4gcGF0Y2hfYXBwbHkuXG4gICAgICogQHBhcmFtIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLnBhdGNoX29iaj59IHBhdGNoZXMgQXJyYXkgb2YgUGF0Y2ggb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBwYWRkaW5nIHN0cmluZyBhZGRlZCB0byBlYWNoIHNpZGUuXG4gICAgICovXG4gICAgRGlmZk1hdGNoUGF0Y2gucHJvdG90eXBlLnBhdGNoX2FkZFBhZGRpbmcgPSBmdW5jdGlvbiAocGF0Y2hlcykge1xuICAgICAgICB2YXIgcGFkZGluZ0xlbmd0aCA9IHRoaXMuUGF0Y2hfTWFyZ2luO1xuICAgICAgICB2YXIgbnVsbFBhZGRpbmcgPSAnJztcbiAgICAgICAgZm9yICh2YXIgeCA9IDE7IHggPD0gcGFkZGluZ0xlbmd0aDsgeCsrKSB7XG4gICAgICAgICAgICBudWxsUGFkZGluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJ1bXAgYWxsIHRoZSBwYXRjaGVzIGZvcndhcmQuXG4gICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgcGF0Y2hlcy5sZW5ndGg7IHgrKykge1xuICAgICAgICAgICAgcGF0Y2hlc1t4XS5zdGFydDEgKz0gcGFkZGluZ0xlbmd0aDtcbiAgICAgICAgICAgIHBhdGNoZXNbeF0uc3RhcnQyICs9IHBhZGRpbmdMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHNvbWUgcGFkZGluZyBvbiBzdGFydCBvZiBmaXJzdCBkaWZmLlxuICAgICAgICB2YXIgcGF0Y2ggPSBwYXRjaGVzWzBdO1xuICAgICAgICB2YXIgZGlmZnMgPSBwYXRjaC5kaWZmcztcbiAgICAgICAgaWYgKGRpZmZzLmxlbmd0aCA9PSAwIHx8IGRpZmZzWzBdWzBdICE9IDAgLyogRXF1YWwgKi8pIHtcbiAgICAgICAgICAgIC8vIEFkZCBudWxsUGFkZGluZyBlcXVhbGl0eS5cbiAgICAgICAgICAgIGRpZmZzLnVuc2hpZnQoWzAgLyogRXF1YWwgKi8sIG51bGxQYWRkaW5nXSk7XG4gICAgICAgICAgICBwYXRjaC5zdGFydDEgLT0gcGFkZGluZ0xlbmd0aDsgLy8gU2hvdWxkIGJlIDAuXG4gICAgICAgICAgICBwYXRjaC5zdGFydDIgLT0gcGFkZGluZ0xlbmd0aDsgLy8gU2hvdWxkIGJlIDAuXG4gICAgICAgICAgICBwYXRjaC5sZW5ndGgxICs9IHBhZGRpbmdMZW5ndGg7XG4gICAgICAgICAgICBwYXRjaC5sZW5ndGgyICs9IHBhZGRpbmdMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGFkZGluZ0xlbmd0aCA+IGRpZmZzWzBdWzFdLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gR3JvdyBmaXJzdCBlcXVhbGl0eS5cbiAgICAgICAgICAgIHZhciBleHRyYUxlbmd0aCA9IHBhZGRpbmdMZW5ndGggLSBkaWZmc1swXVsxXS5sZW5ndGg7XG4gICAgICAgICAgICBkaWZmc1swXVsxXSA9IG51bGxQYWRkaW5nLnN1YnN0cmluZyhkaWZmc1swXVsxXS5sZW5ndGgpICsgZGlmZnNbMF1bMV07XG4gICAgICAgICAgICBwYXRjaC5zdGFydDEgLT0gZXh0cmFMZW5ndGg7XG4gICAgICAgICAgICBwYXRjaC5zdGFydDIgLT0gZXh0cmFMZW5ndGg7XG4gICAgICAgICAgICBwYXRjaC5sZW5ndGgxICs9IGV4dHJhTGVuZ3RoO1xuICAgICAgICAgICAgcGF0Y2gubGVuZ3RoMiArPSBleHRyYUxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgc29tZSBwYWRkaW5nIG9uIGVuZCBvZiBsYXN0IGRpZmYuXG4gICAgICAgIHBhdGNoID0gcGF0Y2hlc1twYXRjaGVzLmxlbmd0aCAtIDFdO1xuICAgICAgICBkaWZmcyA9IHBhdGNoLmRpZmZzO1xuICAgICAgICBpZiAoZGlmZnMubGVuZ3RoID09IDAgfHwgZGlmZnNbZGlmZnMubGVuZ3RoIC0gMV1bMF0gIT0gMCAvKiBFcXVhbCAqLykge1xuICAgICAgICAgICAgLy8gQWRkIG51bGxQYWRkaW5nIGVxdWFsaXR5LlxuICAgICAgICAgICAgZGlmZnMucHVzaChbMCAvKiBFcXVhbCAqLywgbnVsbFBhZGRpbmddKTtcbiAgICAgICAgICAgIHBhdGNoLmxlbmd0aDEgKz0gcGFkZGluZ0xlbmd0aDtcbiAgICAgICAgICAgIHBhdGNoLmxlbmd0aDIgKz0gcGFkZGluZ0xlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYWRkaW5nTGVuZ3RoID4gZGlmZnNbZGlmZnMubGVuZ3RoIC0gMV1bMV0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBHcm93IGxhc3QgZXF1YWxpdHkuXG4gICAgICAgICAgICB2YXIgZXh0cmFMZW5ndGggPSBwYWRkaW5nTGVuZ3RoIC0gZGlmZnNbZGlmZnMubGVuZ3RoIC0gMV1bMV0ubGVuZ3RoO1xuICAgICAgICAgICAgZGlmZnNbZGlmZnMubGVuZ3RoIC0gMV1bMV0gKz0gbnVsbFBhZGRpbmcuc3Vic3RyaW5nKDAsIGV4dHJhTGVuZ3RoKTtcbiAgICAgICAgICAgIHBhdGNoLmxlbmd0aDEgKz0gZXh0cmFMZW5ndGg7XG4gICAgICAgICAgICBwYXRjaC5sZW5ndGgyICs9IGV4dHJhTGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsUGFkZGluZztcbiAgICB9O1xuICAgIDtcbiAgICAvKipcbiAgICAgKiBUYWtlIGEgbGlzdCBvZiBwYXRjaGVzIGFuZCByZXR1cm4gYSB0ZXh0dWFsIHJlcHJlc2VudGF0aW9uLlxuICAgICAqIEBwYXJhbSB7IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5wYXRjaF9vYmo+fSBwYXRjaGVzIEFycmF5IG9mIFBhdGNoIG9iamVjdHMuXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBUZXh0IHJlcHJlc2VudGF0aW9uIG9mIHBhdGNoZXMuXG4gICAgICovXG4gICAgRGlmZk1hdGNoUGF0Y2gucHJvdG90eXBlLnBhdGNoX3RvVGV4dCA9IGZ1bmN0aW9uIChwYXRjaGVzKSB7XG4gICAgICAgIHZhciB0ZXh0ID0gW107XG4gICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgcGF0Y2hlcy5sZW5ndGg7IHgrKykge1xuICAgICAgICAgICAgdGV4dFt4XSA9IHBhdGNoZXNbeF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHQuam9pbignJyk7XG4gICAgfTtcbiAgICA7XG4gICAgLyoqXG4gICAgICogUGFyc2UgYSB0ZXh0dWFsIHJlcHJlc2VudGF0aW9uIG9mIHBhdGNoZXMgYW5kIHJldHVybiBhIGxpc3Qgb2YgUGF0Y2ggb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dGxpbmUgVGV4dCByZXByZXNlbnRhdGlvbiBvZiBwYXRjaGVzLlxuICAgICAqIEByZXR1cm4geyFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2gucGF0Y2hfb2JqPn0gQXJyYXkgb2YgUGF0Y2ggb2JqZWN0cy5cbiAgICAgKiBAdGhyb3dzIHshRXJyb3J9IElmIGludmFsaWQgaW5wdXQuXG4gICAgICovXG4gICAgRGlmZk1hdGNoUGF0Y2gucHJvdG90eXBlLnBhdGNoX2Zyb21UZXh0ID0gZnVuY3Rpb24gKHRleHRsaW5lKSB7XG4gICAgICAgIHZhciBwYXRjaGVzID0gW107XG4gICAgICAgIGlmICghdGV4dGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXRjaGVzO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0ZXh0ID0gdGV4dGxpbmUuc3BsaXQoJ1xcbicpO1xuICAgICAgICB2YXIgdGV4dFBvaW50ZXIgPSAwO1xuICAgICAgICB2YXIgcGF0Y2hIZWFkZXIgPSAvXkBAIC0oXFxkKyksPyhcXGQqKSBcXCsoXFxkKyksPyhcXGQqKSBAQCQvO1xuICAgICAgICB3aGlsZSAodGV4dFBvaW50ZXIgPCB0ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIG0gPSB0ZXh0W3RleHRQb2ludGVyXS5tYXRjaChwYXRjaEhlYWRlcik7XG4gICAgICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcGF0Y2ggc3RyaW5nOiAnICsgdGV4dFt0ZXh0UG9pbnRlcl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHBhdGNoID0gbmV3IHBhdGNoX29iaigpO1xuICAgICAgICAgICAgcGF0Y2hlcy5wdXNoKHBhdGNoKTtcbiAgICAgICAgICAgIHBhdGNoLnN0YXJ0MSA9IHBhcnNlSW50KG1bMV0sIDEwKTtcbiAgICAgICAgICAgIGlmIChtWzJdID09PSAnJykge1xuICAgICAgICAgICAgICAgIHBhdGNoLnN0YXJ0MS0tO1xuICAgICAgICAgICAgICAgIHBhdGNoLmxlbmd0aDEgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobVsyXSA9PSAnMCcpIHtcbiAgICAgICAgICAgICAgICBwYXRjaC5sZW5ndGgxID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhdGNoLnN0YXJ0MS0tO1xuICAgICAgICAgICAgICAgIHBhdGNoLmxlbmd0aDEgPSBwYXJzZUludChtWzJdLCAxMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXRjaC5zdGFydDIgPSBwYXJzZUludChtWzNdLCAxMCk7XG4gICAgICAgICAgICBpZiAobVs0XSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICBwYXRjaC5zdGFydDItLTtcbiAgICAgICAgICAgICAgICBwYXRjaC5sZW5ndGgyID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1bNF0gPT0gJzAnKSB7XG4gICAgICAgICAgICAgICAgcGF0Y2gubGVuZ3RoMiA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXRjaC5zdGFydDItLTtcbiAgICAgICAgICAgICAgICBwYXRjaC5sZW5ndGgyID0gcGFyc2VJbnQobVs0XSwgMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGV4dFBvaW50ZXIrKztcbiAgICAgICAgICAgIHdoaWxlICh0ZXh0UG9pbnRlciA8IHRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNpZ24gPSB0ZXh0W3RleHRQb2ludGVyXS5jaGFyQXQoMCk7XG4gICAgICAgICAgICAgICAgdmFyIGxpbmUgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgbGluZSA9IGRlY29kZVVSSSh0ZXh0W3RleHRQb2ludGVyXS5zdWJzdHJpbmcoMSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTWFsZm9ybWVkIFVSSSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGVzY2FwZSBpbiBwYXRjaF9mcm9tVGV4dDogJyArIGxpbmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2lnbiA9PSAnLScpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRGVsZXRpb24uXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoLmRpZmZzLnB1c2goWy0xIC8qIERlbGV0ZSAqLywgbGluZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzaWduID09ICcrJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbnNlcnRpb24uXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoLmRpZmZzLnB1c2goWzEgLyogSW5zZXJ0ICovLCBsaW5lXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNpZ24gPT0gJyAnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1pbm9yIGVxdWFsaXR5LlxuICAgICAgICAgICAgICAgICAgICBwYXRjaC5kaWZmcy5wdXNoKFswIC8qIEVxdWFsICovLCBsaW5lXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNpZ24gPT0gJ0AnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFN0YXJ0IG9mIG5leHQgcGF0Y2guXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzaWduID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBCbGFuayBsaW5lPyAgV2hhdGV2ZXIuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBXVEY/XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwYXRjaCBtb2RlIFwiJyArIHNpZ24gKyAnXCIgaW46ICcgKyBsaW5lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGV4dFBvaW50ZXIrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0Y2hlcztcbiAgICB9O1xuICAgIDtcbiAgICByZXR1cm4gRGlmZk1hdGNoUGF0Y2g7XG59KCkpO1xuZXhwb3J0cy5EaWZmTWF0Y2hQYXRjaCA9IERpZmZNYXRjaFBhdGNoO1xuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgb25lIHBhdGNoIG9wZXJhdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgcGF0Y2hfb2JqID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBwYXRjaF9vYmooKSB7XG4gICAgICAgIHRoaXMuZGlmZnMgPSBbXTtcbiAgICAgICAgdGhpcy5zdGFydDEgPSBudWxsO1xuICAgICAgICB0aGlzLnN0YXJ0MiA9IG51bGw7XG4gICAgICAgIHRoaXMubGVuZ3RoMSA9IDA7XG4gICAgICAgIHRoaXMubGVuZ3RoMiA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbW11bGF0ZSBHTlUgZGlmZidzIGZvcm1hdC5cbiAgICAgICAgICogSGVhZGVyOiBAQCAtMzgyLDggKzQ4MSw5IEBAXG4gICAgICAgICAqIEluZGljaWVzIGFyZSBwcmludGVkIGFzIDEtYmFzZWQsIG5vdCAwLWJhc2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjb29yZHMxLCBjb29yZHMyO1xuICAgICAgICAgICAgaWYgKHRoaXMubGVuZ3RoMSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNvb3JkczEgPSB0aGlzLnN0YXJ0MSArICcsMCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmxlbmd0aDEgPT0gMSkge1xuICAgICAgICAgICAgICAgIGNvb3JkczEgPSB0aGlzLnN0YXJ0MSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb29yZHMxID0gKHRoaXMuc3RhcnQxICsgMSkgKyAnLCcgKyB0aGlzLmxlbmd0aDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5sZW5ndGgyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY29vcmRzMiA9IHRoaXMuc3RhcnQyICsgJywwJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubGVuZ3RoMiA9PSAxKSB7XG4gICAgICAgICAgICAgICAgY29vcmRzMiA9IHRoaXMuc3RhcnQyICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvb3JkczIgPSAodGhpcy5zdGFydDIgKyAxKSArICcsJyArIHRoaXMubGVuZ3RoMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0ZXh0ID0gWydAQCAtJyArIGNvb3JkczEgKyAnICsnICsgY29vcmRzMiArICcgQEBcXG4nXTtcbiAgICAgICAgICAgIHZhciBvcDtcbiAgICAgICAgICAgIC8vIEVzY2FwZSB0aGUgYm9keSBvZiB0aGUgcGF0Y2ggd2l0aCAleHggbm90YXRpb24uXG4gICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHRoaXMuZGlmZnMubGVuZ3RoOyB4KyspIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMuZGlmZnNbeF1bMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxIC8qIEluc2VydCAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wID0gJysnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgLTEgLyogRGVsZXRlICovOlxuICAgICAgICAgICAgICAgICAgICAgICAgb3AgPSAnLSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwIC8qIEVxdWFsICovOlxuICAgICAgICAgICAgICAgICAgICAgICAgb3AgPSAnICc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGV4dFt4ICsgMV0gPSBvcCArIGVuY29kZVVSSSh0aGlzLmRpZmZzW3hdWzFdKSArICdcXG4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRleHQuam9pbignJykucmVwbGFjZSgvJTIwL2csICcgJyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBwYXRjaF9vYmo7XG59KCkpO1xuZXhwb3J0cy5wYXRjaF9vYmogPSBwYXRjaF9vYmo7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kaWZmTWF0Y2hQYXRjaC5qcy5tYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/ng-diff-match-patch/dist/diffMatchPatch.js\n");

/***/ }),

/***/ "./node_modules/ng-diff-match-patch/dist/diffMatchPatch.module.js":
/*!************************************************************************!*\
  !*** ./node_modules/ng-diff-match-patch/dist/diffMatchPatch.module.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar core_1 = __webpack_require__(/*! @angular/core */ \"./node_modules/@angular/core/fesm5/core.js\");\nvar common_1 = __webpack_require__(/*! @angular/common */ \"./node_modules/@angular/common/fesm5/common.js\");\nvar diff_directive_1 = __webpack_require__(/*! ./diff.directive */ \"./node_modules/ng-diff-match-patch/dist/diff.directive.js\");\nvar lineDiff_directive_1 = __webpack_require__(/*! ./lineDiff.directive */ \"./node_modules/ng-diff-match-patch/dist/lineDiff.directive.js\");\nvar processingDiff_directive_1 = __webpack_require__(/*! ./processingDiff.directive */ \"./node_modules/ng-diff-match-patch/dist/processingDiff.directive.js\");\nvar semanticDiff_directive_1 = __webpack_require__(/*! ./semanticDiff.directive */ \"./node_modules/ng-diff-match-patch/dist/semanticDiff.directive.js\");\nvar lineCompare_component_1 = __webpack_require__(/*! ./lineCompare.component */ \"./node_modules/ng-diff-match-patch/dist/lineCompare.component.js\");\nvar diffMatchPatch_1 = __webpack_require__(/*! ./diffMatchPatch */ \"./node_modules/ng-diff-match-patch/dist/diffMatchPatch.js\");\nvar diffMatchPatch_service_1 = __webpack_require__(/*! ./diffMatchPatch.service */ \"./node_modules/ng-diff-match-patch/dist/diffMatchPatch.service.js\");\nvar DiffMatchPatchModule = (function () {\n    function DiffMatchPatchModule() {\n    }\n    DiffMatchPatchModule = __decorate([\n        core_1.NgModule({\n            declarations: [\n                diff_directive_1.DiffDirective,\n                lineDiff_directive_1.LineDiffDirective,\n                processingDiff_directive_1.ProcessingDiffDirective,\n                semanticDiff_directive_1.SemanticDiffDirective,\n                lineCompare_component_1.LineCompareComponent\n            ],\n            imports: [\n                common_1.CommonModule\n            ],\n            exports: [\n                diff_directive_1.DiffDirective,\n                lineDiff_directive_1.LineDiffDirective,\n                processingDiff_directive_1.ProcessingDiffDirective,\n                semanticDiff_directive_1.SemanticDiffDirective,\n                lineCompare_component_1.LineCompareComponent\n            ],\n            providers: [\n                diffMatchPatch_1.DiffMatchPatch,\n                diffMatchPatch_service_1.DiffMatchPatchService\n            ]\n        })\n    ], DiffMatchPatchModule);\n    return DiffMatchPatchModule;\n}());\nexports.DiffMatchPatchModule = DiffMatchPatchModule;\n//# sourceMappingURL=diffMatchPatch.module.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmctZGlmZi1tYXRjaC1wYXRjaC9kaXN0L2RpZmZNYXRjaFBhdGNoLm1vZHVsZS5qcz85YTBhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVELGFBQWEsbUJBQU8sQ0FBQyxpRUFBZTtBQUNwQyxlQUFlLG1CQUFPLENBQUMsdUVBQWlCO0FBQ3hDLHVCQUF1QixtQkFBTyxDQUFDLG1GQUFrQjtBQUNqRCwyQkFBMkIsbUJBQU8sQ0FBQywyRkFBc0I7QUFDekQsaUNBQWlDLG1CQUFPLENBQUMsdUdBQTRCO0FBQ3JFLCtCQUErQixtQkFBTyxDQUFDLG1HQUEwQjtBQUNqRSw4QkFBOEIsbUJBQU8sQ0FBQyxpR0FBeUI7QUFDL0QsdUJBQXVCLG1CQUFPLENBQUMsbUZBQWtCO0FBQ2pELCtCQUErQixtQkFBTyxDQUFDLG1HQUEwQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9uZy1kaWZmLW1hdGNoLXBhdGNoL2Rpc3QvZGlmZk1hdGNoUGF0Y2gubW9kdWxlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29yZV8xID0gcmVxdWlyZShcIkBhbmd1bGFyL2NvcmVcIik7XG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvY29tbW9uXCIpO1xudmFyIGRpZmZfZGlyZWN0aXZlXzEgPSByZXF1aXJlKFwiLi9kaWZmLmRpcmVjdGl2ZVwiKTtcbnZhciBsaW5lRGlmZl9kaXJlY3RpdmVfMSA9IHJlcXVpcmUoXCIuL2xpbmVEaWZmLmRpcmVjdGl2ZVwiKTtcbnZhciBwcm9jZXNzaW5nRGlmZl9kaXJlY3RpdmVfMSA9IHJlcXVpcmUoXCIuL3Byb2Nlc3NpbmdEaWZmLmRpcmVjdGl2ZVwiKTtcbnZhciBzZW1hbnRpY0RpZmZfZGlyZWN0aXZlXzEgPSByZXF1aXJlKFwiLi9zZW1hbnRpY0RpZmYuZGlyZWN0aXZlXCIpO1xudmFyIGxpbmVDb21wYXJlX2NvbXBvbmVudF8xID0gcmVxdWlyZShcIi4vbGluZUNvbXBhcmUuY29tcG9uZW50XCIpO1xudmFyIGRpZmZNYXRjaFBhdGNoXzEgPSByZXF1aXJlKFwiLi9kaWZmTWF0Y2hQYXRjaFwiKTtcbnZhciBkaWZmTWF0Y2hQYXRjaF9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi9kaWZmTWF0Y2hQYXRjaC5zZXJ2aWNlXCIpO1xudmFyIERpZmZNYXRjaFBhdGNoTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEaWZmTWF0Y2hQYXRjaE1vZHVsZSgpIHtcbiAgICB9XG4gICAgRGlmZk1hdGNoUGF0Y2hNb2R1bGUgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgY29yZV8xLk5nTW9kdWxlKHtcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICAgICAgICAgIGRpZmZfZGlyZWN0aXZlXzEuRGlmZkRpcmVjdGl2ZSxcbiAgICAgICAgICAgICAgICBsaW5lRGlmZl9kaXJlY3RpdmVfMS5MaW5lRGlmZkRpcmVjdGl2ZSxcbiAgICAgICAgICAgICAgICBwcm9jZXNzaW5nRGlmZl9kaXJlY3RpdmVfMS5Qcm9jZXNzaW5nRGlmZkRpcmVjdGl2ZSxcbiAgICAgICAgICAgICAgICBzZW1hbnRpY0RpZmZfZGlyZWN0aXZlXzEuU2VtYW50aWNEaWZmRGlyZWN0aXZlLFxuICAgICAgICAgICAgICAgIGxpbmVDb21wYXJlX2NvbXBvbmVudF8xLkxpbmVDb21wYXJlQ29tcG9uZW50XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgaW1wb3J0czogW1xuICAgICAgICAgICAgICAgIGNvbW1vbl8xLkNvbW1vbk1vZHVsZVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGV4cG9ydHM6IFtcbiAgICAgICAgICAgICAgICBkaWZmX2RpcmVjdGl2ZV8xLkRpZmZEaXJlY3RpdmUsXG4gICAgICAgICAgICAgICAgbGluZURpZmZfZGlyZWN0aXZlXzEuTGluZURpZmZEaXJlY3RpdmUsXG4gICAgICAgICAgICAgICAgcHJvY2Vzc2luZ0RpZmZfZGlyZWN0aXZlXzEuUHJvY2Vzc2luZ0RpZmZEaXJlY3RpdmUsXG4gICAgICAgICAgICAgICAgc2VtYW50aWNEaWZmX2RpcmVjdGl2ZV8xLlNlbWFudGljRGlmZkRpcmVjdGl2ZSxcbiAgICAgICAgICAgICAgICBsaW5lQ29tcGFyZV9jb21wb25lbnRfMS5MaW5lQ29tcGFyZUNvbXBvbmVudFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgIGRpZmZNYXRjaFBhdGNoXzEuRGlmZk1hdGNoUGF0Y2gsXG4gICAgICAgICAgICAgICAgZGlmZk1hdGNoUGF0Y2hfc2VydmljZV8xLkRpZmZNYXRjaFBhdGNoU2VydmljZVxuICAgICAgICAgICAgXVxuICAgICAgICB9KVxuICAgIF0sIERpZmZNYXRjaFBhdGNoTW9kdWxlKTtcbiAgICByZXR1cm4gRGlmZk1hdGNoUGF0Y2hNb2R1bGU7XG59KCkpO1xuZXhwb3J0cy5EaWZmTWF0Y2hQYXRjaE1vZHVsZSA9IERpZmZNYXRjaFBhdGNoTW9kdWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGlmZk1hdGNoUGF0Y2gubW9kdWxlLmpzLm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/ng-diff-match-patch/dist/diffMatchPatch.module.js\n");

/***/ }),

/***/ "./node_modules/ng-diff-match-patch/dist/diffMatchPatch.service.js":
/*!*************************************************************************!*\
  !*** ./node_modules/ng-diff-match-patch/dist/diffMatchPatch.service.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar core_1 = __webpack_require__(/*! @angular/core */ \"./node_modules/@angular/core/fesm5/core.js\");\nvar diffMatchPatch_1 = __webpack_require__(/*! ./diffMatchPatch */ \"./node_modules/ng-diff-match-patch/dist/diffMatchPatch.js\");\nvar DiffMatchPatchService = (function () {\n    function DiffMatchPatchService(dmp) {\n        this.dmp = dmp;\n    }\n    DiffMatchPatchService.prototype.ngOnInit = function () {\n    };\n    DiffMatchPatchService.prototype.getDiff = function (left, right) {\n        return this.dmp.diff_main(left, right);\n    };\n    DiffMatchPatchService.prototype.getSemanticDiff = function (left, right) {\n        var diffs = this.dmp.diff_main(left, right);\n        this.dmp.diff_cleanupSemantic(diffs);\n        return diffs;\n    };\n    DiffMatchPatchService.prototype.getProcessingDiff = function (left, right) {\n        var diffs = this.dmp.diff_main(left, right);\n        this.dmp.diff_cleanupEfficiency(diffs);\n        return diffs;\n    };\n    DiffMatchPatchService.prototype.getLineDiff = function (left, right) {\n        var chars = this.dmp.diff_linesToChars_(left, right);\n        var diffs = this.dmp.diff_main(chars.chars1, chars.chars2, false);\n        this.dmp.diff_charsToLines_(diffs, chars.lineArray);\n        return diffs;\n    };\n    DiffMatchPatchService.prototype.getDmp = function () {\n        return this.dmp;\n    };\n    DiffMatchPatchService = __decorate([\n        core_1.Injectable(),\n        __metadata(\"design:paramtypes\", [diffMatchPatch_1.DiffMatchPatch])\n    ], DiffMatchPatchService);\n    return DiffMatchPatchService;\n}());\nexports.DiffMatchPatchService = DiffMatchPatchService;\n//# sourceMappingURL=diffMatchPatch.service.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmctZGlmZi1tYXRjaC1wYXRjaC9kaXN0L2RpZmZNYXRjaFBhdGNoLnNlcnZpY2UuanM/NDc1ZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RCxhQUFhLG1CQUFPLENBQUMsaUVBQWU7QUFDcEMsdUJBQXVCLG1CQUFPLENBQUMsbUZBQWtCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL25nLWRpZmYtbWF0Y2gtcGF0Y2gvZGlzdC9kaWZmTWF0Y2hQYXRjaC5zZXJ2aWNlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb3JlXCIpO1xudmFyIGRpZmZNYXRjaFBhdGNoXzEgPSByZXF1aXJlKFwiLi9kaWZmTWF0Y2hQYXRjaFwiKTtcbnZhciBEaWZmTWF0Y2hQYXRjaFNlcnZpY2UgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERpZmZNYXRjaFBhdGNoU2VydmljZShkbXApIHtcbiAgICAgICAgdGhpcy5kbXAgPSBkbXA7XG4gICAgfVxuICAgIERpZmZNYXRjaFBhdGNoU2VydmljZS5wcm90b3R5cGUubmdPbkluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgfTtcbiAgICBEaWZmTWF0Y2hQYXRjaFNlcnZpY2UucHJvdG90eXBlLmdldERpZmYgPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG1wLmRpZmZfbWFpbihsZWZ0LCByaWdodCk7XG4gICAgfTtcbiAgICBEaWZmTWF0Y2hQYXRjaFNlcnZpY2UucHJvdG90eXBlLmdldFNlbWFudGljRGlmZiA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xuICAgICAgICB2YXIgZGlmZnMgPSB0aGlzLmRtcC5kaWZmX21haW4obGVmdCwgcmlnaHQpO1xuICAgICAgICB0aGlzLmRtcC5kaWZmX2NsZWFudXBTZW1hbnRpYyhkaWZmcyk7XG4gICAgICAgIHJldHVybiBkaWZmcztcbiAgICB9O1xuICAgIERpZmZNYXRjaFBhdGNoU2VydmljZS5wcm90b3R5cGUuZ2V0UHJvY2Vzc2luZ0RpZmYgPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgdmFyIGRpZmZzID0gdGhpcy5kbXAuZGlmZl9tYWluKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgdGhpcy5kbXAuZGlmZl9jbGVhbnVwRWZmaWNpZW5jeShkaWZmcyk7XG4gICAgICAgIHJldHVybiBkaWZmcztcbiAgICB9O1xuICAgIERpZmZNYXRjaFBhdGNoU2VydmljZS5wcm90b3R5cGUuZ2V0TGluZURpZmYgPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgdmFyIGNoYXJzID0gdGhpcy5kbXAuZGlmZl9saW5lc1RvQ2hhcnNfKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgdmFyIGRpZmZzID0gdGhpcy5kbXAuZGlmZl9tYWluKGNoYXJzLmNoYXJzMSwgY2hhcnMuY2hhcnMyLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuZG1wLmRpZmZfY2hhcnNUb0xpbmVzXyhkaWZmcywgY2hhcnMubGluZUFycmF5KTtcbiAgICAgICAgcmV0dXJuIGRpZmZzO1xuICAgIH07XG4gICAgRGlmZk1hdGNoUGF0Y2hTZXJ2aWNlLnByb3RvdHlwZS5nZXREbXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRtcDtcbiAgICB9O1xuICAgIERpZmZNYXRjaFBhdGNoU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBjb3JlXzEuSW5qZWN0YWJsZSgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW2RpZmZNYXRjaFBhdGNoXzEuRGlmZk1hdGNoUGF0Y2hdKVxuICAgIF0sIERpZmZNYXRjaFBhdGNoU2VydmljZSk7XG4gICAgcmV0dXJuIERpZmZNYXRjaFBhdGNoU2VydmljZTtcbn0oKSk7XG5leHBvcnRzLkRpZmZNYXRjaFBhdGNoU2VydmljZSA9IERpZmZNYXRjaFBhdGNoU2VydmljZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRpZmZNYXRjaFBhdGNoLnNlcnZpY2UuanMubWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/ng-diff-match-patch/dist/diffMatchPatch.service.js\n");

/***/ }),

/***/ "./node_modules/ng-diff-match-patch/dist/lineCompare.component.js":
/*!************************************************************************!*\
  !*** ./node_modules/ng-diff-match-patch/dist/lineCompare.component.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar core_1 = __webpack_require__(/*! @angular/core */ \"./node_modules/@angular/core/fesm5/core.js\");\nvar diffMatchPatch_service_1 = __webpack_require__(/*! ./diffMatchPatch.service */ \"./node_modules/ng-diff-match-patch/dist/diffMatchPatch.service.js\");\nvar LineCompareComponent = (function () {\n    function LineCompareComponent(dmp) {\n        this.dmp = dmp;\n    }\n    LineCompareComponent.prototype.ngOnInit = function () {\n        this.updateHtml();\n    };\n    LineCompareComponent.prototype.ngOnChanges = function () {\n        this.updateHtml();\n    };\n    LineCompareComponent.prototype.updateHtml = function () {\n        if (typeof this.left === 'number' || typeof this.left === 'boolean') {\n            this.left = this.left.toString();\n        }\n        if (typeof this.right === 'number' || typeof this.right === 'boolean') {\n            this.right = this.right.toString();\n        }\n        this.calculateLineDiff(this.dmp.getLineDiff(this.left, this.right));\n    };\n    LineCompareComponent.prototype.calculateLineDiff = function (diffs) {\n        var diffCalculation = {\n            lines: [],\n            lineLeft: 1,\n            lineRight: 1\n        };\n        this.isContentEqual = diffs.length === 1 && diffs[0][0] === 0 /* Equal */;\n        if (this.isContentEqual) {\n            this.calculatedDiff = [];\n            return;\n        }\n        for (var i = 0; i < diffs.length; i++) {\n            var diff = diffs[i];\n            var diffLines = diff[1].split(/\\r?\\n/);\n            // If the original line had a \\r\\n at the end then remove the\n            // empty string after it.\n            if (diffLines[diffLines.length - 1].length == 0) {\n                diffLines.pop();\n            }\n            switch (diff[0]) {\n                case 0 /* Equal */: {\n                    var isFirstDiff = i === 0;\n                    var isLastDiff = i === diffs.length - 1;\n                    this.outputEqualDiff(diffLines, diffCalculation, isFirstDiff, isLastDiff);\n                    break;\n                }\n                case -1 /* Delete */: {\n                    this.outputDeleteDiff(diffLines, diffCalculation);\n                    break;\n                }\n                case 1 /* Insert */: {\n                    this.outputInsertDiff(diffLines, diffCalculation);\n                    break;\n                }\n            }\n        }\n        this.calculatedDiff = diffCalculation.lines;\n    };\n    /* If the number of diffLines is greater than lineContextSize then we may need to adjust the diff\n     * that is output.\n     *   > If the first diff of a document is DiffOp.Equal then the leading lines can be dropped\n     *     leaving the last 'lineContextSize' lines for context.\n     *   > If the last diff of a document is DiffOp.Equal then the trailing lines can be dropped\n     *     leaving the first 'lineContextSize' lines for context.\n     *   > If the diff is a DiffOp.Equal occurs in the middle then the diffs either side of it must be\n     *     DiffOp.Insert or DiffOp.Delete. If it has more than 2 * 'lineContextSize' lines of content\n     *     then the middle lines are dropped leaving the first 'lineContextSize' and last 'lineContextSize'\n     *     lines for context. A special line is inserted with '...' indicating that content is skipped.\n     *\n     * A document cannot consist of a single Diff with DiffOp.Equal and reach this function because\n     * in this case the calculateLineDiff method returns early.\n     */\n    LineCompareComponent.prototype.outputEqualDiff = function (diffLines, diffCalculation, isFirstDiff, isLastDiff) {\n        if (this.lineContextSize && diffLines.length > this.lineContextSize) {\n            if (isFirstDiff) {\n                // Take the last 'lineContextSize' lines from the first diff\n                var lineIncrement = diffLines.length - this.lineContextSize;\n                diffCalculation.lineLeft += lineIncrement;\n                diffCalculation.lineRight += lineIncrement;\n                diffLines = diffLines.slice(diffLines.length - this.lineContextSize, diffLines.length);\n            }\n            else if (isLastDiff) {\n                // Take only the first 'lineContextSize' lines from the final diff\n                diffLines = diffLines.slice(0, this.lineContextSize);\n            }\n            else if (diffLines.length > 2 * this.lineContextSize) {\n                // Take the first 'lineContextSize' lines from this diff to provide context for the last diff\n                this.outputEqualDiffLines(diffLines.slice(0, this.lineContextSize), diffCalculation);\n                // Output a special line indicating that some content is equal and has been skipped\n                diffCalculation.lines.push(['dmp-line-compare-equal', '...', '...', '...']);\n                var numberOfSkippedLines = diffLines.length - (2 * this.lineContextSize);\n                diffCalculation.lineLeft += numberOfSkippedLines;\n                diffCalculation.lineRight += numberOfSkippedLines;\n                // Take the last 'lineContextSize' lines from this diff to provide context for the next diff\n                this.outputEqualDiffLines(diffLines.slice(diffLines.length - this.lineContextSize), diffCalculation);\n                // This if branch has already output the diff lines so we return early to avoid outputting the lines\n                // at the end of the method.\n                return;\n            }\n        }\n        this.outputEqualDiffLines(diffLines, diffCalculation);\n    };\n    LineCompareComponent.prototype.outputEqualDiffLines = function (diffLines, diffCalculation) {\n        for (var _i = 0, diffLines_1 = diffLines; _i < diffLines_1.length; _i++) {\n            var line = diffLines_1[_i];\n            diffCalculation.lines.push(['dmp-line-compare-equal', \"\" + diffCalculation.lineLeft, \"\" + diffCalculation.lineRight, line]);\n            diffCalculation.lineLeft++;\n            diffCalculation.lineRight++;\n        }\n    };\n    LineCompareComponent.prototype.outputDeleteDiff = function (diffLines, diffCalculation) {\n        for (var _i = 0, diffLines_2 = diffLines; _i < diffLines_2.length; _i++) {\n            var line = diffLines_2[_i];\n            diffCalculation.lines.push(['dmp-line-compare-delete', \"\" + diffCalculation.lineLeft, '-', line]);\n            diffCalculation.lineLeft++;\n        }\n    };\n    LineCompareComponent.prototype.outputInsertDiff = function (diffLines, diffCalculation) {\n        for (var _i = 0, diffLines_3 = diffLines; _i < diffLines_3.length; _i++) {\n            var line = diffLines_3[_i];\n            diffCalculation.lines.push(['dmp-line-compare-insert', '-', \"\" + diffCalculation.lineRight, line]);\n            diffCalculation.lineRight++;\n        }\n    };\n    __decorate([\n        core_1.Input(),\n        __metadata(\"design:type\", Object)\n    ], LineCompareComponent.prototype, \"left\", void 0);\n    __decorate([\n        core_1.Input(),\n        __metadata(\"design:type\", Object)\n    ], LineCompareComponent.prototype, \"right\", void 0);\n    __decorate([\n        core_1.Input(),\n        __metadata(\"design:type\", Number)\n    ], LineCompareComponent.prototype, \"lineContextSize\", void 0);\n    LineCompareComponent = __decorate([\n        core_1.Component({\n            selector: 'dmp-line-compare',\n            styles: [\"\\n    div.dmp-line-compare {\\n      display: flex;\\n      flex-direction: row;\\n      border: 1px solid #808080;\\n      font-family: Consolas, Courier, monospace;\\n      width: 911px;\\n    }\\n    div.dmp-line-compare-margin {\\n      width: 101px;\\n    }\\n    div.dmp-line-compare-content {\\n      position: relative;\\n      top: 0px;\\n      left: 0px;\\n      flex-grow: 1;\\n      overflow-x: scroll;\\n    }\\n    div.dmp-line-compare-content-wrapper {\\n      position: absolute;\\n      top: 0px;\\n      left: 0px;\\n      display: flex;\\n      flex-direction: column;\\n      align-items: stretch;\\n    }\\n    div.dmp-line-compare-left {\\n      width: 50px;\\n      text-align: center;\\n      color: #484848;\\n    }\\n    div.dmp-line-compare-equal>div.dmp-line-compare-left,\\n      div.dmp-line-compare-equal>div.dmp-line-compare-right {\\n      background-color: #dedede;\\n    }\\n    div.dmp-line-compare-insert>div.dmp-line-compare-left,\\n      div.dmp-line-compare-insert>div.dmp-line-compare-right {\\n      background-color: #8bfb6f;\\n    }\\n    div.dmp-line-compare-delete>div.dmp-line-compare-left,\\n      div.dmp-line-compare-delete>div.dmp-line-compare-right {\\n      background-color: #f56868;\\n    }\\n    div.dmp-line-compare-right {\\n      width: 50px;\\n      text-align: center;\\n      color: #484848;\\n      border-right: 1px solid #888888;\\n    }\\n    div.dmp-line-compare-text {\\n      white-space: pre;\\n      padding-left: 10px;\\n      min-width: 800px;\\n    }\\n    .dmp-line-compare-delete {\\n      background-color: #ff8c8c;\\n    }\\n    .dmp-line-compare-insert {\\n      background-color: #9dff97;\\n    }\\n    .dmp-line-compare-delete>div {\\n      display: inline-block;\\n    }  \\n    .dmp-line-compare-insert>div {\\n      display: inline-block;\\n    }\\n    .dmp-line-compare-equal>div {\\n      display: inline-block;\\n    }\\n    .dmp-margin-bottom-spacer {\\n      height: 20px;\\n      background-color: #dedede;\\n      border-right: 1px solid #888888;\\n    }\\n  \"],\n            template: \"\\n    <div class=\\\"dmp-line-compare-no-changes-text\\\" *ngIf=\\\"isContentEqual\\\">\\n      There are no changes to display.\\n    </div>    \\n    <div class=\\\"dmp-line-compare\\\" *ngIf=\\\"!isContentEqual\\\">\\n      <div class=\\\"dmp-line-compare-margin\\\">\\n        <div [ngClass]=\\\"lineDiff[0]\\\" *ngFor=\\\"let lineDiff of calculatedDiff\\\">\\n          <div class=\\\"dmp-line-compare-left\\\">{{lineDiff[1]}}</div><!-- No space\\n        --><div class=\\\"dmp-line-compare-right\\\">{{lineDiff[2]}}</div>\\n        </div>\\n        <div class=\\\"dmp-margin-bottom-spacer\\\"></div>\\n      </div><!-- No space\\n   --><div class=\\\"dmp-line-compare-content\\\">\\n        <div class=\\\"dmp-line-compare-content-wrapper\\\">\\n          <div [ngClass]=\\\"lineDiff[0]\\\" *ngFor=\\\"let lineDiff of calculatedDiff\\\">\\n            <div class=\\\"dmp-line-compare-text\\\">{{lineDiff[3]}}</div>\\n          </div>\\n        </div>\\n      </div>\\n    </div>\\n  \"\n        }),\n        __metadata(\"design:paramtypes\", [diffMatchPatch_service_1.DiffMatchPatchService])\n    ], LineCompareComponent);\n    return LineCompareComponent;\n}());\nexports.LineCompareComponent = LineCompareComponent;\n//# sourceMappingURL=lineCompare.component.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmctZGlmZi1tYXRjaC1wYXRjaC9kaXN0L2xpbmVDb21wYXJlLmNvbXBvbmVudC5qcz80NmI0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVELGFBQWEsbUJBQU8sQ0FBQyxpRUFBZTtBQUNwQywrQkFBK0IsbUJBQU8sQ0FBQyxtR0FBMEI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtCQUFrQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELHlCQUF5QjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCx5QkFBeUI7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELHlCQUF5QjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELHNCQUFzQiw0QkFBNEIsa0NBQWtDLGtEQUFrRCxxQkFBcUIsT0FBTyxtQ0FBbUMscUJBQXFCLE9BQU8sb0NBQW9DLDJCQUEyQixpQkFBaUIsa0JBQWtCLHFCQUFxQiwyQkFBMkIsT0FBTyw0Q0FBNEMsMkJBQTJCLGlCQUFpQixrQkFBa0Isc0JBQXNCLCtCQUErQiw2QkFBNkIsT0FBTyxpQ0FBaUMsb0JBQW9CLDJCQUEyQix1QkFBdUIsT0FBTywwSEFBMEgsa0NBQWtDLE9BQU8sNEhBQTRILGtDQUFrQyxPQUFPLDRIQUE0SCxrQ0FBa0MsT0FBTyxrQ0FBa0Msb0JBQW9CLDJCQUEyQix1QkFBdUIsd0NBQXdDLE9BQU8saUNBQWlDLHlCQUF5QiwyQkFBMkIseUJBQXlCLE9BQU8sZ0NBQWdDLGtDQUFrQyxPQUFPLGdDQUFnQyxrQ0FBa0MsT0FBTyxvQ0FBb0MsOEJBQThCLE9BQU8sc0NBQXNDLDhCQUE4QixPQUFPLG1DQUFtQyw4QkFBOEIsT0FBTyxpQ0FBaUMscUJBQXFCLGtDQUFrQyx3Q0FBd0MsT0FBTztBQUMzOEQsbVpBQW1aLGFBQWEsd0VBQXdFLGFBQWEsNlZBQTZWLGFBQWE7QUFDLzFCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9uZy1kaWZmLW1hdGNoLXBhdGNoL2Rpc3QvbGluZUNvbXBhcmUuY29tcG9uZW50LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb3JlXCIpO1xudmFyIGRpZmZNYXRjaFBhdGNoX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL2RpZmZNYXRjaFBhdGNoLnNlcnZpY2VcIik7XG52YXIgTGluZUNvbXBhcmVDb21wb25lbnQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExpbmVDb21wYXJlQ29tcG9uZW50KGRtcCkge1xuICAgICAgICB0aGlzLmRtcCA9IGRtcDtcbiAgICB9XG4gICAgTGluZUNvbXBhcmVDb21wb25lbnQucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZUh0bWwoKTtcbiAgICB9O1xuICAgIExpbmVDb21wYXJlQ29tcG9uZW50LnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVIdG1sKCk7XG4gICAgfTtcbiAgICBMaW5lQ29tcGFyZUNvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlSHRtbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmxlZnQgPT09ICdudW1iZXInIHx8IHR5cGVvZiB0aGlzLmxlZnQgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgdGhpcy5sZWZ0ID0gdGhpcy5sZWZ0LnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnJpZ2h0ID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgdGhpcy5yaWdodCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICB0aGlzLnJpZ2h0ID0gdGhpcy5yaWdodC50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FsY3VsYXRlTGluZURpZmYodGhpcy5kbXAuZ2V0TGluZURpZmYodGhpcy5sZWZ0LCB0aGlzLnJpZ2h0KSk7XG4gICAgfTtcbiAgICBMaW5lQ29tcGFyZUNvbXBvbmVudC5wcm90b3R5cGUuY2FsY3VsYXRlTGluZURpZmYgPSBmdW5jdGlvbiAoZGlmZnMpIHtcbiAgICAgICAgdmFyIGRpZmZDYWxjdWxhdGlvbiA9IHtcbiAgICAgICAgICAgIGxpbmVzOiBbXSxcbiAgICAgICAgICAgIGxpbmVMZWZ0OiAxLFxuICAgICAgICAgICAgbGluZVJpZ2h0OiAxXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaXNDb250ZW50RXF1YWwgPSBkaWZmcy5sZW5ndGggPT09IDEgJiYgZGlmZnNbMF1bMF0gPT09IDAgLyogRXF1YWwgKi87XG4gICAgICAgIGlmICh0aGlzLmlzQ29udGVudEVxdWFsKSB7XG4gICAgICAgICAgICB0aGlzLmNhbGN1bGF0ZWREaWZmID0gW107XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaWZmcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGRpZmYgPSBkaWZmc1tpXTtcbiAgICAgICAgICAgIHZhciBkaWZmTGluZXMgPSBkaWZmWzFdLnNwbGl0KC9cXHI/XFxuLyk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgb3JpZ2luYWwgbGluZSBoYWQgYSBcXHJcXG4gYXQgdGhlIGVuZCB0aGVuIHJlbW92ZSB0aGVcbiAgICAgICAgICAgIC8vIGVtcHR5IHN0cmluZyBhZnRlciBpdC5cbiAgICAgICAgICAgIGlmIChkaWZmTGluZXNbZGlmZkxpbmVzLmxlbmd0aCAtIDFdLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgZGlmZkxpbmVzLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoIChkaWZmWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwIC8qIEVxdWFsICovOiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpc0ZpcnN0RGlmZiA9IGkgPT09IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpc0xhc3REaWZmID0gaSA9PT0gZGlmZnMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vdXRwdXRFcXVhbERpZmYoZGlmZkxpbmVzLCBkaWZmQ2FsY3VsYXRpb24sIGlzRmlyc3REaWZmLCBpc0xhc3REaWZmKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgLTEgLyogRGVsZXRlICovOiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0RGVsZXRlRGlmZihkaWZmTGluZXMsIGRpZmZDYWxjdWxhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIDEgLyogSW5zZXJ0ICovOiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0SW5zZXJ0RGlmZihkaWZmTGluZXMsIGRpZmZDYWxjdWxhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhbGN1bGF0ZWREaWZmID0gZGlmZkNhbGN1bGF0aW9uLmxpbmVzO1xuICAgIH07XG4gICAgLyogSWYgdGhlIG51bWJlciBvZiBkaWZmTGluZXMgaXMgZ3JlYXRlciB0aGFuIGxpbmVDb250ZXh0U2l6ZSB0aGVuIHdlIG1heSBuZWVkIHRvIGFkanVzdCB0aGUgZGlmZlxuICAgICAqIHRoYXQgaXMgb3V0cHV0LlxuICAgICAqICAgPiBJZiB0aGUgZmlyc3QgZGlmZiBvZiBhIGRvY3VtZW50IGlzIERpZmZPcC5FcXVhbCB0aGVuIHRoZSBsZWFkaW5nIGxpbmVzIGNhbiBiZSBkcm9wcGVkXG4gICAgICogICAgIGxlYXZpbmcgdGhlIGxhc3QgJ2xpbmVDb250ZXh0U2l6ZScgbGluZXMgZm9yIGNvbnRleHQuXG4gICAgICogICA+IElmIHRoZSBsYXN0IGRpZmYgb2YgYSBkb2N1bWVudCBpcyBEaWZmT3AuRXF1YWwgdGhlbiB0aGUgdHJhaWxpbmcgbGluZXMgY2FuIGJlIGRyb3BwZWRcbiAgICAgKiAgICAgbGVhdmluZyB0aGUgZmlyc3QgJ2xpbmVDb250ZXh0U2l6ZScgbGluZXMgZm9yIGNvbnRleHQuXG4gICAgICogICA+IElmIHRoZSBkaWZmIGlzIGEgRGlmZk9wLkVxdWFsIG9jY3VycyBpbiB0aGUgbWlkZGxlIHRoZW4gdGhlIGRpZmZzIGVpdGhlciBzaWRlIG9mIGl0IG11c3QgYmVcbiAgICAgKiAgICAgRGlmZk9wLkluc2VydCBvciBEaWZmT3AuRGVsZXRlLiBJZiBpdCBoYXMgbW9yZSB0aGFuIDIgKiAnbGluZUNvbnRleHRTaXplJyBsaW5lcyBvZiBjb250ZW50XG4gICAgICogICAgIHRoZW4gdGhlIG1pZGRsZSBsaW5lcyBhcmUgZHJvcHBlZCBsZWF2aW5nIHRoZSBmaXJzdCAnbGluZUNvbnRleHRTaXplJyBhbmQgbGFzdCAnbGluZUNvbnRleHRTaXplJ1xuICAgICAqICAgICBsaW5lcyBmb3IgY29udGV4dC4gQSBzcGVjaWFsIGxpbmUgaXMgaW5zZXJ0ZWQgd2l0aCAnLi4uJyBpbmRpY2F0aW5nIHRoYXQgY29udGVudCBpcyBza2lwcGVkLlxuICAgICAqXG4gICAgICogQSBkb2N1bWVudCBjYW5ub3QgY29uc2lzdCBvZiBhIHNpbmdsZSBEaWZmIHdpdGggRGlmZk9wLkVxdWFsIGFuZCByZWFjaCB0aGlzIGZ1bmN0aW9uIGJlY2F1c2VcbiAgICAgKiBpbiB0aGlzIGNhc2UgdGhlIGNhbGN1bGF0ZUxpbmVEaWZmIG1ldGhvZCByZXR1cm5zIGVhcmx5LlxuICAgICAqL1xuICAgIExpbmVDb21wYXJlQ29tcG9uZW50LnByb3RvdHlwZS5vdXRwdXRFcXVhbERpZmYgPSBmdW5jdGlvbiAoZGlmZkxpbmVzLCBkaWZmQ2FsY3VsYXRpb24sIGlzRmlyc3REaWZmLCBpc0xhc3REaWZmKSB7XG4gICAgICAgIGlmICh0aGlzLmxpbmVDb250ZXh0U2l6ZSAmJiBkaWZmTGluZXMubGVuZ3RoID4gdGhpcy5saW5lQ29udGV4dFNpemUpIHtcbiAgICAgICAgICAgIGlmIChpc0ZpcnN0RGlmZikge1xuICAgICAgICAgICAgICAgIC8vIFRha2UgdGhlIGxhc3QgJ2xpbmVDb250ZXh0U2l6ZScgbGluZXMgZnJvbSB0aGUgZmlyc3QgZGlmZlxuICAgICAgICAgICAgICAgIHZhciBsaW5lSW5jcmVtZW50ID0gZGlmZkxpbmVzLmxlbmd0aCAtIHRoaXMubGluZUNvbnRleHRTaXplO1xuICAgICAgICAgICAgICAgIGRpZmZDYWxjdWxhdGlvbi5saW5lTGVmdCArPSBsaW5lSW5jcmVtZW50O1xuICAgICAgICAgICAgICAgIGRpZmZDYWxjdWxhdGlvbi5saW5lUmlnaHQgKz0gbGluZUluY3JlbWVudDtcbiAgICAgICAgICAgICAgICBkaWZmTGluZXMgPSBkaWZmTGluZXMuc2xpY2UoZGlmZkxpbmVzLmxlbmd0aCAtIHRoaXMubGluZUNvbnRleHRTaXplLCBkaWZmTGluZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzTGFzdERpZmYpIHtcbiAgICAgICAgICAgICAgICAvLyBUYWtlIG9ubHkgdGhlIGZpcnN0ICdsaW5lQ29udGV4dFNpemUnIGxpbmVzIGZyb20gdGhlIGZpbmFsIGRpZmZcbiAgICAgICAgICAgICAgICBkaWZmTGluZXMgPSBkaWZmTGluZXMuc2xpY2UoMCwgdGhpcy5saW5lQ29udGV4dFNpemUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGlmZkxpbmVzLmxlbmd0aCA+IDIgKiB0aGlzLmxpbmVDb250ZXh0U2l6ZSkge1xuICAgICAgICAgICAgICAgIC8vIFRha2UgdGhlIGZpcnN0ICdsaW5lQ29udGV4dFNpemUnIGxpbmVzIGZyb20gdGhpcyBkaWZmIHRvIHByb3ZpZGUgY29udGV4dCBmb3IgdGhlIGxhc3QgZGlmZlxuICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0RXF1YWxEaWZmTGluZXMoZGlmZkxpbmVzLnNsaWNlKDAsIHRoaXMubGluZUNvbnRleHRTaXplKSwgZGlmZkNhbGN1bGF0aW9uKTtcbiAgICAgICAgICAgICAgICAvLyBPdXRwdXQgYSBzcGVjaWFsIGxpbmUgaW5kaWNhdGluZyB0aGF0IHNvbWUgY29udGVudCBpcyBlcXVhbCBhbmQgaGFzIGJlZW4gc2tpcHBlZFxuICAgICAgICAgICAgICAgIGRpZmZDYWxjdWxhdGlvbi5saW5lcy5wdXNoKFsnZG1wLWxpbmUtY29tcGFyZS1lcXVhbCcsICcuLi4nLCAnLi4uJywgJy4uLiddKTtcbiAgICAgICAgICAgICAgICB2YXIgbnVtYmVyT2ZTa2lwcGVkTGluZXMgPSBkaWZmTGluZXMubGVuZ3RoIC0gKDIgKiB0aGlzLmxpbmVDb250ZXh0U2l6ZSk7XG4gICAgICAgICAgICAgICAgZGlmZkNhbGN1bGF0aW9uLmxpbmVMZWZ0ICs9IG51bWJlck9mU2tpcHBlZExpbmVzO1xuICAgICAgICAgICAgICAgIGRpZmZDYWxjdWxhdGlvbi5saW5lUmlnaHQgKz0gbnVtYmVyT2ZTa2lwcGVkTGluZXM7XG4gICAgICAgICAgICAgICAgLy8gVGFrZSB0aGUgbGFzdCAnbGluZUNvbnRleHRTaXplJyBsaW5lcyBmcm9tIHRoaXMgZGlmZiB0byBwcm92aWRlIGNvbnRleHQgZm9yIHRoZSBuZXh0IGRpZmZcbiAgICAgICAgICAgICAgICB0aGlzLm91dHB1dEVxdWFsRGlmZkxpbmVzKGRpZmZMaW5lcy5zbGljZShkaWZmTGluZXMubGVuZ3RoIC0gdGhpcy5saW5lQ29udGV4dFNpemUpLCBkaWZmQ2FsY3VsYXRpb24pO1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgaWYgYnJhbmNoIGhhcyBhbHJlYWR5IG91dHB1dCB0aGUgZGlmZiBsaW5lcyBzbyB3ZSByZXR1cm4gZWFybHkgdG8gYXZvaWQgb3V0cHV0dGluZyB0aGUgbGluZXNcbiAgICAgICAgICAgICAgICAvLyBhdCB0aGUgZW5kIG9mIHRoZSBtZXRob2QuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMub3V0cHV0RXF1YWxEaWZmTGluZXMoZGlmZkxpbmVzLCBkaWZmQ2FsY3VsYXRpb24pO1xuICAgIH07XG4gICAgTGluZUNvbXBhcmVDb21wb25lbnQucHJvdG90eXBlLm91dHB1dEVxdWFsRGlmZkxpbmVzID0gZnVuY3Rpb24gKGRpZmZMaW5lcywgZGlmZkNhbGN1bGF0aW9uKSB7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgZGlmZkxpbmVzXzEgPSBkaWZmTGluZXM7IF9pIDwgZGlmZkxpbmVzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgbGluZSA9IGRpZmZMaW5lc18xW19pXTtcbiAgICAgICAgICAgIGRpZmZDYWxjdWxhdGlvbi5saW5lcy5wdXNoKFsnZG1wLWxpbmUtY29tcGFyZS1lcXVhbCcsIFwiXCIgKyBkaWZmQ2FsY3VsYXRpb24ubGluZUxlZnQsIFwiXCIgKyBkaWZmQ2FsY3VsYXRpb24ubGluZVJpZ2h0LCBsaW5lXSk7XG4gICAgICAgICAgICBkaWZmQ2FsY3VsYXRpb24ubGluZUxlZnQrKztcbiAgICAgICAgICAgIGRpZmZDYWxjdWxhdGlvbi5saW5lUmlnaHQrKztcbiAgICAgICAgfVxuICAgIH07XG4gICAgTGluZUNvbXBhcmVDb21wb25lbnQucHJvdG90eXBlLm91dHB1dERlbGV0ZURpZmYgPSBmdW5jdGlvbiAoZGlmZkxpbmVzLCBkaWZmQ2FsY3VsYXRpb24pIHtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBkaWZmTGluZXNfMiA9IGRpZmZMaW5lczsgX2kgPCBkaWZmTGluZXNfMi5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBsaW5lID0gZGlmZkxpbmVzXzJbX2ldO1xuICAgICAgICAgICAgZGlmZkNhbGN1bGF0aW9uLmxpbmVzLnB1c2goWydkbXAtbGluZS1jb21wYXJlLWRlbGV0ZScsIFwiXCIgKyBkaWZmQ2FsY3VsYXRpb24ubGluZUxlZnQsICctJywgbGluZV0pO1xuICAgICAgICAgICAgZGlmZkNhbGN1bGF0aW9uLmxpbmVMZWZ0Kys7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExpbmVDb21wYXJlQ29tcG9uZW50LnByb3RvdHlwZS5vdXRwdXRJbnNlcnREaWZmID0gZnVuY3Rpb24gKGRpZmZMaW5lcywgZGlmZkNhbGN1bGF0aW9uKSB7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgZGlmZkxpbmVzXzMgPSBkaWZmTGluZXM7IF9pIDwgZGlmZkxpbmVzXzMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgbGluZSA9IGRpZmZMaW5lc18zW19pXTtcbiAgICAgICAgICAgIGRpZmZDYWxjdWxhdGlvbi5saW5lcy5wdXNoKFsnZG1wLWxpbmUtY29tcGFyZS1pbnNlcnQnLCAnLScsIFwiXCIgKyBkaWZmQ2FsY3VsYXRpb24ubGluZVJpZ2h0LCBsaW5lXSk7XG4gICAgICAgICAgICBkaWZmQ2FsY3VsYXRpb24ubGluZVJpZ2h0Kys7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBMaW5lQ29tcGFyZUNvbXBvbmVudC5wcm90b3R5cGUsIFwibGVmdFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBMaW5lQ29tcGFyZUNvbXBvbmVudC5wcm90b3R5cGUsIFwicmlnaHRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29yZV8xLklucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG4gICAgXSwgTGluZUNvbXBhcmVDb21wb25lbnQucHJvdG90eXBlLCBcImxpbmVDb250ZXh0U2l6ZVwiLCB2b2lkIDApO1xuICAgIExpbmVDb21wYXJlQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgICAgIGNvcmVfMS5Db21wb25lbnQoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdkbXAtbGluZS1jb21wYXJlJyxcbiAgICAgICAgICAgIHN0eWxlczogW1wiXFxuICAgIGRpdi5kbXAtbGluZS1jb21wYXJlIHtcXG4gICAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XFxuICAgICAgYm9yZGVyOiAxcHggc29saWQgIzgwODA4MDtcXG4gICAgICBmb250LWZhbWlseTogQ29uc29sYXMsIENvdXJpZXIsIG1vbm9zcGFjZTtcXG4gICAgICB3aWR0aDogOTExcHg7XFxuICAgIH1cXG4gICAgZGl2LmRtcC1saW5lLWNvbXBhcmUtbWFyZ2luIHtcXG4gICAgICB3aWR0aDogMTAxcHg7XFxuICAgIH1cXG4gICAgZGl2LmRtcC1saW5lLWNvbXBhcmUtY29udGVudCB7XFxuICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICAgIHRvcDogMHB4O1xcbiAgICAgIGxlZnQ6IDBweDtcXG4gICAgICBmbGV4LWdyb3c6IDE7XFxuICAgICAgb3ZlcmZsb3cteDogc2Nyb2xsO1xcbiAgICB9XFxuICAgIGRpdi5kbXAtbGluZS1jb21wYXJlLWNvbnRlbnQtd3JhcHBlciB7XFxuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICAgIHRvcDogMHB4O1xcbiAgICAgIGxlZnQ6IDBweDtcXG4gICAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICAgICAgYWxpZ24taXRlbXM6IHN0cmV0Y2g7XFxuICAgIH1cXG4gICAgZGl2LmRtcC1saW5lLWNvbXBhcmUtbGVmdCB7XFxuICAgICAgd2lkdGg6IDUwcHg7XFxuICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgICAgIGNvbG9yOiAjNDg0ODQ4O1xcbiAgICB9XFxuICAgIGRpdi5kbXAtbGluZS1jb21wYXJlLWVxdWFsPmRpdi5kbXAtbGluZS1jb21wYXJlLWxlZnQsXFxuICAgICAgZGl2LmRtcC1saW5lLWNvbXBhcmUtZXF1YWw+ZGl2LmRtcC1saW5lLWNvbXBhcmUtcmlnaHQge1xcbiAgICAgIGJhY2tncm91bmQtY29sb3I6ICNkZWRlZGU7XFxuICAgIH1cXG4gICAgZGl2LmRtcC1saW5lLWNvbXBhcmUtaW5zZXJ0PmRpdi5kbXAtbGluZS1jb21wYXJlLWxlZnQsXFxuICAgICAgZGl2LmRtcC1saW5lLWNvbXBhcmUtaW5zZXJ0PmRpdi5kbXAtbGluZS1jb21wYXJlLXJpZ2h0IHtcXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjOGJmYjZmO1xcbiAgICB9XFxuICAgIGRpdi5kbXAtbGluZS1jb21wYXJlLWRlbGV0ZT5kaXYuZG1wLWxpbmUtY29tcGFyZS1sZWZ0LFxcbiAgICAgIGRpdi5kbXAtbGluZS1jb21wYXJlLWRlbGV0ZT5kaXYuZG1wLWxpbmUtY29tcGFyZS1yaWdodCB7XFxuICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2Y1Njg2ODtcXG4gICAgfVxcbiAgICBkaXYuZG1wLWxpbmUtY29tcGFyZS1yaWdodCB7XFxuICAgICAgd2lkdGg6IDUwcHg7XFxuICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgICAgIGNvbG9yOiAjNDg0ODQ4O1xcbiAgICAgIGJvcmRlci1yaWdodDogMXB4IHNvbGlkICM4ODg4ODg7XFxuICAgIH1cXG4gICAgZGl2LmRtcC1saW5lLWNvbXBhcmUtdGV4dCB7XFxuICAgICAgd2hpdGUtc3BhY2U6IHByZTtcXG4gICAgICBwYWRkaW5nLWxlZnQ6IDEwcHg7XFxuICAgICAgbWluLXdpZHRoOiA4MDBweDtcXG4gICAgfVxcbiAgICAuZG1wLWxpbmUtY29tcGFyZS1kZWxldGUge1xcbiAgICAgIGJhY2tncm91bmQtY29sb3I6ICNmZjhjOGM7XFxuICAgIH1cXG4gICAgLmRtcC1saW5lLWNvbXBhcmUtaW5zZXJ0IHtcXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjOWRmZjk3O1xcbiAgICB9XFxuICAgIC5kbXAtbGluZS1jb21wYXJlLWRlbGV0ZT5kaXYge1xcbiAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gICAgfSAgXFxuICAgIC5kbXAtbGluZS1jb21wYXJlLWluc2VydD5kaXYge1xcbiAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gICAgfVxcbiAgICAuZG1wLWxpbmUtY29tcGFyZS1lcXVhbD5kaXYge1xcbiAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gICAgfVxcbiAgICAuZG1wLW1hcmdpbi1ib3R0b20tc3BhY2VyIHtcXG4gICAgICBoZWlnaHQ6IDIwcHg7XFxuICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2RlZGVkZTtcXG4gICAgICBib3JkZXItcmlnaHQ6IDFweCBzb2xpZCAjODg4ODg4O1xcbiAgICB9XFxuICBcIl0sXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPGRpdiBjbGFzcz1cXFwiZG1wLWxpbmUtY29tcGFyZS1uby1jaGFuZ2VzLXRleHRcXFwiICpuZ0lmPVxcXCJpc0NvbnRlbnRFcXVhbFxcXCI+XFxuICAgICAgVGhlcmUgYXJlIG5vIGNoYW5nZXMgdG8gZGlzcGxheS5cXG4gICAgPC9kaXY+ICAgIFxcbiAgICA8ZGl2IGNsYXNzPVxcXCJkbXAtbGluZS1jb21wYXJlXFxcIiAqbmdJZj1cXFwiIWlzQ29udGVudEVxdWFsXFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJkbXAtbGluZS1jb21wYXJlLW1hcmdpblxcXCI+XFxuICAgICAgICA8ZGl2IFtuZ0NsYXNzXT1cXFwibGluZURpZmZbMF1cXFwiICpuZ0Zvcj1cXFwibGV0IGxpbmVEaWZmIG9mIGNhbGN1bGF0ZWREaWZmXFxcIj5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZG1wLWxpbmUtY29tcGFyZS1sZWZ0XFxcIj57e2xpbmVEaWZmWzFdfX08L2Rpdj48IS0tIE5vIHNwYWNlXFxuICAgICAgICAtLT48ZGl2IGNsYXNzPVxcXCJkbXAtbGluZS1jb21wYXJlLXJpZ2h0XFxcIj57e2xpbmVEaWZmWzJdfX08L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiZG1wLW1hcmdpbi1ib3R0b20tc3BhY2VyXFxcIj48L2Rpdj5cXG4gICAgICA8L2Rpdj48IS0tIE5vIHNwYWNlXFxuICAgLS0+PGRpdiBjbGFzcz1cXFwiZG1wLWxpbmUtY29tcGFyZS1jb250ZW50XFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImRtcC1saW5lLWNvbXBhcmUtY29udGVudC13cmFwcGVyXFxcIj5cXG4gICAgICAgICAgPGRpdiBbbmdDbGFzc109XFxcImxpbmVEaWZmWzBdXFxcIiAqbmdGb3I9XFxcImxldCBsaW5lRGlmZiBvZiBjYWxjdWxhdGVkRGlmZlxcXCI+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZG1wLWxpbmUtY29tcGFyZS10ZXh0XFxcIj57e2xpbmVEaWZmWzNdfX08L2Rpdj5cXG4gICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICBcIlxuICAgICAgICB9KSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtkaWZmTWF0Y2hQYXRjaF9zZXJ2aWNlXzEuRGlmZk1hdGNoUGF0Y2hTZXJ2aWNlXSlcbiAgICBdLCBMaW5lQ29tcGFyZUNvbXBvbmVudCk7XG4gICAgcmV0dXJuIExpbmVDb21wYXJlQ29tcG9uZW50O1xufSgpKTtcbmV4cG9ydHMuTGluZUNvbXBhcmVDb21wb25lbnQgPSBMaW5lQ29tcGFyZUNvbXBvbmVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpbmVDb21wYXJlLmNvbXBvbmVudC5qcy5tYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/ng-diff-match-patch/dist/lineCompare.component.js\n");

/***/ }),

/***/ "./node_modules/ng-diff-match-patch/dist/lineDiff.directive.js":
/*!*********************************************************************!*\
  !*** ./node_modules/ng-diff-match-patch/dist/lineDiff.directive.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar core_1 = __webpack_require__(/*! @angular/core */ \"./node_modules/@angular/core/fesm5/core.js\");\nvar diffMatchPatch_service_1 = __webpack_require__(/*! ./diffMatchPatch.service */ \"./node_modules/ng-diff-match-patch/dist/diffMatchPatch.service.js\");\nvar LineDiffDirective = (function () {\n    function LineDiffDirective(el, dmp) {\n        this.el = el;\n        this.dmp = dmp;\n    }\n    LineDiffDirective.prototype.ngOnInit = function () {\n        this.updateHtml();\n    };\n    LineDiffDirective.prototype.ngOnChanges = function () {\n        this.updateHtml();\n    };\n    LineDiffDirective.prototype.updateHtml = function () {\n        if (typeof this.left === 'number' || typeof this.left === 'boolean') {\n            this.left = this.left.toString();\n        }\n        if (typeof this.right === 'number' || typeof this.right === 'boolean') {\n            this.right = this.right.toString();\n        }\n        this.el.nativeElement.innerHTML = this.createHtml(this.dmp.getLineDiff(this.left, this.right));\n    };\n    // TODO: Need to fix this for line diffs\n    LineDiffDirective.prototype.createHtml = function (diffs) {\n        var html;\n        html = '<div>';\n        for (var _i = 0, diffs_1 = diffs; _i < diffs_1.length; _i++) {\n            var diff = diffs_1[_i];\n            if (diff[0] === 0 /* Equal */) {\n                html += diff[1];\n            }\n            if (diff[0] === -1 /* Delete */) {\n                html += '<div class=\\\"del\\\"> - <del>' + diff[1] + '</del></div>\\n';\n            }\n            if (diff[0] === 1 /* Insert */) {\n                html += '<div class=\\\"ins\\\"> + <ins>' + diff[1] + '</ins></div>\\n';\n            }\n        }\n        html += '</div>';\n        return html;\n    };\n    __decorate([\n        core_1.Input(),\n        __metadata(\"design:type\", Object)\n    ], LineDiffDirective.prototype, \"left\", void 0);\n    __decorate([\n        core_1.Input(),\n        __metadata(\"design:type\", Object)\n    ], LineDiffDirective.prototype, \"right\", void 0);\n    LineDiffDirective = __decorate([\n        core_1.Directive({\n            selector: '[lineDiff]',\n        }),\n        __metadata(\"design:paramtypes\", [core_1.ElementRef,\n            diffMatchPatch_service_1.DiffMatchPatchService])\n    ], LineDiffDirective);\n    return LineDiffDirective;\n}());\nexports.LineDiffDirective = LineDiffDirective;\n//# sourceMappingURL=lineDiff.directive.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmctZGlmZi1tYXRjaC1wYXRjaC9kaXN0L2xpbmVEaWZmLmRpcmVjdGl2ZS5qcz9kZTJlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVELGFBQWEsbUJBQU8sQ0FBQyxpRUFBZTtBQUNwQywrQkFBK0IsbUJBQU8sQ0FBQyxtR0FBMEI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHFCQUFxQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL25nLWRpZmYtbWF0Y2gtcGF0Y2gvZGlzdC9saW5lRGlmZi5kaXJlY3RpdmUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29yZV8xID0gcmVxdWlyZShcIkBhbmd1bGFyL2NvcmVcIik7XG52YXIgZGlmZk1hdGNoUGF0Y2hfc2VydmljZV8xID0gcmVxdWlyZShcIi4vZGlmZk1hdGNoUGF0Y2guc2VydmljZVwiKTtcbnZhciBMaW5lRGlmZkRpcmVjdGl2ZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTGluZURpZmZEaXJlY3RpdmUoZWwsIGRtcCkge1xuICAgICAgICB0aGlzLmVsID0gZWw7XG4gICAgICAgIHRoaXMuZG1wID0gZG1wO1xuICAgIH1cbiAgICBMaW5lRGlmZkRpcmVjdGl2ZS5wcm90b3R5cGUubmdPbkluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlSHRtbCgpO1xuICAgIH07XG4gICAgTGluZURpZmZEaXJlY3RpdmUucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZUh0bWwoKTtcbiAgICB9O1xuICAgIExpbmVEaWZmRGlyZWN0aXZlLnByb3RvdHlwZS51cGRhdGVIdG1sID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMubGVmdCA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHRoaXMubGVmdCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICB0aGlzLmxlZnQgPSB0aGlzLmxlZnQudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRoaXMucmlnaHQgPT09ICdudW1iZXInIHx8IHR5cGVvZiB0aGlzLnJpZ2h0ID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHRoaXMucmlnaHQgPSB0aGlzLnJpZ2h0LnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbC5uYXRpdmVFbGVtZW50LmlubmVySFRNTCA9IHRoaXMuY3JlYXRlSHRtbCh0aGlzLmRtcC5nZXRMaW5lRGlmZih0aGlzLmxlZnQsIHRoaXMucmlnaHQpKTtcbiAgICB9O1xuICAgIC8vIFRPRE86IE5lZWQgdG8gZml4IHRoaXMgZm9yIGxpbmUgZGlmZnNcbiAgICBMaW5lRGlmZkRpcmVjdGl2ZS5wcm90b3R5cGUuY3JlYXRlSHRtbCA9IGZ1bmN0aW9uIChkaWZmcykge1xuICAgICAgICB2YXIgaHRtbDtcbiAgICAgICAgaHRtbCA9ICc8ZGl2Pic7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgZGlmZnNfMSA9IGRpZmZzOyBfaSA8IGRpZmZzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgZGlmZiA9IGRpZmZzXzFbX2ldO1xuICAgICAgICAgICAgaWYgKGRpZmZbMF0gPT09IDAgLyogRXF1YWwgKi8pIHtcbiAgICAgICAgICAgICAgICBodG1sICs9IGRpZmZbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGlmZlswXSA9PT0gLTEgLyogRGVsZXRlICovKSB7XG4gICAgICAgICAgICAgICAgaHRtbCArPSAnPGRpdiBjbGFzcz1cXFwiZGVsXFxcIj4gLSA8ZGVsPicgKyBkaWZmWzFdICsgJzwvZGVsPjwvZGl2Plxcbic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGlmZlswXSA9PT0gMSAvKiBJbnNlcnQgKi8pIHtcbiAgICAgICAgICAgICAgICBodG1sICs9ICc8ZGl2IGNsYXNzPVxcXCJpbnNcXFwiPiArIDxpbnM+JyArIGRpZmZbMV0gKyAnPC9pbnM+PC9kaXY+XFxuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBodG1sICs9ICc8L2Rpdj4nO1xuICAgICAgICByZXR1cm4gaHRtbDtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBMaW5lRGlmZkRpcmVjdGl2ZS5wcm90b3R5cGUsIFwibGVmdFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBMaW5lRGlmZkRpcmVjdGl2ZS5wcm90b3R5cGUsIFwicmlnaHRcIiwgdm9pZCAwKTtcbiAgICBMaW5lRGlmZkRpcmVjdGl2ZSA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBjb3JlXzEuRGlyZWN0aXZlKHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnW2xpbmVEaWZmXScsXG4gICAgICAgIH0pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW2NvcmVfMS5FbGVtZW50UmVmLFxuICAgICAgICAgICAgZGlmZk1hdGNoUGF0Y2hfc2VydmljZV8xLkRpZmZNYXRjaFBhdGNoU2VydmljZV0pXG4gICAgXSwgTGluZURpZmZEaXJlY3RpdmUpO1xuICAgIHJldHVybiBMaW5lRGlmZkRpcmVjdGl2ZTtcbn0oKSk7XG5leHBvcnRzLkxpbmVEaWZmRGlyZWN0aXZlID0gTGluZURpZmZEaXJlY3RpdmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saW5lRGlmZi5kaXJlY3RpdmUuanMubWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/ng-diff-match-patch/dist/lineDiff.directive.js\n");

/***/ }),

/***/ "./node_modules/ng-diff-match-patch/dist/processingDiff.directive.js":
/*!***************************************************************************!*\
  !*** ./node_modules/ng-diff-match-patch/dist/processingDiff.directive.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar core_1 = __webpack_require__(/*! @angular/core */ \"./node_modules/@angular/core/fesm5/core.js\");\nvar diffMatchPatch_service_1 = __webpack_require__(/*! ./diffMatchPatch.service */ \"./node_modules/ng-diff-match-patch/dist/diffMatchPatch.service.js\");\nvar ProcessingDiffDirective = (function () {\n    function ProcessingDiffDirective(el, dmp) {\n        this.el = el;\n        this.dmp = dmp;\n    }\n    ProcessingDiffDirective.prototype.ngOnInit = function () {\n        this.updateHtml();\n    };\n    ProcessingDiffDirective.prototype.ngOnChanges = function () {\n        this.updateHtml();\n    };\n    ProcessingDiffDirective.prototype.updateHtml = function () {\n        this.el.nativeElement.innerHTML = this.createHtml(this.dmp.getProcessingDiff(this.left, this.right));\n    };\n    // TODO: Need to fix this for line diffs\n    ProcessingDiffDirective.prototype.createHtml = function (diffs) {\n        var html;\n        html = '<div>';\n        for (var _i = 0, diffs_1 = diffs; _i < diffs_1.length; _i++) {\n            var diff = diffs_1[_i];\n            diff[1] = diff[1].replace(/\\n/g, '<br/>');\n            if (diff[0] === 0 /* Equal */) {\n                html += diff[1];\n            }\n            if (diff[0] === -1 /* Delete */) {\n                html += '<del>' + diff[1] + '</del>';\n            }\n            if (diff[0] === 1 /* Insert */) {\n                html += '<ins>' + diff[1] + '</ins>';\n            }\n        }\n        html += '</div>';\n        return html;\n    };\n    __decorate([\n        core_1.Input(),\n        __metadata(\"design:type\", String)\n    ], ProcessingDiffDirective.prototype, \"left\", void 0);\n    __decorate([\n        core_1.Input(),\n        __metadata(\"design:type\", String)\n    ], ProcessingDiffDirective.prototype, \"right\", void 0);\n    ProcessingDiffDirective = __decorate([\n        core_1.Directive({\n            selector: '[processingDiff]'\n        }),\n        __metadata(\"design:paramtypes\", [core_1.ElementRef,\n            diffMatchPatch_service_1.DiffMatchPatchService])\n    ], ProcessingDiffDirective);\n    return ProcessingDiffDirective;\n}());\nexports.ProcessingDiffDirective = ProcessingDiffDirective;\n//# sourceMappingURL=processingDiff.directive.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmctZGlmZi1tYXRjaC1wYXRjaC9kaXN0L3Byb2Nlc3NpbmdEaWZmLmRpcmVjdGl2ZS5qcz84OGNhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVELGFBQWEsbUJBQU8sQ0FBQyxpRUFBZTtBQUNwQywrQkFBK0IsbUJBQU8sQ0FBQyxtR0FBMEI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHFCQUFxQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmctZGlmZi1tYXRjaC1wYXRjaC9kaXN0L3Byb2Nlc3NpbmdEaWZmLmRpcmVjdGl2ZS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKFwiQGFuZ3VsYXIvY29yZVwiKTtcbnZhciBkaWZmTWF0Y2hQYXRjaF9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi9kaWZmTWF0Y2hQYXRjaC5zZXJ2aWNlXCIpO1xudmFyIFByb2Nlc3NpbmdEaWZmRGlyZWN0aXZlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQcm9jZXNzaW5nRGlmZkRpcmVjdGl2ZShlbCwgZG1wKSB7XG4gICAgICAgIHRoaXMuZWwgPSBlbDtcbiAgICAgICAgdGhpcy5kbXAgPSBkbXA7XG4gICAgfVxuICAgIFByb2Nlc3NpbmdEaWZmRGlyZWN0aXZlLnByb3RvdHlwZS5uZ09uSW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVIdG1sKCk7XG4gICAgfTtcbiAgICBQcm9jZXNzaW5nRGlmZkRpcmVjdGl2ZS5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlSHRtbCgpO1xuICAgIH07XG4gICAgUHJvY2Vzc2luZ0RpZmZEaXJlY3RpdmUucHJvdG90eXBlLnVwZGF0ZUh0bWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZWwubmF0aXZlRWxlbWVudC5pbm5lckhUTUwgPSB0aGlzLmNyZWF0ZUh0bWwodGhpcy5kbXAuZ2V0UHJvY2Vzc2luZ0RpZmYodGhpcy5sZWZ0LCB0aGlzLnJpZ2h0KSk7XG4gICAgfTtcbiAgICAvLyBUT0RPOiBOZWVkIHRvIGZpeCB0aGlzIGZvciBsaW5lIGRpZmZzXG4gICAgUHJvY2Vzc2luZ0RpZmZEaXJlY3RpdmUucHJvdG90eXBlLmNyZWF0ZUh0bWwgPSBmdW5jdGlvbiAoZGlmZnMpIHtcbiAgICAgICAgdmFyIGh0bWw7XG4gICAgICAgIGh0bWwgPSAnPGRpdj4nO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGRpZmZzXzEgPSBkaWZmczsgX2kgPCBkaWZmc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGRpZmYgPSBkaWZmc18xW19pXTtcbiAgICAgICAgICAgIGRpZmZbMV0gPSBkaWZmWzFdLnJlcGxhY2UoL1xcbi9nLCAnPGJyLz4nKTtcbiAgICAgICAgICAgIGlmIChkaWZmWzBdID09PSAwIC8qIEVxdWFsICovKSB7XG4gICAgICAgICAgICAgICAgaHRtbCArPSBkaWZmWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRpZmZbMF0gPT09IC0xIC8qIERlbGV0ZSAqLykge1xuICAgICAgICAgICAgICAgIGh0bWwgKz0gJzxkZWw+JyArIGRpZmZbMV0gKyAnPC9kZWw+JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkaWZmWzBdID09PSAxIC8qIEluc2VydCAqLykge1xuICAgICAgICAgICAgICAgIGh0bWwgKz0gJzxpbnM+JyArIGRpZmZbMV0gKyAnPC9pbnM+JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBodG1sICs9ICc8L2Rpdj4nO1xuICAgICAgICByZXR1cm4gaHRtbDtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbiAgICBdLCBQcm9jZXNzaW5nRGlmZkRpcmVjdGl2ZS5wcm90b3R5cGUsIFwibGVmdFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbiAgICBdLCBQcm9jZXNzaW5nRGlmZkRpcmVjdGl2ZS5wcm90b3R5cGUsIFwicmlnaHRcIiwgdm9pZCAwKTtcbiAgICBQcm9jZXNzaW5nRGlmZkRpcmVjdGl2ZSA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBjb3JlXzEuRGlyZWN0aXZlKHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnW3Byb2Nlc3NpbmdEaWZmXSdcbiAgICAgICAgfSksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbY29yZV8xLkVsZW1lbnRSZWYsXG4gICAgICAgICAgICBkaWZmTWF0Y2hQYXRjaF9zZXJ2aWNlXzEuRGlmZk1hdGNoUGF0Y2hTZXJ2aWNlXSlcbiAgICBdLCBQcm9jZXNzaW5nRGlmZkRpcmVjdGl2ZSk7XG4gICAgcmV0dXJuIFByb2Nlc3NpbmdEaWZmRGlyZWN0aXZlO1xufSgpKTtcbmV4cG9ydHMuUHJvY2Vzc2luZ0RpZmZEaXJlY3RpdmUgPSBQcm9jZXNzaW5nRGlmZkRpcmVjdGl2ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb2Nlc3NpbmdEaWZmLmRpcmVjdGl2ZS5qcy5tYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/ng-diff-match-patch/dist/processingDiff.directive.js\n");

/***/ }),

/***/ "./node_modules/ng-diff-match-patch/dist/semanticDiff.directive.js":
/*!*************************************************************************!*\
  !*** ./node_modules/ng-diff-match-patch/dist/semanticDiff.directive.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar core_1 = __webpack_require__(/*! @angular/core */ \"./node_modules/@angular/core/fesm5/core.js\");\nvar diffMatchPatch_service_1 = __webpack_require__(/*! ./diffMatchPatch.service */ \"./node_modules/ng-diff-match-patch/dist/diffMatchPatch.service.js\");\nvar SemanticDiffDirective = (function () {\n    function SemanticDiffDirective(el, dmp) {\n        this.el = el;\n        this.dmp = dmp;\n    }\n    SemanticDiffDirective.prototype.ngOnInit = function () {\n        this.updateHtml();\n    };\n    SemanticDiffDirective.prototype.ngOnChanges = function () {\n        this.updateHtml();\n    };\n    SemanticDiffDirective.prototype.updateHtml = function () {\n        if (!this.left) {\n            this.left = \"\";\n        }\n        if (!this.right) {\n            this.right = \"\";\n        }\n        if (typeof this.left === 'number' || typeof this.left === 'boolean') {\n            this.left = this.left.toString();\n        }\n        if (typeof this.right === 'number' || typeof this.right === 'boolean') {\n            this.right = this.right.toString();\n        }\n        this.el.nativeElement.innerHTML = this.createHtml(this.dmp.getSemanticDiff(this.left, this.right));\n    };\n    // TODO: Need to fix this for line diffs\n    SemanticDiffDirective.prototype.createHtml = function (diffs) {\n        var html;\n        html = '<div>';\n        for (var _i = 0, diffs_1 = diffs; _i < diffs_1.length; _i++) {\n            var diff = diffs_1[_i];\n            diff[1] = diff[1].replace(/\\n/g, '<br/>');\n            if (diff[0] === 0 /* Equal */) {\n                html += diff[1];\n            }\n            if (diff[0] === -1 /* Delete */) {\n                html += '<del>' + diff[1] + '</del>';\n            }\n            if (diff[0] === 1 /* Insert */) {\n                html += '<ins>' + diff[1] + '</ins>';\n            }\n        }\n        html += '</div>';\n        return html;\n    };\n    __decorate([\n        core_1.Input(),\n        __metadata(\"design:type\", Object)\n    ], SemanticDiffDirective.prototype, \"left\", void 0);\n    __decorate([\n        core_1.Input(),\n        __metadata(\"design:type\", Object)\n    ], SemanticDiffDirective.prototype, \"right\", void 0);\n    SemanticDiffDirective = __decorate([\n        core_1.Directive({\n            selector: '[semanticDiff]'\n        }),\n        __metadata(\"design:paramtypes\", [core_1.ElementRef,\n            diffMatchPatch_service_1.DiffMatchPatchService])\n    ], SemanticDiffDirective);\n    return SemanticDiffDirective;\n}());\nexports.SemanticDiffDirective = SemanticDiffDirective;\n//# sourceMappingURL=semanticDiff.directive.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmctZGlmZi1tYXRjaC1wYXRjaC9kaXN0L3NlbWFudGljRGlmZi5kaXJlY3RpdmUuanM/YzI0OCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RCxhQUFhLG1CQUFPLENBQUMsaUVBQWU7QUFDcEMsK0JBQStCLG1CQUFPLENBQUMsbUdBQTBCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxxQkFBcUI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL25nLWRpZmYtbWF0Y2gtcGF0Y2gvZGlzdC9zZW1hbnRpY0RpZmYuZGlyZWN0aXZlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb3JlXCIpO1xudmFyIGRpZmZNYXRjaFBhdGNoX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL2RpZmZNYXRjaFBhdGNoLnNlcnZpY2VcIik7XG52YXIgU2VtYW50aWNEaWZmRGlyZWN0aXZlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZW1hbnRpY0RpZmZEaXJlY3RpdmUoZWwsIGRtcCkge1xuICAgICAgICB0aGlzLmVsID0gZWw7XG4gICAgICAgIHRoaXMuZG1wID0gZG1wO1xuICAgIH1cbiAgICBTZW1hbnRpY0RpZmZEaXJlY3RpdmUucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZUh0bWwoKTtcbiAgICB9O1xuICAgIFNlbWFudGljRGlmZkRpcmVjdGl2ZS5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlSHRtbCgpO1xuICAgIH07XG4gICAgU2VtYW50aWNEaWZmRGlyZWN0aXZlLnByb3RvdHlwZS51cGRhdGVIdG1sID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMubGVmdCkge1xuICAgICAgICAgICAgdGhpcy5sZWZ0ID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMucmlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMucmlnaHQgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5sZWZ0ID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgdGhpcy5sZWZ0ID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHRoaXMubGVmdCA9IHRoaXMubGVmdC50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5yaWdodCA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHRoaXMucmlnaHQgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgdGhpcy5yaWdodCA9IHRoaXMucmlnaHQudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQuaW5uZXJIVE1MID0gdGhpcy5jcmVhdGVIdG1sKHRoaXMuZG1wLmdldFNlbWFudGljRGlmZih0aGlzLmxlZnQsIHRoaXMucmlnaHQpKTtcbiAgICB9O1xuICAgIC8vIFRPRE86IE5lZWQgdG8gZml4IHRoaXMgZm9yIGxpbmUgZGlmZnNcbiAgICBTZW1hbnRpY0RpZmZEaXJlY3RpdmUucHJvdG90eXBlLmNyZWF0ZUh0bWwgPSBmdW5jdGlvbiAoZGlmZnMpIHtcbiAgICAgICAgdmFyIGh0bWw7XG4gICAgICAgIGh0bWwgPSAnPGRpdj4nO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGRpZmZzXzEgPSBkaWZmczsgX2kgPCBkaWZmc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGRpZmYgPSBkaWZmc18xW19pXTtcbiAgICAgICAgICAgIGRpZmZbMV0gPSBkaWZmWzFdLnJlcGxhY2UoL1xcbi9nLCAnPGJyLz4nKTtcbiAgICAgICAgICAgIGlmIChkaWZmWzBdID09PSAwIC8qIEVxdWFsICovKSB7XG4gICAgICAgICAgICAgICAgaHRtbCArPSBkaWZmWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRpZmZbMF0gPT09IC0xIC8qIERlbGV0ZSAqLykge1xuICAgICAgICAgICAgICAgIGh0bWwgKz0gJzxkZWw+JyArIGRpZmZbMV0gKyAnPC9kZWw+JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkaWZmWzBdID09PSAxIC8qIEluc2VydCAqLykge1xuICAgICAgICAgICAgICAgIGh0bWwgKz0gJzxpbnM+JyArIGRpZmZbMV0gKyAnPC9pbnM+JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBodG1sICs9ICc8L2Rpdj4nO1xuICAgICAgICByZXR1cm4gaHRtbDtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjb3JlXzEuSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBTZW1hbnRpY0RpZmZEaXJlY3RpdmUucHJvdG90eXBlLCBcImxlZnRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY29yZV8xLklucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgU2VtYW50aWNEaWZmRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJyaWdodFwiLCB2b2lkIDApO1xuICAgIFNlbWFudGljRGlmZkRpcmVjdGl2ZSA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBjb3JlXzEuRGlyZWN0aXZlKHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnW3NlbWFudGljRGlmZl0nXG4gICAgICAgIH0pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW2NvcmVfMS5FbGVtZW50UmVmLFxuICAgICAgICAgICAgZGlmZk1hdGNoUGF0Y2hfc2VydmljZV8xLkRpZmZNYXRjaFBhdGNoU2VydmljZV0pXG4gICAgXSwgU2VtYW50aWNEaWZmRGlyZWN0aXZlKTtcbiAgICByZXR1cm4gU2VtYW50aWNEaWZmRGlyZWN0aXZlO1xufSgpKTtcbmV4cG9ydHMuU2VtYW50aWNEaWZmRGlyZWN0aXZlID0gU2VtYW50aWNEaWZmRGlyZWN0aXZlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VtYW50aWNEaWZmLmRpcmVjdGl2ZS5qcy5tYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/ng-diff-match-patch/dist/semanticDiff.directive.js\n");

/***/ }),

/***/ "./node_modules/ng-diff-match-patch/index.ts":
/*!***************************************************!*\
  !*** ./node_modules/ng-diff-match-patch/index.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./dist/diffMatchPatch.module */ \"./node_modules/ng-diff-match-patch/dist/diffMatchPatch.module.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./dist/diff.directive */ \"./node_modules/ng-diff-match-patch/dist/diff.directive.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./dist/lineDiff.directive */ \"./node_modules/ng-diff-match-patch/dist/lineDiff.directive.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./dist/semanticDiff.directive */ \"./node_modules/ng-diff-match-patch/dist/semanticDiff.directive.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./dist/processingDiff.directive */ \"./node_modules/ng-diff-match-patch/dist/processingDiff.directive.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./dist/diffMatchPatch.service */ \"./node_modules/ng-diff-match-patch/dist/diffMatchPatch.service.js\"), exports);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmctZGlmZi1tYXRjaC1wYXRjaC9pbmRleC50cz9iNWUyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLDJKQUE2QztBQUM3Qyw2SUFBc0M7QUFDdEMscUpBQTBDO0FBQzFDLDZKQUE4QztBQUM5QyxpS0FBZ0Q7QUFDaEQsNkpBQThDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL25nLWRpZmYtbWF0Y2gtcGF0Y2gvaW5kZXgudHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBmcm9tICcuL2Rpc3QvZGlmZk1hdGNoUGF0Y2gubW9kdWxlJztcbmV4cG9ydCAqIGZyb20gJy4vZGlzdC9kaWZmLmRpcmVjdGl2ZSc7XG5leHBvcnQgKiBmcm9tICcuL2Rpc3QvbGluZURpZmYuZGlyZWN0aXZlJztcbmV4cG9ydCAqIGZyb20gJy4vZGlzdC9zZW1hbnRpY0RpZmYuZGlyZWN0aXZlJztcbmV4cG9ydCAqIGZyb20gJy4vZGlzdC9wcm9jZXNzaW5nRGlmZi5kaXJlY3RpdmUnO1xuZXhwb3J0ICogZnJvbSAnLi9kaXN0L2RpZmZNYXRjaFBhdGNoLnNlcnZpY2UnO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/ng-diff-match-patch/index.ts\n");

/***/ })

}]);